<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>プロトコライト // ASCII PROTOCOLITE VI ANIMATED</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100;200;300;400&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #000000;
            color: #ffffff;
            line-height: 1;
            font-size: 12px;
            font-weight: 200;
            padding: 0;
            margin: 0;
        }

        .header {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 30px;
        }

        h1 {
            font-size: 13px;
            font-weight: 200;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        .subtitle {
            font-size: 10px;
            color: #999;
            letter-spacing: 0.2em;
        }

        /* Creatures are all white, backgrounds are colored by family */
        .ascii-display { color: #ffffff; }

        /* Family background colors */
        .bg-red { background-color: #cc0000; }
        .bg-green { background-color: #008800; }
        .bg-blue { background-color: #0044cc; }
        .bg-yellow { background-color: #cc9900; }
        .bg-purple { background-color: #8800cc; }
        .bg-cyan { background-color: #0088aa; }

        .main-container {
            display: flex;
            height: calc(100vh - 120px);
        }

        .sidebar {
            width: 320px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            padding: 30px 20px;
            overflow-y: auto;
        }

        .content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: #000000;
        }

        .control-section {
            margin-bottom: 30px;
        }

        .control-title {
            font-size: 10px;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #999;
            margin-bottom: 15px;
        }

        .family-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }

        .family-btn {
            padding: 12px;
            background: #2a2a2a;
            color: #ffffff;
            border: 1px solid #444;
            font-family: inherit;
            font-size: 9px;
            font-weight: 300;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
        }

        .family-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }

        .family-btn.active {
            background: #ffffff;
            color: #000000;
            border-color: #ffffff;
        }

        .family-btn[data-family="red"] { border-left: 3px solid #ff3333; }
        .family-btn[data-family="green"] { border-left: 3px solid #33ff33; }
        .family-btn[data-family="blue"] { border-left: 3px solid #3366ff; }
        .family-btn[data-family="yellow"] { border-left: 3px solid #ffff33; }
        .family-btn[data-family="purple"] { border-left: 3px solid #ff33ff; }
        .family-btn[data-family="cyan"] { border-left: 3px solid #33ffff; }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #ffffff;
            font-family: inherit;
            font-size: 10px;
            font-weight: 300;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: #cccccc;
            border-color: #cccccc;
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #ffffff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
            border-color: #666;
        }

        .stats-panel {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 10px;
            color: #999;
        }

        .stat-value {
            color: #fff;
            font-weight: 400;
        }

        .creatures-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            height: 100%;
        }

        .spreaders-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .children-panel {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #999;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .spreader-card {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .spreader-card:hover {
            transform: translateX(5px);
            box-shadow: -5px 0 15px rgba(255,255,255,0.1);
        }

        .ascii-display {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            line-height: 10px;
            letter-spacing: 0;
            white-space: pre;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }

        .spreader-ascii {
            font-size: 9px;
            line-height: 9px;
        }

        .child-ascii {
            font-size: 8px;
            line-height: 8px;
        }

        .creature-info {
            font-size: 9px;
            color: #888;
            margin-top: 8px;
        }

        .children-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .child-card {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 10px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .child-card:hover {
            background: #2a2a2a;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }

        /* Removed - creatures are all white, only backgrounds are colored */

        .dna-documentation {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 15px;
            margin-top: 20px;
            font-size: 9px;
            line-height: 1.6;
        }

        .dna-doc-title {
            font-weight: 400;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-size: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            color: #fff;
        }

        .dna-section {
            margin-bottom: 12px;
        }

        .dna-section-title {
            font-weight: 400;
            color: #fff;
            margin-bottom: 5px;
            font-size: 9px;
        }

        .dna-item {
            padding: 3px 0;
            color: #999;
            padding-left: 10px;
        }

        .dna-example {
            background: #1a1a1a;
            border: 1px solid #444;
            padding: 8px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            color: #ccc;
        }

        .inheritance-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .inherited-100 { background: #00cc00; }
        .inherited-80 { background: #ffcc00; }
        .inherited-random { background: #cc0000; }

        .dna-traits {
            font-size: 8px;
            color: #ccc;
            margin-top: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 3px;
            line-height: 1.5;
        }

        .dna-trait {
            display: inline-block;
            margin-right: 8px;
            padding: 2px 4px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 2px;
        }

        .dna-trait.inherited {
            background: #1a3a1a;
            border-color: #4a8;
        }

        .dna-trait.mutated {
            background: #3a1a1a;
            border-color: #a44;
        }

        /* Species badge - prominent display */
        .species-trait {
            font-weight: 300;
            font-size: 10px;
            background: #333;
            border: 1px solid #666;
            padding: 3px 6px;
            letter-spacing: 0.05em;
        }

        .parent-link {
            display: inline-block;
            padding: 2px 6px;
            background: #fff;
            color: #000;
            font-size: 8px;
            border-radius: 2px;
            margin-bottom: 5px;
        }

        .spreader-card.selected {
            border: 2px solid #fff;
            background: #3a3a20;
        }

        .child-card[data-parent-id] {
            position: relative;
        }

        .child-card[data-parent-id]::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .child-card.highlight-parent::before {
            border-color: #ffcc00;
        }

        /* Zoom Modal */
        .zoom-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s ease;
        }

        .zoom-modal.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .zoom-content {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 4px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
            animation: zoomIn 0.3s ease;
            border: 1px solid #444;
        }

        @keyframes zoomIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .zoom-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background: #000;
            color: #fff;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-close:hover {
            background: #ff0000;
            transform: rotate(90deg);
        }

        .zoom-ascii {
            font-family: 'Courier New', monospace;
            line-height: 1.2;
            white-space: pre;
            font-size: 20px;
            margin: 20px 0;
            text-align: center;
            padding: 20px;
            border-radius: 4px;
        }

        .zoom-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e8e8e8;
        }

        .zoom-title {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .zoom-id {
            font-size: 11px;
            color: #666;
            letter-spacing: 0.1em;
        }

        .zoom-dna-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #333;
        }

        .zoom-dna-title {
            font-size: 11px;
            font-weight: 400;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 15px;
            color: #fff;
        }

        .zoom-dna-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .zoom-dna-item {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 3px;
            font-size: 10px;
        }

        .zoom-dna-item.inherited {
            background: #1a3a1a;
            border-left: 3px solid #4a8;
        }

        .zoom-dna-item.mutated {
            background: #3a1a1a;
            border-left: 3px solid #a44;
        }

        .zoom-dna-label {
            font-weight: 400;
            color: #999;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.1em;
        }

        .zoom-dna-value {
            color: #fff;
            font-size: 12px;
            margin-top: 5px;
        }

        .zoom-btn {
            padding: 6px 12px;
            background: #fff;
            color: #000;
            border: none;
            font-family: inherit;
            font-size: 8px;
            font-weight: 300;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
            width: 100%;
        }

        .zoom-btn:hover {
            background: #ccc;
        }

        .spreader-card {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Zoom Modal -->
    <div class="zoom-modal" id="zoomModal" onclick="closeZoom(event)">
        <div class="zoom-content" onclick="event.stopPropagation()">
            <button class="zoom-close" onclick="closeZoom()">&times;</button>
            <div class="zoom-header">
                <div class="zoom-title" id="zoomTitle">SPREADER</div>
                <div class="zoom-id" id="zoomId">ID: ---</div>
            </div>
            <div class="zoom-ascii" id="zoomAscii"></div>
            <div class="zoom-dna-section">
                <div class="zoom-dna-title">DNA TRAITS</div>
                <div class="zoom-dna-grid" id="zoomDnaGrid"></div>
            </div>
        </div>
    </div>

    <div class="header">
        <h1>プロトコライト // ASCII PROTOCOLITE VI ANIMATED</h1>
        <div class="subtitle">MULTI-SPECIES DNA SYSTEM — 7 ANATOMICALLY DISTINCT CREATURES — GENERATIVE ASCII ART PROTOCOL — ANIMATED</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="control-section">
                <div class="control-title">Family Selection</div>
                <div class="family-grid">
                    <button class="family-btn" data-family="red" onclick="selectFamily('red')">RED<br>赤</button>
                    <button class="family-btn" data-family="green" onclick="selectFamily('green')">GREEN<br>緑</button>
                    <button class="family-btn" data-family="blue" onclick="selectFamily('blue')">BLUE<br>青</button>
                    <button class="family-btn" data-family="yellow" onclick="selectFamily('yellow')">YELLOW<br>黄</button>
                    <button class="family-btn" data-family="purple" onclick="selectFamily('purple')">PURPLE<br>紫</button>
                    <button class="family-btn" data-family="cyan" onclick="selectFamily('cyan')">CYAN<br>水</button>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">Actions</div>
                <div class="action-buttons">
                    <button class="btn" onclick="generateSpreader()">GENERATE SPREADER</button>
                    <button class="btn btn-secondary" onclick="clearFamily()">CLEAR FAMILY</button>
                    <button class="btn btn-secondary" onclick="clearAll()">CLEAR ALL</button>
                    <button class="btn btn-secondary" onclick="exportData()">EXPORT DATA</button>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <span>Active Families:</span>
                    <span class="stat-value" id="activeFamilies">0</span>
                </div>
                <div class="stat-item">
                    <span>Total Spreaders:</span>
                    <span class="stat-value" id="totalSpreaders">0</span>
                </div>
                <div class="stat-item">
                    <span>Total Children:</span>
                    <span class="stat-value" id="totalChildren">0</span>
                </div>
                <div class="stat-item">
                    <span>Current Family:</span>
                    <span class="stat-value" id="currentFamilyName">RED</span>
                </div>
            </div>

            <div class="dna-documentation">
                <div class="dna-doc-title">DNA System Documentation</div>

                <div class="dna-section">
                    <div class="dna-section-title">🧬 Color Inheritance</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Family color (100% inherited)</div>
                    <div class="dna-item">• Children always match parent's family</div>
                </div>

                <div class="dna-section">
                    <div class="dna-section-title">🎨 ASCII Attributes</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Body Type: 100% inherited</div>
                    <div class="dna-item">• square, round, diamond, mushroom, etc.</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Body Char: 80% inherited</div>
                    <div class="dna-item">• █ ▓ ▒ ░ (20% mutation chance)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Eye Char: 80% inherited</div>
                    <div class="dna-item">• ● ◉ ◎ ○ (always present!)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Antenna Tip: 80% inherited</div>
                    <div class="dna-item">• ● ◉ ○ ◎ ✦ ✧ ★</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Arm Style: 100% inherited</div>
                    <div class="dna-item">• block (█) or line (─)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Leg Style: 100% inherited</div>
                    <div class="dna-item">• block (█) or line (│)</div>
                </div>

                <div class="dna-section">
                    <div class="dna-section-title">✨ New Attributes (V)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Hat: 80% inherited</div>
                    <div class="dna-item">• ▀ ▄ ═ ╔╗ (if parent has hat)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-random"></span>Cigarette: Random</div>
                    <div class="dna-item">• ≈ ∼ ~ (10% chance)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Eye Size: 80% inherited</div>
                    <div class="dna-item">• Regular or MEGA eyes</div>
                </div>

                <div class="dna-section">
                    <div class="dna-section-title">📊 DNA Code Format</div>
                    <div class="dna-example">[BODY-CHAR-EYE-ARM-LEG-HAT]<br>Example: [sq-█-●-blo-blo-▀]<br><br>sq = square body<br>█ = solid body fill<br>● = round eyes<br>blo = block limbs<br>▀ = top hat</div>
                </div>
            </div>
        </div>

        <div class="content">
            <div class="creatures-grid">
                <div class="spreaders-panel">
                    <div class="panel-title">SPREADERS (24×24) — Click to breed</div>
                    <div id="spreaders"></div>
                </div>

                <div class="children-panel">
                    <div class="panel-title">CHILDREN (16×16)</div>
                    <div class="children-grid" id="children"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const families = {
            red: { name: 'RED', class: 'ascii-red' },
            green: { name: 'GREEN', class: 'ascii-green' },
            blue: { name: 'BLUE', class: 'ascii-blue' },
            yellow: { name: 'YELLOW', class: 'ascii-yellow' },
            purple: { name: 'PURPLE', class: 'ascii-purple' },
            cyan: { name: 'CYAN', class: 'ascii-cyan' }
        };

        let currentFamily = 'red';
        let familyData = {};

        // CRITICAL: Unique seed tracking to prevent duplicates
        let seedCounter = 0;
        let usedSeeds = new Set();

        // Initialize family data
        Object.keys(families).forEach(key => {
            familyData[key] = { spreaders: [], children: [] };
        });

        function generateASCIICreature(size, family, seed = null, parentDNA = null, siblingIndex = 0) {
            // If no seed provided, generate a GUARANTEED UNIQUE one
            if (seed === null) {
                // Use multiple sources of entropy + counter to ensure uniqueness
                let newSeed;
                let attempts = 0;
                do {
                    seedCounter++;
                    newSeed = Date.now() + seedCounter * 1000000 + Math.random() * 999999999;
                    attempts++;
                    if (attempts > 100) {
                        // Failsafe: just use counter if we can't find unused seed
                        newSeed = Date.now() + seedCounter * 1000000000;
                        break;
                    }
                } while (usedSeeds.has(newSeed));

                seed = newSeed;
                usedSeeds.add(seed);
            }

            // Seeded random
            let s = seed;
            function random() {
                s = (s * 9301 + 49297) % 233280;
                return s / 233280;
            }

            // DNA INHERITANCE SYSTEM
            const isChild = size === 16;
            let dna = {};

            if (parentDNA) {
                // CHILD: Inherit DNA from parent with mutations
                dna.species = parentDNA.species; // 100% inherited - SPECIES NEVER CHANGES
                dna.bodyType = parentDNA.bodyType; // 100% inherited
                dna.armStyle = parentDNA.armStyle; // 100% inherited
                dna.legStyle = parentDNA.legStyle; // 100% inherited

                // Body character: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.bodyChar = parentDNA.bodyChar;
                } else {
                    const bodyChars = ['█', '▓', '▒', '░'];
                    dna.bodyChar = bodyChars[Math.floor(random() * bodyChars.length)];
                }

                // Eye style: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.eyeChar = parentDNA.eyeChar;
                } else {
                    const eyeChars = ['●', '◉', '◎', '○'];
                    dna.eyeChar = eyeChars[Math.floor(random() * eyeChars.length)];
                }

                // Eye size: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.eyeSize = parentDNA.eyeSize;
                } else {
                    dna.eyeSize = random() > 0.5 ? 'normal' : 'mega';
                }

                // Antenna tip: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.antennaTip = parentDNA.antennaTip;
                } else {
                    const antennaTips = ['●', '◉', '○', '◎', '✦', '✧', '★'];
                    dna.antennaTip = antennaTips[Math.floor(random() * antennaTips.length)];
                }

                // Hat: 50% inherit if parent has hat (REDUCED from 80%)
                if (parentDNA.hatType && parentDNA.hatType !== 'none') {
                    if (random() < 0.50) {
                        dna.hatType = parentDNA.hatType;
                    } else {
                        const hatTypes = ['none', 'top', 'flat', 'double', 'fancy'];
                        dna.hatType = hatTypes[Math.floor(random() * hatTypes.length)];
                    }
                } else {
                    // Parent has no hat, HIGHER chance child gets one (30% up from 15%)
                    dna.hatType = random() < 0.30 ? ['top', 'flat', 'double', 'fancy'][Math.floor(random() * 4)] : 'none';
                }

                // Cigarette: Random 25% chance (INCREASED from 10%)
                dna.hasCigarette = random() < 0.25;

                // ═══ VI EXTENDED DNA INHERITANCE WITH HIGH SIBLING DIVERSITY ═══
                // Each sibling focuses mutations on DIFFERENT property groups
                // Sibling 0: Facial features mutate AGGRESSIVELY (eyes, mouth, nose)
                // Sibling 1: Body features mutate AGGRESSIVELY (texture, marks, head)
                // Sibling 2: Limb features mutate AGGRESSIVELY (arms, legs, claws)
                // This creates DRAMATICALLY DIFFERENT siblings while maintaining species identity

                // EXTREME mutation probabilities for DRAMATIC visual diversity
                // Children should look significantly different from parents!
                const facialMutationRate = siblingIndex === 0 ? 0.90 : 0.70;  // 90% vs 70% - MUCH higher!
                const bodyMutationRate = siblingIndex === 1 ? 0.90 : 0.70;    // 90% vs 70%
                const limbMutationRate = siblingIndex === 2 ? 0.90 : 0.70;    // 90% vs 70%
                const detailMutationRate = 0.75; // 75% for all details (up from 50%)
                const wildMutationChance = 0.40; // 40% chance of complete randomization (up from 15%!)

                // EYES - Sibling 0 mutates these more + wild mutation chance
                dna.numEyes = (random() < wildMutationChance) ? (Math.floor(random() * 4) + 2) :
                              (random() < (1 - facialMutationRate) ? parentDNA.numEyes : (Math.floor(random() * 4) + 2));
                dna.eyeStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                  (random() < (1 - facialMutationRate) ? parentDNA.eyeStyleIdx : Math.floor(random() * 18));
                dna.pupilStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 9) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.pupilStyleIdx : Math.floor(random() * 9));
                dna.hasPupils = (random() < wildMutationChance) ? (random() < 0.7) :
                                (random() < (1 - facialMutationRate) ? parentDNA.hasPupils : (random() < 0.7));
                dna.eyebrowStyleIdx = random() < (1 - facialMutationRate) ? parentDNA.eyebrowStyleIdx : Math.floor(random() * 7);
                dna.hasEyebrows = random() < (1 - facialMutationRate) ? parentDNA.hasEyebrows : (random() < 0.4);

                // MOUTH - Sibling 0 mutates these more + wild mutation chance
                dna.mouthStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 19) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.mouthStyleIdx : Math.floor(random() * 19));
                dna.teethStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 12) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.teethStyleIdx : Math.floor(random() * 12));
                dna.hasTeeth = random() < (1 - facialMutationRate) ? parentDNA.hasTeeth : (random() < 0.5);

                // NOSE - Sibling 0 mutates these more
                dna.noseStyleIdx = random() < (1 - facialMutationRate) ? parentDNA.noseStyleIdx : Math.floor(random() * 15);
                dna.hasNose = random() < (1 - facialMutationRate) ? parentDNA.hasNose : (random() < 0.3);

                // BODY - Sibling 1 mutates these more + wild mutation chance
                dna.headVariant = (random() < wildMutationChance) ? Math.floor(random() * 7) :
                                  (random() < (1 - bodyMutationRate) ? parentDNA.headVariant : Math.floor(random() * 7));
                dna.bodyTextureIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                     (random() < (1 - bodyMutationRate) ? parentDNA.bodyTextureIdx : Math.floor(random() * 18));
                dna.bellyMarkIdx = (random() < wildMutationChance) ? Math.floor(random() * 8) :
                                   (random() < (1 - bodyMutationRate) ? parentDNA.bellyMarkIdx : Math.floor(random() * 8));

                // LIMBS - Sibling 2 mutates these more + wild mutation chance
                dna.armStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 12) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.armStyleIdx : Math.floor(random() * 12));
                dna.legStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 11) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.legStyleIdx : Math.floor(random() * 11));
                dna.numArms = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                              (random() < (1 - limbMutationRate) ? parentDNA.numArms : (Math.floor(random() * 3) + 2));
                dna.numLegs = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                              (random() < (1 - limbMutationRate) ? parentDNA.numLegs : (Math.floor(random() * 3) + 2));
                dna.hasClaws = (random() < wildMutationChance) ? (random() < 0.6) :
                               (random() < (1 - limbMutationRate) ? parentDNA.hasClaws : (random() < 0.6));
                dna.hasToes = random() < (1 - limbMutationRate) ? parentDNA.hasToes : (random() < 0.5);

                // DETAILS - All siblings get 30% mutation
                dna.faceMarkIdx = random() < (1 - detailMutationRate) ? parentDNA.faceMarkIdx : Math.floor(random() * 9);
                dna.hasSpots = random() < (1 - detailMutationRate) ? parentDNA.hasSpots : (random() < 0.6);
                dna.scarMarkIdx = random() < (1 - detailMutationRate) ? parentDNA.scarMarkIdx : Math.floor(random() * 6);
                dna.hasScars = random() < (1 - detailMutationRate) ? parentDNA.hasScars : (random() < 0.2);

                // SPECIES-SPECIFIC - Apply same diversity pattern
                // Use bodyMutationRate for structural traits, facialMutationRate for appendages

                // Insectoid - EXPANDED with ALL trait mutations for maximum variety!
                dna.legStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 11) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.legStyleIdx : Math.floor(random() * 11));
                dna.eyeStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                  (random() < (1 - facialMutationRate) ? parentDNA.eyeStyleIdx : Math.floor(random() * 18));
                dna.antennaTip = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.antennaTip : Math.floor(random() * 18));
                dna.antennaLength = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.antennaLength : (Math.floor(random() * 3) + 2));
                dna.bodyTextureIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                     (random() < (1 - bodyMutationRate) ? parentDNA.bodyTextureIdx : Math.floor(random() * 18));
                dna.segmentWidth = (random() < wildMutationChance) ? Math.floor(random() * 2) :
                                   (random() < (1 - bodyMutationRate) ? parentDNA.segmentWidth : Math.floor(random() * 2));
                dna.hasWings = (random() < wildMutationChance) ? (random() < 0.5) :
                               (random() < (1 - limbMutationRate) ? parentDNA.hasWings : (random() < 0.5));
                dna.wingCharIdx = (random() < wildMutationChance) ? Math.floor(random() * 6) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.wingCharIdx : Math.floor(random() * 6));
                dna.mandibleStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 4) :
                                       (random() < (1 - facialMutationRate) ? parentDNA.mandibleStyleIdx : Math.floor(random() * 4));
                // New insectoid traits for even more variety
                dna.hasAntennae = (random() < wildMutationChance) ? (random() < 0.9) :
                                  (random() < (1 - facialMutationRate) ? (parentDNA.hasAntennae !== false) : (random() < 0.9));
                dna.legCount = (random() < wildMutationChance) ? (Math.floor(random() * 2) + 3) :
                               (random() < (1 - limbMutationRate) ? (parentDNA.legCount || 3) : (Math.floor(random() * 2) + 3));
                dna.hasStingers = (random() < wildMutationChance) ? (random() < 0.3) :
                                  (random() < (1 - detailMutationRate) ? parentDNA.hasStingers : (random() < 0.3));

                // Reptilian - EXPANDED with wild mutations
                dna.hasTongue = (random() < wildMutationChance) ? (random() < 0.7) :
                                (random() < (1 - facialMutationRate) ? parentDNA.hasTongue : (random() < 0.7));
                dna.hasSpines = (random() < wildMutationChance) ? (random() < 0.6) :
                                (random() < (1 - bodyMutationRate) ? parentDNA.hasSpines : (random() < 0.6));
                dna.tailStyle = (random() < wildMutationChance) ? Math.floor(random() * 3) :
                                (random() < (1 - limbMutationRate) ? parentDNA.tailStyle : Math.floor(random() * 3));
                dna.bodyHeightVariant = (random() < wildMutationChance) ? Math.floor(random() * 2) :
                                        (random() < (1 - bodyMutationRate) ? parentDNA.bodyHeightVariant : Math.floor(random() * 2));
                // New reptilian traits with HIGH mutation
                dna.hasHorns = (random() < wildMutationChance) ? (random() < 0.4) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasHorns : (random() < 0.4));
                dna.hasFrill = (random() < wildMutationChance) ? (random() < 0.3) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasFrill : (random() < 0.3));
                dna.spineCount = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                                 (random() < (1 - bodyMutationRate) ? parentDNA.spineCount : (Math.floor(random() * 3) + 2));
                dna.scaleSize = (random() < wildMutationChance) ? Math.floor(random() * 3) :
                                (random() < (1 - bodyMutationRate) ? parentDNA.scaleSize : Math.floor(random() * 3));

                // Mammalian
                dna.earStyle = random() < (1 - facialMutationRate) ? parentDNA.earStyle : Math.floor(random() * 3);
                dna.hasTail = random() < (1 - limbMutationRate) ? parentDNA.hasTail : (random() < 0.8);
                dna.hasWhiskers = random() < (1 - facialMutationRate) ? parentDNA.hasWhiskers : (random() < 0.7);

                // Skeletal - MASSIVELY EXPANDED with EXTREME wild mutation for maximum diversity
                // Each sibling can have dramatically different skeletal structure
                dna.jawStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                               (random() < (1 - facialMutationRate) ? parentDNA.jawStyle : Math.floor(random() * 5));
                dna.ribCount = (random() < wildMutationChance) ? (Math.floor(random() * 4) + 2) :
                               (random() < (1 - bodyMutationRate) ? parentDNA.ribCount : (Math.floor(random() * 4) + 2));
                dna.ribStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                               (random() < (1 - bodyMutationRate) ? parentDNA.ribStyle : Math.floor(random() * 5));
                dna.spineStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - bodyMutationRate) ? parentDNA.spineStyle : Math.floor(random() * 5));
                dna.spineHeightVariant = (random() < wildMutationChance) ? Math.floor(random() * 4) :
                                         (random() < (1 - bodyMutationRate) ? parentDNA.spineHeightVariant : Math.floor(random() * 4));
                dna.skullShape = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.skullShape : Math.floor(random() * 5));
                dna.eyeSocketStyle = (random() < wildMutationChance) ? Math.floor(random() * 6) :
                                     (random() < (1 - facialMutationRate) ? parentDNA.eyeSocketStyle : Math.floor(random() * 6));
                dna.nasalStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.nasalStyle : Math.floor(random() * 5));
                dna.armBoneStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                   (random() < (1 - limbMutationRate) ? parentDNA.armBoneStyle : Math.floor(random() * 5));
                dna.legBoneStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                   (random() < (1 - limbMutationRate) ? parentDNA.legBoneStyle : Math.floor(random() * 5));
                dna.jointStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - limbMutationRate) ? parentDNA.jointStyle : Math.floor(random() * 5));
                dna.fingerStyle = (random() < wildMutationChance) ? Math.floor(random() * 6) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.fingerStyle : Math.floor(random() * 6));
                dna.footStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                (random() < (1 - limbMutationRate) ? parentDNA.footStyle : Math.floor(random() * 5));
                // Boolean traits - higher mutation for dramatic variation
                dna.hasCracks = (random() < wildMutationChance) ? (random() < 0.4) :
                                (random() < (1 - detailMutationRate) ? parentDNA.hasCracks : (random() < 0.4));
                dna.hasSpinalCord = (random() < wildMutationChance) ? (random() < 0.3) :
                                    (random() < (1 - detailMutationRate) ? parentDNA.hasSpinalCord : (random() < 0.3));
                dna.hasExtraRibs = (random() < wildMutationChance) ? (random() < 0.3) :
                                   (random() < (1 - bodyMutationRate) ? parentDNA.hasExtraRibs : (random() < 0.3));
                dna.hasHorns = (random() < wildMutationChance) ? (random() < 0.4) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasHorns : (random() < 0.4));
                dna.hasTeeth = (random() < wildMutationChance) ? (random() < 0.7) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasTeeth : (random() < 0.7));
                dna.teethStyle = (random() < wildMutationChance) ? Math.floor(random() * 4) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.teethStyle : Math.floor(random() * 4));
                dna.boneThickness = (random() < wildMutationChance) ? Math.floor(random() * 3) :
                                    (random() < (1 - bodyMutationRate) ? parentDNA.boneThickness : Math.floor(random() * 3));
                dna.hasTail = (random() < wildMutationChance) ? (random() < 0.6) :
                              (random() < (1 - limbMutationRate) ? (parentDNA.hasTail !== false) : (random() < 0.6));
                dna.tailBoneCount = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 3) :
                                    (random() < (1 - limbMutationRate) ? (parentDNA.tailBoneCount || 4) : (Math.floor(random() * 3) + 3));

                // Alien
                dna.alienHeadVariant = random() < (1 - bodyMutationRate) ? parentDNA.alienHeadVariant : Math.floor(random() * 2);
                dna.hasAntennae = random() < (1 - facialMutationRate) ? parentDNA.hasAntennae : (random() < 0.7);
                dna.numTentacles = random() < (1 - limbMutationRate) ? parentDNA.numTentacles : (Math.floor(random() * 2) + 3);

                // Aquatic
                dna.hasDorsalFin = random() < (1 - bodyMutationRate) ? parentDNA.hasDorsalFin : (random() < 0.7);
                dna.tailShape = random() < (1 - limbMutationRate) ? parentDNA.tailShape : Math.floor(random() * 3);
                dna.numGills = random() < (1 - facialMutationRate) ? parentDNA.numGills : (Math.floor(random() * 2) + 2);

                // ═══ SPONTANEOUS MUTATIONS - Random features that can appear completely randomly! ═══
                // These override inherited traits to create truly surprising variations
                const spontaneousMutationChance = 0.20; // 20% chance for each trait to spontaneously mutate

                if (random() < spontaneousMutationChance) {
                    // Spontaneous body texture change
                    dna.bodyTextureIdx = Math.floor(random() * 18);
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous number of eyes change
                    dna.numEyes = Math.floor(random() * 4) + 2;
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous mouth style change
                    dna.mouthStyleIdx = Math.floor(random() * 19);
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous arm/leg count change
                    dna.numArms = Math.floor(random() * 3) + 2;
                    dna.numLegs = Math.floor(random() * 3) + 2;
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous head variant change
                    dna.headVariant = Math.floor(random() * 7);
                }
                // Random trait additions
                if (random() < 0.15) dna.hasTeeth = !dna.hasTeeth; // 15% flip teeth
                if (random() < 0.15) dna.hasNose = !dna.hasNose;   // 15% flip nose
                if (random() < 0.15) dna.hasEyebrows = !dna.hasEyebrows; // 15% flip eyebrows
                if (random() < 0.15) dna.hasClaws = !dna.hasClaws; // 15% flip claws

                // ═══ ANIMATION INHERITANCE - 30% chance to mutate stage ═══
                const stages = ['calm', 'nervous', 'adhd', 'crazy'];
                if (random() < 0.70) {
                    dna.animationStage = parentDNA.animationStage; // Inherit
                } else {
                    dna.animationStage = stages[Math.floor(random() * 4)]; // MUTATE!
                }

                // Apply speeds based on stage
                if (dna.animationStage === 'calm') {
                    dna.blinkSpeed = 7000 + Math.floor(random() * 5000);
                    dna.limbSpeed = 4000 + Math.floor(random() * 3000);
                    dna.antennaSpeed = 3500 + Math.floor(random() * 2500);
                } else if (dna.animationStage === 'nervous') {
                    dna.blinkSpeed = 2000 + Math.floor(random() * 2000);
                    dna.limbSpeed = 1000 + Math.floor(random() * 1000);
                    dna.antennaSpeed = 800 + Math.floor(random() * 700);
                } else if (dna.animationStage === 'adhd') {
                    dna.blinkSpeed = 500 + Math.floor(random() * 700);
                    dna.limbSpeed = 250 + Math.floor(random() * 350);
                    dna.antennaSpeed = 200 + Math.floor(random() * 300);
                } else { // crazy
                    dna.blinkSpeed = 100 + Math.floor(random() * 200);
                    dna.limbSpeed = 80 + Math.floor(random() * 120);
                    dna.antennaSpeed = 60 + Math.floor(random() * 90);
                }

                dna.blinkDelay = Math.floor(random() * 2000);
                dna.limbDelay = Math.floor(random() * 1000);
                dna.antennaDelay = Math.floor(random() * 800);

            } else {
                // SPREADER: Generate random DNA with SPECIES + ALL VARIATIONS
                const speciesTypes = ['insectoid', 'reptilian', 'mammalian', 'viral', 'alien', 'aquatic', 'skeletal'];
                dna.species = speciesTypes[Math.floor(random() * speciesTypes.length)];

                // OLD ATTRIBUTES (kept for compatibility)
                const bodyChars = ['█', '▓', '▒', '░'];
                const eyeChars = ['●', '◉', '◎', '○'];
                const antennaTips = ['●', '◉', '○', '◎', '✦', '✧', '★'];
                const armStyles = ['block', 'line'];
                const legStyles = ['block', 'line'];
                const hatTypes = ['none', 'none', 'none', 'top', 'flat', 'double', 'fancy'];

                dna.bodyChar = bodyChars[Math.floor(random() * bodyChars.length)];
                dna.eyeChar = eyeChars[Math.floor(random() * eyeChars.length)];
                dna.eyeSize = random() > 0.7 ? 'mega' : 'normal';
                dna.antennaTip = antennaTips[Math.floor(random() * antennaTips.length)];
                dna.armStyle = armStyles[Math.floor(random() * armStyles.length)];
                dna.legStyle = legStyles[Math.floor(random() * legStyles.length)];
                dna.hatType = hatTypes[Math.floor(random() * hatTypes.length)];
                dna.hasCigarette = random() < 0.10;

                // ═══ NEW: COMPREHENSIVE VARIATION DNA (seed-deterministic) ═══
                // Store ALL visual choices in DNA so different seeds = different appearance

                // EYES
                dna.numEyes = Math.floor(random() * 4) + 2; // 2-5
                dna.eyeStyleIdx = Math.floor(random() * 18); // 18 eye styles
                dna.pupilStyleIdx = Math.floor(random() * 9); // 9 pupil styles
                dna.hasPupils = random() < 0.7;
                dna.eyebrowStyleIdx = Math.floor(random() * 7);
                dna.hasEyebrows = random() < 0.4;

                // MOUTH
                dna.mouthStyleIdx = Math.floor(random() * 19); // 19 mouth styles
                dna.teethStyleIdx = Math.floor(random() * 12);
                dna.hasTeeth = random() < 0.5;

                // NOSE
                dna.noseStyleIdx = Math.floor(random() * 15);
                dna.hasNose = random() < 0.3;

                // BODY
                dna.headVariant = Math.floor(random() * 7);
                dna.bodyTextureIdx = Math.floor(random() * 18);
                dna.bellyMarkIdx = Math.floor(random() * 8);

                // LIMBS
                dna.armStyleIdx = Math.floor(random() * 12); // 12 arm styles
                dna.legStyleIdx = Math.floor(random() * 11); // 11 leg styles
                dna.numArms = Math.floor(random() * 3) + 2; // 2-4
                dna.numLegs = Math.floor(random() * 3) + 2; // 2-4
                dna.hasClaws = random() < 0.6;
                dna.hasToes = random() < 0.5;

                // DETAILS
                dna.faceMarkIdx = Math.floor(random() * 9);
                dna.hasSpots = random() < 0.6;
                dna.scarMarkIdx = Math.floor(random() * 6);
                dna.hasScars = random() < 0.2;

                // SPECIES-SPECIFIC
                // Insectoid - EXPANDED TRAITS
                dna.antennaLength = Math.floor(random() * 3) + 2; // 2-4
                dna.segmentWidth = Math.floor(random() * 2); // narrow or wide
                dna.hasWings = random() < 0.5;
                dna.wingCharIdx = Math.floor(random() * 6);
                dna.mandibleStyleIdx = Math.floor(random() * 4);
                dna.hasAntennae = random() < 0.9; // Most have antennae
                dna.legCount = Math.floor(random() * 2) + 3; // 3-4 pairs (6-8 legs)
                dna.hasStingers = random() < 0.3; // Tail stingers

                // Reptilian - EXPANDED TRAITS
                dna.hasTongue = random() < 0.7;
                dna.hasSpines = random() < 0.6;
                dna.tailStyle = Math.floor(random() * 3); // 0=serpentine, 1=spiked, 2=club
                dna.bodyHeightVariant = Math.floor(random() * 2); // Variable height
                dna.hasHorns = random() < 0.4; // Head horns/crests
                dna.hasFrill = random() < 0.3; // Neck frill
                dna.spineCount = Math.floor(random() * 3) + 2; // 2-4 dorsal spines
                dna.scaleSize = Math.floor(random() * 3); // 0=small, 1=medium, 2=large

                // Mammalian
                dna.earStyle = Math.floor(random() * 3); // 0=pointy, 1=round, 2=floppy
                dna.hasTail = random() < 0.8;
                dna.hasWhiskers = random() < 0.7;

                // Skeletal - MASSIVELY EXPANDED VARIETY
                dna.jawStyle = Math.floor(random() * 5); // 0-4 jaw types
                dna.ribCount = Math.floor(random() * 4) + 2; // 2-5 ribs per side
                dna.ribStyle = Math.floor(random() * 5); // 0-4 rib styles
                dna.spineStyle = Math.floor(random() * 5); // 0-4 spine styles
                dna.spineHeightVariant = Math.floor(random() * 4); // 0-3 height variants
                dna.skullShape = Math.floor(random() * 5); // 0-4 skull shapes
                dna.eyeSocketStyle = Math.floor(random() * 6); // 0-5 socket shapes
                dna.nasalStyle = Math.floor(random() * 5); // 0-4 nasal styles
                dna.armBoneStyle = Math.floor(random() * 5); // 0-4 arm styles
                dna.legBoneStyle = Math.floor(random() * 5); // 0-4 leg styles
                dna.jointStyle = Math.floor(random() * 5); // 0-4 joint styles
                dna.fingerStyle = Math.floor(random() * 6); // 0-5 finger patterns
                dna.footStyle = Math.floor(random() * 5); // 0-4 foot shapes
                dna.hasCracks = random() < 0.4; // Random bone cracks/damage
                dna.hasSpinalCord = random() < 0.3; // Internal spinal cord visible
                dna.hasExtraRibs = random() < 0.3; // Extra rib pairs
                dna.hasHorns = random() < 0.4; // Skull horns/protrusions
                dna.hasTeeth = random() < 0.7; // Teeth in skull
                dna.teethStyle = Math.floor(random() * 4); // Tooth patterns
                dna.boneThickness = Math.floor(random() * 3); // 0=thin, 1=normal, 2=thick
                dna.hasTail = random() < 0.6; // Skeletal tail
                dna.tailBoneCount = Math.floor(random() * 3) + 3; // 3-5 tail vertebrae

                // Alien
                dna.alienHeadVariant = Math.floor(random() * 2); // 0=huge, 1=medium
                dna.hasAntennae = random() < 0.7;
                dna.numTentacles = Math.floor(random() * 2) + 3; // 3-4 legs

                // Aquatic
                dna.hasDorsalFin = random() < 0.7;
                dna.tailShape = Math.floor(random() * 3); // 0=fan, 1=forked, 2=round
                dna.numGills = Math.floor(random() * 2) + 2; // 2-3 gill slits

                // ═══ ANIMATION PERSONALITY STAGES ═══
                const stages = ['calm', 'nervous', 'adhd', 'crazy'];
                dna.animationStage = stages[Math.floor(random() * 4)];

                // Set speeds based on stage - MORE EXTREME
                if (dna.animationStage === 'calm') {
                    dna.blinkSpeed = 7000 + Math.floor(random() * 5000);     // 7-12 seconds
                    dna.limbSpeed = 4000 + Math.floor(random() * 3000);      // 4-7 seconds
                    dna.antennaSpeed = 3500 + Math.floor(random() * 2500);   // 3.5-6 seconds
                } else if (dna.animationStage === 'nervous') {
                    dna.blinkSpeed = 2000 + Math.floor(random() * 2000);     // 2-4 seconds
                    dna.limbSpeed = 1000 + Math.floor(random() * 1000);      // 1-2 seconds
                    dna.antennaSpeed = 800 + Math.floor(random() * 700);     // 0.8-1.5 seconds
                } else if (dna.animationStage === 'adhd') {
                    dna.blinkSpeed = 500 + Math.floor(random() * 700);       // 0.5-1.2 seconds
                    dna.limbSpeed = 250 + Math.floor(random() * 350);        // 0.25-0.6 seconds
                    dna.antennaSpeed = 200 + Math.floor(random() * 300);     // 0.2-0.5 seconds
                } else { // crazy
                    dna.blinkSpeed = 100 + Math.floor(random() * 200);       // 0.1-0.3 seconds
                    dna.limbSpeed = 80 + Math.floor(random() * 120);         // 0.08-0.2 seconds
                    dna.antennaSpeed = 60 + Math.floor(random() * 90);       // 0.06-0.15 seconds
                }

                dna.blinkDelay = Math.floor(random() * 2000);
                dna.limbDelay = Math.floor(random() * 1000);
                dna.antennaDelay = Math.floor(random() * 800);
            }

            // Create grid
            const grid = Array(size).fill().map(() => Array(size).fill(' '));

            // Center coordinates
            const cx = Math.floor(size / 2);
            const cy = Math.floor(size / 2);

            // BODY TYPE - Inherited or random
            let bodyType;
            if (parentDNA && parentDNA.bodyType) {
                // CHILD: 100% inherit parent's body type
                bodyType = parentDNA.bodyType;
            } else {
                // SPREADER: Random body type
                const bodyTypes = isChild ?
                    ['square', 'round', 'diamond', 'mushroom'] :
                    ['square', 'round', 'invader', 'mushroom', 'ghost', 'diamond'];
                const bodyTypeIndex = Math.floor(random() * bodyTypes.length);
                bodyType = bodyTypes[bodyTypeIndex];
                dna.bodyType = bodyType; // Store in DNA
            }

            const bodyWidth = size === 24 ? 6 : 3;
            const bodyHeight = size === 24 ? 8 : 4;
            const bodyStartY = size === 24 ? 7 : 6;

            // Draw OUTLINED body using box-drawing characters
            // First pass: mark interior cells
            const bodyInterior = Array(size).fill().map(() => Array(size).fill(false));

            for (let y = 0; y < bodyHeight; y++) {
                for (let x = -bodyWidth; x <= bodyWidth; x++) {
                    const posY = bodyStartY + y;
                    const posX = cx + x;
                    const relX = x / bodyWidth;
                    const relY = (y - bodyHeight/2) / (bodyHeight/2);

                    let inBody = false;
                    switch(bodyType) {
                        case 'square':
                            inBody = true;
                            break;
                        case 'round':
                            inBody = Math.sqrt(relX*relX + relY*relY) <= 1.0;
                            break;
                        case 'diamond':
                            inBody = Math.abs(relX) + Math.abs(relY) <= 1.0;
                            break;
                        case 'mushroom':
                            if (isChild) {
                                inBody = relY < -0.2 ? true : Math.abs(relX) <= 0.7;
                            } else {
                                inBody = relY < 0 ? true : Math.abs(relX) <= 0.6;
                            }
                            break;
                        case 'invader':
                            if (relY < -0.3) inBody = Math.abs(relX) <= 0.7;
                            else if (relY < 0.3) inBody = true;
                            else inBody = Math.abs(relX) <= 0.85;
                            break;
                        case 'ghost':
                            if (relY < 0.5) inBody = Math.sqrt(relX*relX + relY*relY) <= 1.0;
                            else inBody = Math.abs(relX) <= 0.9 && (Math.floor(x + bodyWidth) % 2 === 0 || relY < 0.8);
                            break;
                    }

                    if (inBody && posX >= 0 && posX < size && posY >= 0 && posY < size) {
                        bodyInterior[posY][posX] = true;
                    }
                }
            }

            // Second pass: draw outlines only (edges of interior)
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (bodyInterior[y][x]) {
                        const isTop = y === 0 || !bodyInterior[y-1][x];
                        const isBottom = y === size-1 || !bodyInterior[y+1][x];
                        const isLeft = x === 0 || !bodyInterior[y][x-1];
                        const isRight = x === size-1 || !bodyInterior[y][x+1];

                        // Draw box-drawing characters for edges
                        if (isTop && isLeft) grid[y][x] = '┌';
                        else if (isTop && isRight) grid[y][x] = '┐';
                        else if (isBottom && isLeft) grid[y][x] = '└';
                        else if (isBottom && isRight) grid[y][x] = '┘';
                        else if (isTop || isBottom) grid[y][x] = '─';
                        else if (isLeft || isRight) grid[y][x] = '│';
                        else grid[y][x] = ' '; // Interior is hollow
                    }
                }
            }

            // Helper to check if cell is part of body structure
            const isBodyChar = (char) => ['┌', '┐', '└', '┘', '─', '│', '╔', '╗', '╚', '╝', '═', '║'].includes(char);

            // EYES - ALWAYS PRESENT (using DNA eye character and size)
            const eyeY = bodyStartY + 1;
            const hasMegaEyes = dna.eyeSize === 'mega';

            if (isChild) {
                // CHILDREN - Always have 1-3 eyes, bigger and more visible
                const eyeCount = 1 + Math.floor(random() * 3);

                if (eyeCount === 1) {
                    // Single cyclops eye
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            grid[eyeY + dy][cx + dx] = ' ';
                        }
                    }
                    grid[eyeY][cx] = dna.eyeChar;
                } else if (eyeCount === 2) {
                    // Two eyes
                    const eyeSpacing = 1;
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = -1; dx <= 0; dx++) {
                            grid[eyeY + dy][cx - eyeSpacing + dx] = ' ';
                            grid[eyeY + dy][cx + eyeSpacing + dx] = ' ';
                        }
                    }
                    grid[eyeY][cx - eyeSpacing] = dna.eyeChar;
                    grid[eyeY][cx + eyeSpacing] = dna.eyeChar;
                } else {
                    // Three eyes
                    for (let dx of [-2, 0, 2]) {
                        grid[eyeY][cx + dx] = dna.eyeChar;
                    }
                }
            } else {
                // SPREADERS - Always have BIG eyes (1-3 eyes, always prominent)
                const eyeCount = 1 + Math.floor(random() * 3); // 1, 2, or 3 eyes

                if (eyeCount === 1) {
                    // Giant cyclops eye
                    for (let dy = 0; dy < 3; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            grid[eyeY + dy][cx + dx] = ' ';
                        }
                    }
                    grid[eyeY + 1][cx - 1] = dna.eyeChar;
                    grid[eyeY + 1][cx] = dna.eyeChar;
                    grid[eyeY + 1][cx + 1] = dna.eyeChar;
                } else if (eyeCount === 2) {
                    // Two BIG eyes
                    const blockSpacing = 2;
                    for (let dy = 0; dy < 3; dy++) {
                        for (let dx = 0; dx < 3; dx++) {
                            grid[eyeY + dy][cx - blockSpacing - 2 + dx] = ' ';
                            grid[eyeY + dy][cx + blockSpacing + dx] = ' ';
                        }
                    }
                    grid[eyeY + 1][cx - blockSpacing - 1] = dna.eyeChar;
                    grid[eyeY + 1][cx + blockSpacing + 1] = dna.eyeChar;
                } else {
                    // Three eyes
                    for (let i of [-3, 0, 3]) {
                        grid[eyeY + 1][cx + i] = dna.eyeChar;
                    }
                }
            }

            // EYEBROWS - Above eyes (NEW)
            const browY = eyeY - 1;
            if (browY >= 0 && random() > 0.5) {
                const browChars = ['¯', '‾', '⁀', '⌢', '⌣', '‿', '⁔'];
                const browStyle = Math.floor(random() * 3);

                if (browStyle === 0) {
                    // Straight brows
                    if (grid[browY][cx - 1] === ' ') grid[browY][cx - 1] = '¯';
                    if (grid[browY][cx] === ' ') grid[browY][cx] = '¯';
                    if (grid[browY][cx + 1] === ' ') grid[browY][cx + 1] = '¯';
                } else if (browStyle === 1) {
                    // Angry brows
                    if (grid[browY][cx - 2] === ' ') grid[browY][cx - 2] = '\\';
                    if (grid[browY][cx + 2] === ' ') grid[browY][cx + 2] = '/';
                } else {
                    // Curved brows
                    const brow = browChars[Math.floor(random() * browChars.length)];
                    if (grid[browY][cx - 1] === ' ') grid[browY][cx - 1] = brow;
                    if (grid[browY][cx + 1] === ' ') grid[browY][cx + 1] = brow;
                }
            }

            // EARS - Side projections (NEW)
            if (random() > 0.6) {
                const earY = eyeY;
                const earChars = [')', '(', '>', '<', '⟩', '⟨', 'D', 'C'];

                // Find body edges at ear level
                let leftEar = cx, rightEar = cx;
                for (let x = cx; x >= 0; x--) {
                    if (isBodyChar(grid[earY][x])) leftEar = x;
                    else break;
                }
                for (let x = cx; x < size; x++) {
                    if (isBodyChar(grid[earY][x])) rightEar = x;
                    else break;
                }

                // Add ears outside body
                if (leftEar - 1 >= 0 && grid[earY][leftEar - 1] === ' ') {
                    grid[earY][leftEar - 1] = earChars[Math.floor(random() * earChars.length)];
                }
                if (rightEar + 1 < size && grid[earY][rightEar + 1] === ' ') {
                    grid[earY][rightEar + 1] = earChars[Math.floor(random() * earChars.length)];
                }
            }

            // NOSE - Add above mouth (NEW)
            const noseY = eyeY + (isChild ? 1 : 2);
            if (random() > 0.4 && noseY < size && grid[noseY][cx] === ' ') {
                const noseChars = ['v', 'V', '∨', 'ʌ', '△', '▽'];
                grid[noseY][cx] = noseChars[Math.floor(random() * noseChars.length)];
            }

            // MOUTH - More detailed with teeth
            if (random() > 0.2) {
                const mouthY = eyeY + (isChild ? 2 : 3);
                if (mouthY < size) {
                    const mouthStyle = Math.floor(random() * 4);

                    if (mouthStyle === 0) {
                        // Simple line mouth
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = '─';
                        if (random() > 0.5 && grid[mouthY][cx - 1] === ' ') grid[mouthY][cx - 1] = '─';
                        if (random() > 0.5 && grid[mouthY][cx + 1] === ' ') grid[mouthY][cx + 1] = '─';
                    } else if (mouthStyle === 1) {
                        // Teeth mouth
                        const teethChars = ['∩', '∪', 'w', 'W', 'm', 'M'];
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = teethChars[Math.floor(random() * teethChars.length)];
                    } else if (mouthStyle === 2) {
                        // Fangs
                        if (grid[mouthY][cx - 1] === ' ') grid[mouthY][cx - 1] = 'v';
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = '─';
                        if (grid[mouthY][cx + 1] === ' ') grid[mouthY][cx + 1] = 'v';
                    } else {
                        // Open mouth with tongue
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = 'o';
                        if (mouthY + 1 < size && grid[mouthY + 1][cx] === ' ') grid[mouthY + 1][cx] = 'U';
                    }
                }
            }

            // CIGARETTE
            if (dna.hasCigarette) {
                const cigY = eyeY + (isChild ? 2 : 3);
                const cigChars = ['≈', '∼', '~'];
                const cigChar = cigChars[Math.floor(random() * cigChars.length)];
                const cigX = cx + (random() > 0.5 ? (isChild ? 3 : 4) : (isChild ? -3 : -4));
                if (cigX >= 0 && cigX < size && cigY >= 0 && cigY < size) {
                    grid[cigY][cigX] = cigChar;
                    if (cigX + 1 < size && cigX + 1 >= 0) {
                        grid[cigY][cigX + 1] = '∙';
                    }
                }
            }

            // INTERNAL DETAILS - Skeleton, organs, patterns (NEW)
            const detailStartY = bodyStartY + (isChild ? 1 : 2);
            const detailEndY = bodyStartY + bodyHeight - (isChild ? 1 : 2);
            const detailStyle = Math.floor(random() * 5);

            if (detailStyle === 0) {
                // Spine/vertebrae down center
                for (let y = detailStartY; y < detailEndY; y++) {
                    if (grid[y][cx] === ' ') {
                        grid[y][cx] = Math.floor(random() * 2) === 0 ? '|' : '│';
                    }
                }
            } else if (detailStyle === 1) {
                // Ribcage pattern
                const ribY1 = detailStartY + 1;
                const ribY2 = detailStartY + 2;
                const ribY3 = detailStartY + 3;
                if (ribY1 < size) {
                    if (grid[ribY1][cx - 1] === ' ') grid[ribY1][cx - 1] = '(';
                    if (grid[ribY1][cx + 1] === ' ') grid[ribY1][cx + 1] = ')';
                }
                if (ribY2 < size) {
                    if (grid[ribY2][cx - 1] === ' ') grid[ribY2][cx - 1] = '(';
                    if (grid[ribY2][cx + 1] === ' ') grid[ribY2][cx + 1] = ')';
                }
                if (!isChild && ribY3 < size) {
                    if (grid[ribY3][cx - 1] === ' ') grid[ribY3][cx - 1] = '(';
                    if (grid[ribY3][cx + 1] === ' ') grid[ribY3][cx + 1] = ')';
                }
            } else if (detailStyle === 2) {
                // Internal organs (dots/circles)
                const organChars = ['●', '◉', '○', '◎', '⊙', '◌', '∘'];
                const organCount = isChild ? 2 : 4;
                for (let i = 0; i < organCount; i++) {
                    const orgX = cx + Math.floor((random() - 0.5) * (isChild ? 2 : 4));
                    const orgY = detailStartY + Math.floor(random() * (detailEndY - detailStartY));
                    if (orgX >= 0 && orgX < size && orgY >= 0 && orgY < size && grid[orgY][orgX] === ' ') {
                        grid[orgY][orgX] = organChars[Math.floor(random() * organChars.length)];
                    }
                }
            } else if (detailStyle === 3) {
                // Cross-hatch pattern
                for (let y = detailStartY; y < detailEndY; y += 2) {
                    for (let x = -1; x <= 1; x += 2) {
                        if (grid[y][cx + x] === ' ') {
                            grid[y][cx + x] = Math.floor(random() * 2) === 0 ? '/' : '\\';
                        }
                    }
                }
            } else {
                // Cellular/virus pattern
                const cellChars = ['◦', '·', '•', '∙', '◘', '◙'];
                const cellCount = isChild ? 3 : 6;
                for (let i = 0; i < cellCount; i++) {
                    const cellX = cx + Math.floor((random() - 0.5) * (isChild ? 3 : 5));
                    const cellY = detailStartY + Math.floor(random() * (detailEndY - detailStartY));
                    if (cellX >= 0 && cellX < size && cellY >= 0 && cellY < size && grid[cellY][cellX] === ' ') {
                        grid[cellY][cellX] = cellChars[Math.floor(random() * cellChars.length)];
                    }
                }
            }

            // ARMS - ALWAYS PRESENT with detailed hands/claws
            const armCount = 1 + Math.floor(random() * 4);
            const armLength = isChild ? (1 + Math.floor(random() * 2)) : (2 + Math.floor(random() * 4));
            const armStyle = dna.armStyle;
            const hasClaws = random() > 0.5;

            for (let a = 0; a < armCount; a++) {
                const currentArmY = bodyStartY + 2 + a * (isChild ? 1 : 2);
                if (currentArmY >= bodyStartY + bodyHeight) break;

                let leftBodyEdge = cx;
                let rightBodyEdge = cx;

                for (let x = cx; x >= 0; x--) {
                    if (isBodyChar(grid[currentArmY][x])) {
                        leftBodyEdge = x;
                    } else {
                        break;
                    }
                }

                for (let x = cx; x < size; x++) {
                    if (isBodyChar(grid[currentArmY][x])) {
                        rightBodyEdge = x;
                    } else {
                        break;
                    }
                }

                const armChar = armStyle === 'block' ? '█' : '─';

                // Draw arms
                for (let i = 1; i <= armLength; i++) {
                    if (leftBodyEdge - i >= 0) {
                        grid[currentArmY][leftBodyEdge - i] = armChar;
                    }
                    if (rightBodyEdge + i < size) {
                        grid[currentArmY][rightBodyEdge + i] = armChar;
                    }
                }

                // Add hands/claws at end of arms
                if (hasClaws) {
                    const clawChars = ['ψ', 'Ψ', '⋔', '⋋', '⋌', 'ʃ', '∫'];
                    const leftClawX = leftBodyEdge - armLength - 1;
                    const rightClawX = rightBodyEdge + armLength + 1;

                    if (leftClawX >= 0 && leftClawX < size) {
                        grid[currentArmY][leftClawX] = clawChars[Math.floor(random() * clawChars.length)];
                    }
                    if (rightClawX >= 0 && rightClawX < size) {
                        grid[currentArmY][rightClawX] = clawChars[Math.floor(random() * clawChars.length)];
                    }
                } else {
                    // Hands with fingers
                    const handChars = ['⊃', '⊂', 'ε', '϶', '∈', '∋'];
                    const leftHandX = leftBodyEdge - armLength - 1;
                    const rightHandX = rightBodyEdge + armLength + 1;

                    if (leftHandX >= 0 && leftHandX < size) {
                        grid[currentArmY][leftHandX] = handChars[Math.floor(random() * handChars.length)];
                    }
                    if (rightHandX >= 0 && rightHandX < size) {
                        grid[currentArmY][rightHandX] = handChars[Math.floor(random() * handChars.length)];
                    }
                }
            }

            // LEGS - ALWAYS PRESENT, using DNA leg style
            const legCount = 1 + Math.floor(random() * 4);
            const legY = bodyStartY + bodyHeight;
            const legLength = isChild ? (1 + Math.floor(random() * 2)) : (2 + Math.floor(random() * 3));
            const legStyle = dna.legStyle;

            const bodyBottomPositions = [];
            for (let x = 0; x < size; x++) {
                if (grid[legY - 1] && isBodyChar(grid[legY - 1][x])) {
                    bodyBottomPositions.push(x);
                }
            }

            const legPositions = [];
            if (bodyBottomPositions.length > 0) {
                if (legCount === 1) {
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length / 2)]);
                } else if (legCount === 2) {
                    const leftPos = Math.floor(bodyBottomPositions.length * 0.25);
                    const rightPos = Math.floor(bodyBottomPositions.length * 0.75);
                    legPositions.push(bodyBottomPositions[leftPos]);
                    legPositions.push(bodyBottomPositions[rightPos]);
                } else if (legCount === 3) {
                    legPositions.push(bodyBottomPositions[0]);
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length / 2)]);
                    legPositions.push(bodyBottomPositions[bodyBottomPositions.length - 1]);
                } else {
                    legPositions.push(bodyBottomPositions[0]);
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length * 0.33)]);
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length * 0.66)]);
                    legPositions.push(bodyBottomPositions[bodyBottomPositions.length - 1]);
                }
            }

            const legChar = legStyle === 'block' ? '█' : '│';
            const hasFeet = random() > 0.4;

            for (let legX of legPositions) {
                if (legX >= 0 && legX < size) {
                    // Draw leg
                    for (let i = 0; i < legLength; i++) {
                        if (legY + i < size) {
                            grid[legY + i][legX] = legChar;
                        }
                    }

                    // Add feet/claws at end of legs
                    const footY = legY + legLength;
                    if (hasFeet && footY < size) {
                        if (random() > 0.5) {
                            // Clawed feet
                            const footChars = ['ʌ', '^', '∧', '⊓', 'Ʌ', 'ʌ'];
                            grid[footY][legX] = footChars[Math.floor(random() * footChars.length)];
                        } else {
                            // Flat feet/pads
                            const padChars = ['_', '⊥', '┴', '⊢', '⊣'];
                            grid[footY][legX] = padChars[Math.floor(random() * padChars.length)];
                        }
                    }
                }
            }

            // ANTENNAS - ALWAYS PRESENT, using DNA antenna tip
            const antennaCount = 1 + Math.floor(random() * 4);
            const antennaLength = isChild ? 1 : (1 + Math.floor(random() * 2));

            const bodyTopPositions = [];
            for (let x = 0; x < size; x++) {
                if (grid[bodyStartY] && isBodyChar(grid[bodyStartY][x])) {
                    bodyTopPositions.push(x);
                }
            }

            const antennaPositions = [];
            if (bodyTopPositions.length > 0) {
                if (antennaCount === 1) {
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length / 2)]);
                } else if (antennaCount === 2) {
                    const leftPos = Math.floor(bodyTopPositions.length * 0.25);
                    const rightPos = Math.floor(bodyTopPositions.length * 0.75);
                    antennaPositions.push(bodyTopPositions[leftPos]);
                    antennaPositions.push(bodyTopPositions[rightPos]);
                } else if (antennaCount === 3) {
                    antennaPositions.push(bodyTopPositions[0]);
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length / 2)]);
                    antennaPositions.push(bodyTopPositions[bodyTopPositions.length - 1]);
                } else {
                    antennaPositions.push(bodyTopPositions[0]);
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length * 0.33)]);
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length * 0.66)]);
                    antennaPositions.push(bodyTopPositions[bodyTopPositions.length - 1]);
                }
            }

            for (let antennaX of antennaPositions) {
                for (let i = 1; i <= antennaLength; i++) {
                    const antennaY = bodyStartY - i;
                    if (antennaY >= 0) {
                        if (i === antennaLength) {
                            // Antenna tip - use DNA antenna tip
                            grid[antennaY][antennaX] = dna.antennaTip;
                        } else {
                            // Antenna stem
                            grid[antennaY][antennaX] = '│';
                        }

                        // Add bulbs/nodes along antenna for spreaders
                        if (!isChild && i === Math.floor(antennaLength / 2) && random() > 0.5) {
                            const bulbChars = ['○', '◯', '◌', '⊙', '⊚'];
                            grid[antennaY][antennaX] = bulbChars[Math.floor(random() * bulbChars.length)];
                        }
                    }
                }
            }

            // HORNS/SPIKES on body sides (NEW)
            if (random() > 0.6 && !isChild) {
                const hornCount = 1 + Math.floor(random() * 3);
                const hornChars = ['>', '<', '⟩', '⟨', '〉', '〈', '⊳', '⊲'];
                for (let h = 0; h < hornCount; h++) {
                    const hornY = bodyStartY + 2 + h * 2;
                    if (hornY < bodyStartY + bodyHeight) {
                        // Left horn
                        let leftEdge = cx;
                        for (let x = cx; x >= 0; x--) {
                            if (isBodyChar(grid[hornY][x])) leftEdge = x;
                            else break;
                        }
                        if (leftEdge - 1 >= 0 && grid[hornY][leftEdge - 1] === ' ') {
                            grid[hornY][leftEdge - 1] = hornChars[Math.floor(random() * hornChars.length)];
                        }

                        // Right horn
                        let rightEdge = cx;
                        for (let x = cx; x < size; x++) {
                            if (isBodyChar(grid[hornY][x])) rightEdge = x;
                            else break;
                        }
                        if (rightEdge + 1 < size && grid[hornY][rightEdge + 1] === ' ') {
                            grid[hornY][rightEdge + 1] = hornChars[Math.floor(random() * hornChars.length)];
                        }
                    }
                }
            }

            // TENTACLES - Alternative to some arms/legs (NEW)
            if (random() > 0.7) {
                const tentacleCount = 1 + Math.floor(random() * 3);
                const tentacleChars = ['~', '≈', '∼', '⌇', '⌢', '⌣'];

                for (let t = 0; t < tentacleCount; t++) {
                    const tentacleY = bodyStartY + bodyHeight + t;
                    if (tentacleY < size) {
                        const tentacleX = cx + Math.floor((random() - 0.5) * (bodyWidth * 2));
                        if (tentacleX >= 0 && tentacleX < size && grid[tentacleY][tentacleX] === ' ') {
                            grid[tentacleY][tentacleX] = tentacleChars[Math.floor(random() * tentacleChars.length)];

                            // Extend tentacle
                            if (tentacleY + 1 < size && grid[tentacleY + 1][tentacleX] === ' ') {
                                grid[tentacleY + 1][tentacleX] = tentacleChars[Math.floor(random() * tentacleChars.length)];
                            }
                        }
                    }
                }
            }

            // TAIL - Protruding from bottom (NEW)
            if (random() > 0.65 && !isChild) {
                const tailLength = 2 + Math.floor(random() * 3);
                const tailChars = ['/', '\\', '|', '│', '╱', '╲'];
                const tailStartY = bodyStartY + bodyHeight;
                const tailX = cx + (random() > 0.5 ? 1 : -1);

                for (let t = 0; t < tailLength; t++) {
                    const ty = tailStartY + t;
                    const tx = tailX + Math.floor((random() - 0.5) * 2);
                    if (ty < size && tx >= 0 && tx < size && grid[ty][tx] === ' ') {
                        grid[ty][tx] = tailChars[Math.floor(random() * tailChars.length)];
                    }
                }

                // Tail tip
                const tipY = tailStartY + tailLength;
                const tipX = tailX;
                if (tipY < size && tipX >= 0 && tipX < size && grid[tipY][tipX] === ' ') {
                    const tipChars = ['▼', '▽', '◢', '◣', '◤', '◥'];
                    grid[tipY][tipX] = tipChars[Math.floor(random() * tipChars.length)];
                }
            }

            // HAT - Drawn above antennas (NEW)
            if (dna.hatType && dna.hatType !== 'none') {
                const hatY = bodyStartY - antennaLength - 1;
                if (hatY >= 0) {
                    switch(dna.hatType) {
                        case 'top':
                            // Top hat: ▀
                            for (let dx = -2; dx <= 2; dx++) {
                                if (cx + dx >= 0 && cx + dx < size) {
                                    grid[hatY][cx + dx] = '▀';
                                }
                            }
                            if (hatY + 1 < size) {
                                grid[hatY + 1][cx] = '█';
                            }
                            break;
                        case 'flat':
                            // Flat cap: ═══
                            for (let dx = -2; dx <= 2; dx++) {
                                if (cx + dx >= 0 && cx + dx < size) {
                                    grid[hatY][cx + dx] = '═';
                                }
                            }
                            break;
                        case 'double':
                            // Double layer: ▄▄▄
                            for (let dx = -2; dx <= 2; dx++) {
                                if (cx + dx >= 0 && cx + dx < size && hatY - 1 >= 0) {
                                    grid[hatY - 1][cx + dx] = '▀';
                                    grid[hatY][cx + dx] = '▄';
                                }
                            }
                            break;
                        case 'fancy':
                            // Fancy: ╔═╗
                            if (cx - 2 >= 0 && cx + 2 < size) {
                                grid[hatY][cx - 2] = '╔';
                                grid[hatY][cx - 1] = '═';
                                grid[hatY][cx] = '═';
                                grid[hatY][cx + 1] = '═';
                                grid[hatY][cx + 2] = '╗';
                            }
                            break;
                    }
                }
            }

            // ═══════════════════════════════════════════════════════════
            // SPECIES-SPECIFIC BEAUTIFUL RENDERING
            // Clear grid and redraw with proper anatomical structures
            // ═══════════════════════════════════════════════════════════

            // Clear the grid completely
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    grid[y][x] = ' ';
                }
            }

            const species = dna.species;

            // ═══════════════════════════════════════════════════════════
            // COMPREHENSIVE ASCII MARK LIBRARY - MAXIMUM DETAIL & VARIETY
            // ═══════════════════════════════════════════════════════════

            // ARM STYLES (horizontal appendages) with CLAWS
            const ARM_STYLES = [
                { chars: ['─', '─', '─'], tip: '⟩', claw: '☆' },
                { chars: ['/', '\\', '/', '\\'], tip: '\\', claw: '◊' },
                { chars: ['~', '~', '~'], tip: '≈', claw: '≋' },
                { chars: ['─', '─', '>'], tip: '', claw: '►' },
                { chars: ['═', '═', '►'], tip: '', claw: '▶' },
                { chars: [')', ')', ')'], tip: '»', claw: '⟩' },
                { chars: ['>', '─', '─'], tip: '─', claw: '╌' },
                { chars: ['╱', '─', '╲'], tip: '╲', claw: '◀' },
                { chars: ['~', '─', '~'], tip: '~', claw: '∿' },
                { chars: ['•', '─', '•'], tip: '◉', claw: '◎' },
                { chars: ['=', '=', '='], tip: '≡', claw: '▣' },
                { chars: ['╌', '╌', '╌'], tip: '╍', claw: '▪' },
            ];

            // LEG STYLES (vertical appendages) with FEET/TOES
            const LEG_STYLES = [
                { chars: ['│', '│'], foot: '⊥', toe: 'w' },
                { chars: ['/', '\\'], foot: '▼', toe: 'v' },
                { chars: ['╱', '╲'], foot: '╲', toe: '◢' },
                { chars: ['┃', '┃'], foot: '▀', toe: '■' },
                { chars: [')', ')'], foot: 'U', toe: '∪' },
                { chars: ['│', '╱'], foot: '╲', toe: '╱' },
                { chars: ['╲', '│'], foot: '▄', toe: '▀' },
                { chars: ['┊', '┊'], foot: '·', toe: '∴' },
                { chars: ['║', '║'], foot: '■', toe: '▪' },
                { chars: ['▼', '│'], foot: '▼', toe: '▽' },
                { chars: [')', '│'], foot: '╰', toe: '◡' },
            ];

            // EYES with PUPILS
            const EYE_STYLES = ['●', '◉', '◎', '○', '◯', '⬡', '■', '◆', '▣', '⊙', '◐', '◑', '◔', '◕', '⊗', '⊕', '◈', '◘'];
            const PUPIL_STYLES = ['·', '•', '▪', '○', '-', '|', '+', 'x', '◦'];
            const EYEBROW_STYLES = ['‾', '¯', '⌃', '╲╱', '/', '\\', '^'];

            // MOUTHS with TEETH
            const MOUTH_STYLES = ['o', 'ω', '▽', '△', '◇', '═', '─', '╰╯', '⌢', '⌣', '∪', '∩', 'ʖ', '◡', '〰', 'v', 'V', 'w', 'W'];
            const TEETH_STYLES = ['v', 'V', 'w', 'W', 'vv', 'VV', '∧', '∨', '▲', '▼', 'ʌ', 'vVv'];

            // NOSE/NOSTRIL
            const NOSE_STYLES = ['▼', '▽', 'v', 'V', '◇', '◊', ':', '∴', '⌄', '∧', ')', '(', '•', '▪', '··'];

            // HORNS/CRESTS
            const HORN_STYLES = ['▲', '△', '▴', '▵', '⟁', '⋀', '◬', '◭', '◮', '╱', '╲', '⊼', '⊽', '∧', 'Λ', '^'];

            // SPIKES/SPINES
            const SPINE_STYLES = ['▲', '▴', '△', '⋀', '^', 'Λ', '∧', '⊼', '◊', '◈', '※', '▴▴', '▲▲'];

            // BODY TEXTURES & PATTERNS
            const BODY_TEXTURES = ['▓', '▒', '░', '▪', '▫', '◇', '◆', '◊', '•', '·', ':', '※', '✦', '✧', '◈', '◉', '⊗', '⊙'];
            const SCALE_PATTERNS = ['◇', '◊', '◈', '◆', '▫', '▪', '⋄', '◇◊', '▫▪'];
            const FUR_PATTERNS = ['░', '▒', '▓', '∴', '∵', ':', '·', ':::'];

            // ANTENNA/HORN TIPS
            const ANTENNA_TIPS = ['●', '◉', '○', '◎', '✦', '✧', '★', '☆', '▲', '△', '◆', '◇', '※', '⚝', '◈', '⊙', '⊕', '◘'];

            // TAIL STYLES with TIPS
            const TAIL_STYLES = [
                { chars: ['╲', '╲'], tip: '▼', spikes: false },
                { chars: ['│', '│'], tip: '●', spikes: false },
                { chars: ['╱', '╲'], tip: '◆', spikes: true },
                { chars: ['~', '~'], tip: '≈', spikes: false },
                { chars: ['≈', '≈'], tip: '≋', spikes: false },
                { chars: ['S', 'S'], tip: '○', spikes: false },
                { chars: [')', ')'], tip: '⟩', spikes: false },
                { chars: ['╲', '│'], tip: '♦', spikes: true },
            ];

            // WING PATTERNS
            const WING_PATTERNS = [
                ['/', '/', '/'],
                ['╱', '╱', '╱'],
                [')', ')', ')'],
                ['≈', '≈', '≈'],
                ['~', '~', '~'],
                ['⟩', '>', '>'],
            ];

            // FACIAL/BODY MARKINGS
            const FACE_MARKS = ['·', '•', ':', '※', '◊', '◈', '▪', '▫', '◦'];
            const BELLY_MARKS = ['◇', '◊', '◈', '▫', '○', '◯', '◦', '∘'];
            const SCAR_MARKS = ['/', '\\', 'X', 'x', '╱', '╲'];

            // Render based on species type
            if (species === 'insectoid') {
                // ═══ INSECTOID: 6-legged creatures with EXTREME variety ═══

                // ═══ READ ALL VARIATIONS FROM DNA (NOT random during render!) ═══
                const legStyleIdx = dna.legStyleIdx || 0;
                const legStyle = LEG_STYLES[legStyleIdx];
                const eyeStyle = EYE_STYLES[dna.eyeStyleIdx || 0];
                const antennaTip = ANTENNA_TIPS[dna.antennaTip || 0]; // fallback for old DNA
                const antennaLength = dna.antennaLength || 3;
                const bodyTexture = BODY_TEXTURES[dna.bodyTextureIdx || 0];
                const hasWings = dna.hasWings && !isChild;
                const wingChar = dna.wingCharIdx < 3 ? '/' : '╱';
                const mandibleStyle = dna.mandibleStyleIdx || 0;
                const segmentWidth = dna.segmentWidth || 0;
                const hasAntennae = dna.hasAntennae !== false; // Default true
                const legCount = dna.legCount || 3; // Default 3 pairs (6 legs)
                const hasStingers = dna.hasStingers || false;

                const segH = isChild ? 2 : 3;
                const baseY = isChild ? 5 : 6;

                // HEAD segment (variable width)
                const headW = segmentWidth === 0 ? 2 : (isChild ? 2 : 3);
                if (baseY >= 0 && baseY < size) {
                    // Top of head with curves
                    if (cx - headW >= 0) grid[baseY][cx - headW] = '╭';
                    for (let x = cx - headW + 1; x < cx + headW; x++) {
                        if (x >= 0 && x < size) grid[baseY][x] = '─';
                    }
                    if (cx + headW < size) grid[baseY][cx + headW] = '╮';
                }
                // Head sides
                for (let y = baseY + 1; y < baseY + segH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - headW >= 0) grid[y][cx - headW] = '│';
                        if (cx + headW < size) grid[y][cx + headW] = '│';
                    }
                }
                // Bottom of head with curves
                if (baseY + segH - 1 >= 0 && baseY + segH - 1 < size) {
                    if (cx - headW >= 0) grid[baseY + segH - 1][cx - headW] = '╰';
                    for (let x = cx - headW + 1; x < cx + headW; x++) {
                        if (x >= 0 && x < size) grid[baseY + segH - 1][x] = '─';
                    }
                    if (cx + headW < size) grid[baseY + segH - 1][cx + headW] = '╯';
                }

                // COMPOUND EYES (from library)
                if (baseY + 1 >= 0 && baseY + 1 < size) {
                    if (cx - 1 >= 0) grid[baseY + 1][cx - 1] = eyeStyle;
                    if (cx + 1 < size) grid[baseY + 1][cx + 1] = eyeStyle;
                }

                // BODY TEXTURE
                if (baseY + 1 >= 0 && baseY + 1 < size && cx >= 0 && cx < size) {
                    grid[baseY + 1][cx] = bodyTexture;
                }

                // THORAX segment (widest, rounded)
                const thoraxY = baseY + segH;
                const thoraxW = 3;
                if (thoraxY >= 0 && thoraxY < size) {
                    // Top of thorax with curves
                    if (cx - thoraxW >= 0) grid[thoraxY][cx - thoraxW] = '╭';
                    for (let x = cx - thoraxW + 1; x < cx + thoraxW; x++) {
                        if (x >= 0 && x < size) grid[thoraxY][x] = '─';
                    }
                    if (cx + thoraxW < size) grid[thoraxY][cx + thoraxW] = '╮';
                }
                // Thorax sides
                for (let y = thoraxY + 1; y < thoraxY + segH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - thoraxW >= 0) grid[y][cx - thoraxW] = '│';
                        if (cx + thoraxW < size) grid[y][cx + thoraxW] = '│';
                    }
                }
                // Bottom of thorax with curves
                if (thoraxY + segH - 1 >= 0 && thoraxY + segH - 1 < size) {
                    if (cx - thoraxW >= 0) grid[thoraxY + segH - 1][cx - thoraxW] = '╰';
                    for (let x = cx - thoraxW + 1; x < cx + thoraxW; x++) {
                        if (x >= 0 && x < size) grid[thoraxY + segH - 1][x] = '─';
                    }
                    if (cx + thoraxW < size) grid[thoraxY + segH - 1][cx + thoraxW] = '╯';
                }

                // ABDOMEN segment (rounded)
                const abdomenY = thoraxY + segH;
                const abdomenW = 2;
                if (abdomenY >= 0 && abdomenY < size) {
                    // Top of abdomen with curves
                    if (cx - abdomenW >= 0) grid[abdomenY][cx - abdomenW] = '╭';
                    for (let x = cx - abdomenW + 1; x < cx + abdomenW; x++) {
                        if (x >= 0 && x < size) grid[abdomenY][x] = '─';
                    }
                    if (cx + abdomenW < size) grid[abdomenY][cx + abdomenW] = '╮';
                }
                // Abdomen sides
                for (let y = abdomenY + 1; y < abdomenY + segH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - abdomenW >= 0) grid[y][cx - abdomenW] = '│';
                        if (cx + abdomenW < size) grid[y][cx + abdomenW] = '│';
                    }
                }
                // Bottom of abdomen with curves
                if (abdomenY + segH - 1 >= 0 && abdomenY + segH - 1 < size) {
                    if (cx - abdomenW >= 0) grid[abdomenY + segH - 1][cx - abdomenW] = '╰';
                    for (let x = cx - abdomenW + 1; x < cx + abdomenW; x++) {
                        if (x >= 0 && x < size) grid[abdomenY + segH - 1][x] = '─';
                    }
                    if (cx + abdomenW < size) grid[abdomenY + segH - 1][cx + abdomenW] = '╯';
                }

                // VARIABLE LEGS (3-4 pairs) - Using DNA legStyle
                // Use ARM_STYLES for insect leg patterns (they work well for horizontal limbs)
                const legPattern = ARM_STYLES[legStyleIdx % ARM_STYLES.length];

                for (let leg = 0; leg < legCount; leg++) {
                    const legY = thoraxY + 1 + leg;
                    if (legY >= 0 && legY < size) {
                        // Left legs using style patterns like /\/\ or -->
                        if (cx - 4 >= 0) grid[legY][cx - 4] = '╲';
                        for (let i = 0; i < legPattern.chars.length; i++) {
                            if (cx - 5 - i >= 0) {
                                grid[legY][cx - 5 - i] = legPattern.chars[i];
                            }
                        }
                        if (legPattern.tip && cx - 5 - legPattern.chars.length >= 0) {
                            grid[legY][cx - 5 - legPattern.chars.length] = legPattern.tip;
                        }

                        // Right legs (mirror)
                        if (cx + 4 < size) grid[legY][cx + 4] = '╱';
                        for (let i = 0; i < legPattern.chars.length; i++) {
                            if (cx + 5 + i < size) {
                                const char = legPattern.chars[i];
                                // Mirror slashes
                                const mirrorChar = char === '/' ? '\\' : (char === '\\' ? '/' : char);
                                grid[legY][cx + 5 + i] = mirrorChar;
                            }
                        }
                        if (legPattern.tip && cx + 5 + legPattern.chars.length < size) {
                            const mirrorTip = legPattern.tip === '⟩' ? '⟨' : (legPattern.tip === '>' ? '<' : legPattern.tip);
                            grid[legY][cx + 5 + legPattern.chars.length] = mirrorTip;
                        }
                    }
                }

                // ANTENNAE (variable length and tip) - only if hasAntennae
                if (hasAntennae) {
                    for (let ant of [-1, 1]) {
                        const antX = cx + ant;
                        for (let i = 1; i <= antennaLength; i++) {
                            const antY = baseY - i;
                            if (antY >= 0 && antX >= 0 && antX < size) {
                                if (i === antennaLength) {
                                    grid[antY][antX] = antennaTip;
                                } else {
                                    grid[antY][antX] = '│';
                                }
                            }
                        }
                    }
                }

                // MANDIBLES (4 different styles)
                const MANDIBLES = [
                    ['⊏', '⊐'],
                    ['<', '>'],
                    ['╰', '╯'],
                    ['(', ')']
                ];
                if (baseY + 2 >= 0 && baseY + 2 < size) {
                    const mand = MANDIBLES[mandibleStyle];
                    if (cx - 1 >= 0) grid[baseY + 2][cx - 1] = mand[0];
                    if (cx + 1 < size) grid[baseY + 2][cx + 1] = mand[1];
                }

                // WINGS (50% chance for adults)
                if (hasWings) {
                    for (let w = 0; w < 3; w++) {
                        const wingY = thoraxY + w + 1;
                        if (wingY >= 0 && wingY < size) {
                            if (cx - 4 >= 0) grid[wingY][cx - 4] = w === 0 ? '╱' : '/';
                            if (cx + 4 < size) grid[wingY][cx + 4] = w === 0 ? '╲' : '\\';
                        }
                    }
                }

                // STINGER (tail stinger like wasp/scorpion)
                if (hasStingers && !isChild) {
                    const stingerY = abdomenY + segH;
                    const stingerLen = 3;
                    for (let i = 0; i < stingerLen; i++) {
                        const sy = stingerY + i;
                        if (sy >= 0 && sy < size && cx >= 0 && cx < size) {
                            if (i === stingerLen - 1) {
                                grid[sy][cx] = '▼'; // Stinger tip
                            } else {
                                grid[sy][cx] = i % 2 === 0 ? '│' : '┃';
                            }
                        }
                    }
                }

            } else if (species === 'reptilian') {
                // ═══ REPTILIAN: MASSIVELY EXPANDED DNA variations ═══

                // ═══ READ ALL VARIATIONS FROM DNA ═══
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const headVariant = dna.headVariant || 0;
                const armStyleIdx = dna.armStyleIdx || 0;
                const legStyleIdx = dna.legStyleIdx || 0;
                const numArms = dna.numArms || 2;
                const numLegs = dna.numLegs || 2;
                const hasTongue = dna.hasTongue;
                const hasSpines = dna.hasSpines && !isChild;
                const hasTeeth = dna.hasTeeth || false;
                const hasClaws = dna.hasClaws || true;
                const tailStyle = dna.tailStyle;
                const bellyMarkIdx = dna.bellyMarkIdx || 0;
                const hasHorns = dna.hasHorns || (random() < 0.4); // New trait
                const hasFrill = dna.hasFrill || (random() < 0.3); // New trait
                const spineCount = dna.spineCount || Math.floor(random() * 3) + 2; // New trait
                const scaleSize = dna.scaleSize || Math.floor(random() * 3); // New trait

                const headY = isChild ? 4 : 5;
                const bodyY = isChild ? 7 : 9;
                const bodyH = isChild ? (3 + dna.bodyHeightVariant) : (4 + dna.bodyHeightVariant);

                // VARIABLE HEAD SHAPES with horns/crests
                const headChar = headVariant % 3 === 0 ? '▓' : (headVariant % 3 === 1 ? '█' : '▒');
                for (let y = 0; y < 3; y++) {
                    const w = 3 - y;
                    for (let x = -w; x <= w; x++) {
                        if (headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            grid[headY + y][cx + x] = headChar;
                        }
                    }
                }

                // HORNS/CRESTS (variable styles)
                if (hasHorns && !isChild) {
                    const hornStyles = [
                        ['▲', '▲'], // dual horns
                        ['◆'], // single crest
                        ['∧', '∧'], // small horns
                        ['♦', '♦'], // diamond crests
                    ];
                    const hornStyle = hornStyles[headVariant % hornStyles.length];
                    if (hornStyle.length === 2) {
                        // Dual horns
                        if (headY - 1 >= 0 && headY - 1 < size) {
                            if (cx - 2 >= 0) grid[headY - 1][cx - 2] = hornStyle[0];
                            if (cx + 2 < size) grid[headY - 1][cx + 2] = hornStyle[1];
                        }
                    } else {
                        // Single crest
                        if (headY - 1 >= 0 && headY - 1 < size && cx >= 0 && cx < size) {
                            grid[headY - 1][cx] = hornStyle[0];
                        }
                    }
                }

                // NECK FRILL (like dinosaur frill)
                if (hasFrill && !isChild) {
                    if (headY + 2 >= 0 && headY + 2 < size) {
                        if (cx - 3 >= 0) grid[headY + 2][cx - 3] = '◢';
                        if (cx - 2 >= 0) grid[headY + 2][cx - 2] = '▓';
                        if (cx + 2 < size) grid[headY + 2][cx + 2] = '▓';
                        if (cx + 3 < size) grid[headY + 2][cx + 3] = '◣';
                    }
                }

                // VARIABLE SLIT EYES (2-4 eyes with different styles)
                const eyeSlits = ['|', '‖', '│', '║'];
                const eyeChar = eyeSlits[eyeStyleIdx % eyeSlits.length];

                if (numEyes === 2) {
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                    }
                } else if (numEyes >= 3) {
                    // Multiple eyes
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 2 >= 0) grid[headY + 1][cx - 2] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY + 1][cx] = eyeChar;
                        if (cx + 2 < size) grid[headY + 1][cx + 2] = eyeChar;
                        if (numEyes >= 4 && cx + 1 < size) grid[headY][cx + 1] = eyeChar;
                    }
                }

                // VARIABLE MOUTH/SNOUT with teeth
                const mouthStyles = ['Y', 'V', 'W', '〈〉', '▼', '∨', 'Ψ', '◊'];
                if (hasTongue && headY + 3 >= 0 && headY + 3 < size && cx >= 0 && cx < size) {
                    const mouth = mouthStyles[mouthStyleIdx % mouthStyles.length];
                    grid[headY + 3][cx] = mouth;
                }

                // TEETH (visible on sides of mouth)
                if (hasTeeth && headY + 2 >= 0 && headY + 2 < size) {
                    const teethChars = ['V', 'v', 'λ', 'Λ'];
                    const toothChar = teethChars[mouthStyleIdx % teethChars.length];
                    if (cx - 2 >= 0) grid[headY + 2][cx - 2] = toothChar;
                    if (cx + 2 < size) grid[headY + 2][cx + 2] = toothChar;
                    // Extra teeth for bigger mouths
                    if (!isChild) {
                        if (cx - 3 >= 0) grid[headY + 2][cx - 3] = toothChar;
                        if (cx + 3 < size) grid[headY + 2][cx + 3] = toothChar;
                    }
                }

                // VARIABLE SCALED BODY with multiple patterns and sizes
                const scalePatterns = [['◇', '◆'], ['▽', '▼'], ['◊', '◈'], ['▿', '▾'], ['∇', '∆'], ['○', '●']];
                const [scale1, scale2] = scalePatterns[bodyTextureIdx % scalePatterns.length];

                // Scale size affects density
                const scaleChars = scaleSize === 0 ? ['·', '∙'] : (scaleSize === 1 ? [scale1, scale2] : ['▓', '▒']);

                for (let y = 0; y < bodyH; y++) {
                    for (let x = -3; x <= 3; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (x === -3 || x === 3) {
                                grid[bodyY + y][cx + x] = '▓'; // Body outline
                            } else if ((x + y) % 2 === 0) {
                                grid[bodyY + y][cx + x] = scaleChars[0];
                            } else {
                                grid[bodyY + y][cx + x] = scaleChars[1];
                            }
                        }
                    }
                }

                // DORSAL RIDGE/STRIPES (based on body texture)
                if (bodyTextureIdx % 3 === 0) {
                    // Add central ridge stripe
                    for (let y = 0; y < bodyH; y++) {
                        const ridgeY = bodyY + y;
                        if (ridgeY >= 0 && ridgeY < size && cx >= 0 && cx < size) {
                            grid[ridgeY][cx] = '║';
                        }
                    }
                }

                // SIDE STRIPES (tiger-like)
                if (bodyTextureIdx % 3 === 1) {
                    for (let y = 0; y < bodyH; y += 2) {
                        const stripeY = bodyY + y;
                        if (stripeY >= 0 && stripeY < size) {
                            if (cx - 2 >= 0) grid[stripeY][cx - 2] = '▓';
                            if (cx + 2 < size) grid[stripeY][cx + 2] = '▓';
                        }
                    }
                }

                // BELLY MARK
                const bellyMarks = ['◉', '●', '▣', '◆'];
                if (bellyMarkIdx < 3 && bodyH > 1) {
                    const markY = bodyY + Math.floor(bodyH / 2);
                    if (markY >= 0 && markY < size && cx >= 0 && cx < size) {
                        grid[markY][cx] = bellyMarks[bellyMarkIdx % bellyMarks.length];
                    }
                }

                // CLAWED ARMS with proper joints
                const armY = bodyY + 1;
                const armLen = isChild ? 2 : 3;
                if (armY >= 0 && armY < size) {
                    // Left arm: shoulder -> forearm -> claw
                    if (cx - 4 >= 0) grid[armY][cx - 4] = '╱';
                    for (let i = 1; i <= armLen; i++) {
                        if (cx - 4 - i >= 0) grid[armY][cx - 4 - i] = '─';
                    }
                    if (cx - 4 - armLen >= 0) grid[armY][cx - 4 - armLen] = 'ψ';

                    // Right arm
                    if (cx + 4 < size) grid[armY][cx + 4] = '╲';
                    for (let i = 1; i <= armLen; i++) {
                        if (cx + 4 + i < size) grid[armY][cx + 4 + i] = '─';
                    }
                    if (cx + 4 + armLen < size) grid[armY][cx + 4 + armLen] = 'ψ';
                }

                // LEGS with joints
                const legY = bodyY + bodyH;
                for (let leg of [-1, 1]) {
                    const legX = cx + leg * 2;
                    const legLen = isChild ? 2 : 3;
                    for (let i = 0; i < legLen; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            grid[legY + i][legX] = '│';
                        }
                    }
                    // Clawed feet
                    if (legY + legLen >= 0 && legY + legLen < size && legX >= 0 && legX < size) {
                        grid[legY + legLen][legX] = 'Ʌ';
                    }
                }

                // VARIABLE TAIL STYLES
                const tailStart = bodyY + bodyH;
                const tailLen = isChild ? 3 : 5;
                for (let i = 0; i < tailLen; i++) {
                    const ty = tailStart + i;
                    if (tailStyle === 0) {
                        // Serpentine
                        const tx = cx + (i % 3 === 0 ? -1 : (i % 3 === 1 ? 0 : 1));
                        if (ty >= 0 && ty < size && tx >= 0 && tx < size) {
                            grid[ty][tx] = i === tailLen - 1 ? '▼' : '╲';
                        }
                    } else if (tailStyle === 1) {
                        // Spiked straight
                        if (ty >= 0 && ty < size && cx >= 0 && cx < size) {
                            grid[ty][cx] = i === tailLen - 1 ? '▼' : (i % 2 === 0 ? '┃' : '│');
                        }
                    } else {
                        // Club tail
                        const tx = cx + (i > tailLen / 2 ? 1 : 0);
                        if (ty >= 0 && ty < size && tx >= 0 && tx < size) {
                            grid[ty][tx] = i === tailLen - 1 ? '█' : '│';
                        }
                    }
                }

                // VARIABLE DORSAL SPINES along back
                if (hasSpines) {
                    const spineStyles = ['▲', '▴', '△', '⋀', '◆', '♦'];
                    const spineChar = spineStyles[headVariant % spineStyles.length];

                    // Variable spine count (2-4)
                    const spacing = Math.floor(bodyH / spineCount);
                    for (let s = 0; s < spineCount; s++) {
                        const spineY = bodyY + s * spacing;
                        if (spineY >= 0 && spineY < size && cx >= 0 && cx < size) {
                            grid[spineY][cx] = spineChar;
                            // Double spines for some variants
                            if (scaleSize >= 2 && cx - 1 >= 0 && cx + 1 < size) {
                                grid[spineY][cx - 1] = spineChar;
                                grid[spineY][cx + 1] = spineChar;
                            }
                        }
                    }
                }

            } else if (species === 'mammalian') {
                // ═══ MAMMALIAN: MASSIVELY EXPANDED DNA variations ═══

                // ═══ READ ALL VARIATIONS FROM DNA ═══
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const noseStyleIdx = dna.noseStyleIdx || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const headVariant = dna.headVariant || 0;
                const earStyle = dna.earStyle;
                const hasTail = dna.hasTail;
                const hasWhiskers = dna.hasWhiskers;
                const bellyMarkIdx = dna.bellyMarkIdx || 0;

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 8 : 10;
                const bodyH = isChild ? 3 : 4;

                // ROUND HEAD with fur texture
                for (let y = -2; y <= 2; y++) {
                    for (let x = -2; x <= 2; x++) {
                        const dist = Math.sqrt(x*x + y*y);
                        if (dist <= 2 && headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            if (dist > 1.5) {
                                grid[headY + y][cx + x] = '░'; // Fur outline
                            } else {
                                grid[headY + y][cx + x] = ' ';
                            }
                        }
                    }
                }

                // VARIABLE EYES (2-4 eyes with different styles)
                const eyeStyles = ['●', '◉', '○', '◎', '⊙', '◕'];
                const eyeChar = eyeStyles[eyeStyleIdx % eyeStyles.length];

                if (numEyes === 2) {
                    if (headY >= 0 && headY < size) {
                        if (cx - 1 >= 0) grid[headY][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY][cx + 1] = eyeChar;
                    }
                } else if (numEyes >= 3) {
                    if (headY >= 0 && headY < size) {
                        if (cx - 2 >= 0) grid[headY][cx - 2] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY][cx] = eyeChar;
                        if (cx + 2 < size) grid[headY][cx + 2] = eyeChar;
                        if (numEyes >= 4 && cx + 1 < size) grid[headY - 1][cx + 1] = eyeChar;
                    }
                }

                // VARIABLE NOSE
                const noseStyles = ['▼', '●', '○', '◉', '▽', '◆'];
                const noseChar = noseStyles[noseStyleIdx % noseStyles.length];
                if (headY + 1 >= 0 && headY + 1 < size && cx >= 0 && cx < size) {
                    grid[headY + 1][cx] = noseChar;
                }

                // VARIABLE MOUTH
                const mouthStyles = ['w', '∪', 'U', 'v', '⌣', '⌢'];
                const mouthChar = mouthStyles[mouthStyleIdx % mouthStyles.length];
                if (headY + 2 >= 0 && headY + 2 < size && cx >= 0 && cx < size) {
                    grid[headY + 2][cx] = mouthChar;
                }

                // WHISKERS (detailed variable styles)
                if (hasWhiskers) {
                    const whiskerStyles = [
                        ['─', '─', '─'], // straight
                        ['╱', '─', '╲'], // angled
                        ['~', '~', '~'], // wavy
                        ['═', '═', '═'], // thick
                        ['╌', '╌', '╌'], // dotted
                    ];
                    const whiskerStyle = whiskerStyles[mouthStyleIdx % whiskerStyles.length];

                    // Upper whiskers
                    if (headY >= 0 && headY < size) {
                        if (cx - 3 >= 0) grid[headY][cx - 3] = whiskerStyle[0];
                        if (cx - 4 >= 0) grid[headY][cx - 4] = whiskerStyle[1];
                        if (cx + 3 < size) grid[headY][cx + 3] = whiskerStyle[0];
                        if (cx + 4 < size) grid[headY][cx + 4] = whiskerStyle[1];
                    }

                    // Middle whiskers
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 3 >= 0) grid[headY + 1][cx - 3] = whiskerStyle[2];
                        if (cx + 3 < size) grid[headY + 1][cx + 3] = whiskerStyle[2];
                    }

                    // Lower whiskers (if not child)
                    if (!isChild && headY + 2 >= 0 && headY + 2 < size) {
                        if (cx - 3 >= 0) grid[headY + 2][cx - 3] = whiskerStyle[0];
                        if (cx + 3 < size) grid[headY + 2][cx + 3] = whiskerStyle[0];
                    }
                }

                // VARIABLE EARS
                if (headY - 2 >= 0) {
                    if (earStyle === 0) {
                        // Pointy
                        if (cx - 2 >= 0) grid[headY - 2][cx - 2] = '▲';
                        if (cx + 2 < size) grid[headY - 2][cx + 2] = '▲';
                    } else if (earStyle === 1) {
                        // Round
                        if (cx - 2 >= 0) grid[headY - 2][cx - 2] = '◯';
                        if (cx + 2 < size) grid[headY - 2][cx + 2] = '◯';
                    } else {
                        // Floppy (down)
                        if (headY >= 0) {
                            if (cx - 3 >= 0) grid[headY][cx - 3] = '╲';
                            if (cx + 3 < size) grid[headY][cx + 3] = '╱';
                        }
                    }
                }

                // FURRY BODY with detailed patterns
                // Fur texture patterns
                const furPatterns = [
                    ['░', '▒', '▓'], // gradient
                    ['∴', '∵', '∷'], // dots
                    ['≈', '~', '∼'], // waves
                    ['▪', '▫', '·'], // spots
                    ['║', '│', '┃'], // stripes vertical
                    ['═', '─', '━'], // stripes horizontal
                ];
                const furPattern = furPatterns[bodyTextureIdx % furPatterns.length];

                // Body outline and fill
                for (let y = 0; y < bodyH; y++) {
                    for (let x = -3; x <= 3; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (x === -3 || x === 3) {
                                grid[bodyY + y][cx + x] = '░'; // Fur outline
                            } else if (Math.abs(x) === 2) {
                                // Inner fur layer
                                grid[bodyY + y][cx + x] = furPattern[0];
                            } else if (Math.abs(x) === 1) {
                                // Middle layer
                                grid[bodyY + y][cx + x] = furPattern[1];
                            } else {
                                // Center/belly
                                grid[bodyY + y][cx + x] = furPattern[2];
                            }
                        }
                    }
                }

                // BELLY MARK (detailed)
                const bellyMarks = [
                    ['◉', '●'], // spots
                    ['▣', '▢'], // squares
                    ['◆', '◇'], // diamonds
                    ['○', '◎'], // circles
                    ['≡', '='], // stripes
                    ['∴', '∵'], // dots pattern
                ];
                if (bellyMarkIdx < bellyMarks.length) {
                    const [mark1, mark2] = bellyMarks[bellyMarkIdx];
                    const markY = bodyY + Math.floor(bodyH / 2);
                    if (markY >= 0 && markY < size) {
                        if (cx >= 0 && cx < size) grid[markY][cx] = mark1;
                        if (markY + 1 < size && cx >= 0 && cx < size) grid[markY + 1][cx] = mark2;
                    }
                }

                // CHEST TUFT (variable)
                if (headVariant % 3 === 0 && bodyY >= 0 && bodyY < size) {
                    if (cx >= 0 && cx < size) grid[bodyY][cx] = '∇';
                }

                // SPOTS/STRIPES on back (based on bodyTextureIdx)
                if (bodyTextureIdx % 4 < 2) {
                    // Add spots
                    for (let i = 0; i < 3; i++) {
                        const spotY = bodyY + Math.floor((i + 0.5) * bodyH / 3);
                        const spotX = cx + (i % 2 === 0 ? -2 : 2);
                        if (spotY >= 0 && spotY < size && spotX >= 0 && spotX < size) {
                            grid[spotY][spotX] = '●';
                        }
                    }
                } else if (bodyTextureIdx % 4 >= 2) {
                    // Add stripes
                    for (let y = 0; y < bodyH; y += 2) {
                        const stripeY = bodyY + y;
                        if (stripeY >= 0 && stripeY < size) {
                            if (cx - 2 >= 0) grid[stripeY][cx - 2] = '║';
                            if (cx + 2 < size) grid[stripeY][cx + 2] = '║';
                        }
                    }
                }

                // FACE MARKINGS (like raccoon mask or forehead mark)
                if (headVariant % 2 === 0) {
                    // Eye mask
                    if (headY >= 0 && headY < size) {
                        if (cx - 2 >= 0) grid[headY][cx - 2] = '▓';
                        if (cx + 2 < size) grid[headY][cx + 2] = '▓';
                    }
                } else {
                    // Forehead mark
                    if (headY - 1 >= 0 && headY - 1 < size && cx >= 0 && cx < size) {
                        grid[headY - 1][cx] = '◆';
                    }
                }

                // CHEEK TUFTS (fluff on sides of face)
                if (noseStyleIdx % 3 === 0 && headY + 1 >= 0 && headY + 1 < size) {
                    if (cx - 2 >= 0) grid[headY + 1][cx - 2] = '≈';
                    if (cx + 2 < size) grid[headY + 1][cx + 2] = '≈';
                }

                // ARMS with detailed paws
                const armY = bodyY + 1;
                const armLen = isChild ? 2 : 3;
                const armStyleIdx = dna.armStyleIdx || 0;
                const pawStyles = ['⊂', '◐', '⊃', '◑', '⊐', '⊏'];

                if (armY >= 0 && armY < size) {
                    // Furry arms
                    for (let i = 1; i <= armLen; i++) {
                        const armChar = i % 2 === 0 ? '─' : '═';
                        if (cx - 3 - i >= 0) grid[armY][cx - 3 - i] = armChar;
                        if (cx + 3 + i < size) grid[armY][cx + 3 + i] = armChar;
                    }
                    // Detailed paws with paw pads
                    const leftPaw = pawStyles[armStyleIdx % pawStyles.length];
                    const rightPaw = pawStyles[(armStyleIdx + 1) % pawStyles.length];
                    if (cx - 3 - armLen >= 0) grid[armY][cx - 3 - armLen] = leftPaw;
                    if (cx + 3 + armLen < size) grid[armY][cx + 3 + armLen] = rightPaw;

                    // Claws (if DNA has them)
                    if (dna.hasClaws && !isChild) {
                        if (cx - 3 - armLen - 1 >= 0 && armY >= 0 && armY < size) {
                            grid[armY][cx - 3 - armLen - 1] = '≺';
                        }
                        if (cx + 3 + armLen + 1 < size && armY >= 0 && armY < size) {
                            grid[armY][cx + 3 + armLen + 1] = '≻';
                        }
                    }
                }

                // LEGS with detailed paws
                const legY = bodyY + bodyH;
                const footStyles = ['⊥', '⊤', '▼', '▽', '╧', '╨'];

                for (let leg of [-1, 1]) {
                    const legX = cx + leg * 2;
                    const legLen = isChild ? 2 : 3;
                    const legStyleIdx = dna.legStyleIdx || 0;

                    // Furry legs
                    for (let i = 0; i < legLen; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            const legChar = i % 2 === 0 ? '│' : '║';
                            grid[legY + i][legX] = legChar;
                        }
                    }

                    // Detailed paw pads
                    const footChar = footStyles[legStyleIdx % footStyles.length];
                    if (legY + legLen >= 0 && legY + legLen < size && legX >= 0 && legX < size) {
                        grid[legY + legLen][legX] = footChar;
                    }

                    // Toe beans (paw pad details)
                    if (!isChild && legY + legLen + 1 >= 0 && legY + legLen + 1 < size) {
                        if (legX - 1 >= 0) grid[legY + legLen + 1][legX - 1] = '·';
                        if (legX + 1 < size) grid[legY + legLen + 1][legX + 1] = '·';
                    }
                }

                // TAIL (variable)
                if (hasTail) {
                    const tailStart = bodyY + bodyH;
                    const tailLen = isChild ? 3 : 4;
                    const tailStyle = Math.floor(random() * 2); // 0=curved, 1=straight
                    for (let i = 0; i < tailLen; i++) {
                        const ty = tailStart + i;
                        let tx;
                        if (tailStyle === 0) {
                            tx = cx + (i % 2 === 0 ? 1 : 2); // Curved
                        } else {
                            tx = cx + 2; // Straight up
                        }
                        if (ty >= 0 && ty < size && tx >= 0 && tx < size) {
                            grid[ty][tx] = i === tailLen - 1 ? '◯' : (tailStyle === 0 ? '╲' : '│');
                        }
                    }
                }

            } else if (species === 'viral') {
                // ═══ VIRAL: Blob creature with MAXIMUM DETAIL & VARIETY ═══

                // ═══ READ ALL VARIATIONS FROM DNA (NOT random during render!) ═══
                const numEyes = dna.numEyes;
                const eyeStyle = EYE_STYLES[dna.eyeStyleIdx];
                const hasPupils = dna.hasPupils;
                const pupilStyle = PUPIL_STYLES[dna.pupilStyleIdx];
                const hasEyebrows = dna.hasEyebrows;
                const eyebrowStyle = EYEBROW_STYLES[dna.eyebrowStyleIdx];

                const mouthStyle = MOUTH_STYLES[dna.mouthStyleIdx];
                const hasTeeth = dna.hasTeeth;
                const teethStyle = TEETH_STYLES[dna.teethStyleIdx];
                const hasNose = dna.hasNose;
                const noseStyle = NOSE_STYLES[dna.noseStyleIdx];

                const headVariant = dna.headVariant;
                const armStyleIdx = dna.armStyleIdx;
                const armStyle = ARM_STYLES[armStyleIdx];
                const numArms = dna.numArms;
                const hasClaws = dna.hasClaws;

                const legStyleIdx = dna.legStyleIdx;
                const legStyle = LEG_STYLES[legStyleIdx];
                const numLegs = dna.numLegs;
                const hasToes = dna.hasToes;

                const bodyTexture = BODY_TEXTURES[dna.bodyTextureIdx];
                const hasSpots = dna.hasSpots;
                const faceMark = FACE_MARKS[dna.faceMarkIdx];
                const bellyMark = BELLY_MARKS[dna.bellyMarkIdx];
                const hasScars = dna.hasScars;
                const scarMark = SCAR_MARKS[dna.scarMarkIdx];

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 8 : 10;
                const bodyH = isChild ? 3 : 4;

                // VARIABLE HEAD SHAPE (based on headVariant)
                let headW, headH;
                if (headVariant === 0) {
                    // Wide blob
                    headW = isChild ? 3 : 4;
                    headH = 3;
                } else if (headVariant === 1) {
                    // Tall blob
                    headW = isChild ? 2 : 3;
                    headH = 4;
                } else {
                    // Round blob
                    headW = isChild ? 2 : 3;
                    headH = 4;
                }

                // Draw head outline
                for (let y = 0; y < headH; y++) {
                    for (let x = -headW; x <= headW; x++) {
                        if (headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            if (y === 0) {
                                if (x === 0 || x === -headW) grid[headY + y][cx + x] = '╭';
                                else if (x === headW) grid[headY + y][cx + x] = '╮';
                                else grid[headY + y][cx + x] = '─';
                            } else if (y === headH - 1) {
                                if (x === 0 || x === -headW) grid[headY + y][cx + x] = '╰';
                                else if (x === headW) grid[headY + y][cx + x] = '╯';
                                else grid[headY + y][cx + x] = '─';
                            } else if (Math.abs(x) === headW) {
                                grid[headY + y][cx + x] = '│';
                            }
                        }
                    }
                }

                // EYEBROWS (40% chance, above eyes)
                if (hasEyebrows && headY - 1 >= 0) {
                    if (numEyes === 2) {
                        if (cx - 2 >= 0) grid[headY - 1][cx - 2] = eyebrowStyle;
                        if (cx + 2 < size) grid[headY - 1][cx + 2] = eyebrowStyle;
                    }
                }

                // EYES with PUPILS (from library, 2-5 eyes)
                const eyeY = headY + Math.floor(headH * 0.3);
                const eyePositions = [];
                if (eyeY >= 0 && eyeY < size) {
                    if (numEyes === 2) {
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    } else if (numEyes === 3) {
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx < size) { grid[eyeY][cx] = eyeStyle; eyePositions.push(cx); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    } else if (numEyes === 4) {
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx - 1 >= 0) { grid[eyeY][cx - 1] = eyeStyle; eyePositions.push(cx - 1); }
                        if (cx + 1 < size) { grid[eyeY][cx + 1] = eyeStyle; eyePositions.push(cx + 1); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    } else {
                        // 5 eyes
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx - 1 >= 0) { grid[eyeY][cx - 1] = eyeStyle; eyePositions.push(cx - 1); }
                        if (cx < size) { grid[eyeY][cx] = eyeStyle; eyePositions.push(cx); }
                        if (cx + 1 < size) { grid[eyeY][cx + 1] = eyeStyle; eyePositions.push(cx + 1); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    }

                    // PUPILS inside eyes (70% chance)
                    if (hasPupils && ['◉', '◎', '○', '◯', '⊙', '◐', '◑'].includes(eyeStyle)) {
                        for (let eyeX of eyePositions) {
                            if (eyeX >= 0 && eyeX < size) {
                                grid[eyeY][eyeX] = pupilStyle;
                            }
                        }
                    }
                }

                // NOSE/NOSTRILS (30% chance, between eyes and mouth)
                if (hasNose) {
                    const noseY = eyeY + 1;
                    if (noseY >= 0 && noseY < size && cx >= 0 && cx < size) {
                        grid[noseY][cx] = noseStyle;
                    }
                }

                // MOUTH with TEETH (from library)
                const mouthY = headY + Math.floor(headH * 0.6);
                if (mouthY >= 0 && mouthY < size && cx >= 0 && cx < size) {
                    if (mouthStyle === '╰╯' && cx + 1 < size) {
                        grid[mouthY][cx] = '╰';
                        grid[mouthY][cx + 1] = '╯';
                    } else {
                        grid[mouthY][cx] = mouthStyle;
                    }

                    // TEETH showing (50% chance)
                    if (hasTeeth && mouthY + 1 >= 0 && mouthY + 1 < size) {
                        if (teethStyle.length > 2) {
                            // Multi-char teeth like 'vv' or 'VV'
                            const startX = cx - 1;
                            for (let i = 0; i < teethStyle.length && startX + i < size; i++) {
                                if (startX + i >= 0) grid[mouthY + 1][startX + i] = teethStyle[i];
                            }
                        } else {
                            if (cx >= 0 && cx < size) grid[mouthY + 1][cx] = teethStyle;
                        }
                    }
                }

                // FACIAL MARKINGS/SPOTS (60% chance)
                if (hasSpots && headH > 2) {
                    const markY = headY + 2;
                    if (markY >= 0 && markY < size) {
                        // Cheek marks
                        if (cx - headW + 1 >= 0 && grid[markY][cx - headW + 1] === ' ') {
                            grid[markY][cx - headW + 1] = faceMark;
                        }
                        if (cx + headW - 1 < size && grid[markY][cx + headW - 1] === ' ') {
                            grid[markY][cx + headW - 1] = faceMark;
                        }
                    }
                }

                // SCARS (20% chance - battle-worn look)
                if (hasScars) {
                    const scarY = headY + 1;
                    if (scarY >= 0 && scarY < size && cx + 1 < size) {
                        grid[scarY][cx + 1] = scarMark;
                    }
                }

                // VARIABLE BODY SHAPE with BELLY PATTERN
                const bodyW = headVariant === 0 ? 3 : 2;
                for (let y = 0; y < bodyH; y++) {
                    for (let x = -bodyW; x <= bodyW; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (y === 0 && Math.abs(x) <= bodyW - 1) {
                                grid[bodyY + y][cx + x] = '─';
                            } else if (y === bodyH - 1 && Math.abs(x) <= bodyW - 1) {
                                grid[bodyY + y][cx + x] = '─';
                            } else if (Math.abs(x) === bodyW) {
                                grid[bodyY + y][cx + x] = '│';
                            }
                            // BELLY MARKING (center of body)
                            else if (x === 0 && y === Math.floor(bodyH / 2)) {
                                grid[bodyY + y][cx + x] = bellyMark;
                            }
                        }
                    }
                }

                // TENTACLE ARMS with CLAWS (using ARM_STYLES library - like /\/\ or --> or ~~~)
                for (let arm = 0; arm < numArms; arm++) {
                    const ay = bodyY + arm;
                    if (ay >= 0 && ay < size) {
                        // Left arms
                        for (let i = 0; i < armStyle.chars.length; i++) {
                            if (cx - bodyW - 1 - i >= 0) {
                                grid[ay][cx - bodyW - 1 - i] = armStyle.chars[i];
                            }
                        }
                        // Tip or Claw at end
                        const leftTipX = cx - bodyW - 1 - armStyle.chars.length;
                        if (leftTipX >= 0) {
                            if (hasClaws) {
                                grid[ay][leftTipX] = armStyle.claw;
                            } else if (armStyle.tip) {
                                grid[ay][leftTipX] = armStyle.tip;
                            }
                        }

                        // Right arms (mirror)
                        for (let i = 0; i < armStyle.chars.length; i++) {
                            if (cx + bodyW + 1 + i < size) {
                                const char = armStyle.chars[i];
                                const mirrorChar = char === '/' ? '\\' : (char === '\\' ? '/' : char);
                                grid[ay][cx + bodyW + 1 + i] = mirrorChar;
                            }
                        }
                        // Tip or Claw at end
                        const rightTipX = cx + bodyW + 1 + armStyle.chars.length;
                        if (rightTipX < size) {
                            if (hasClaws) {
                                grid[ay][rightTipX] = armStyle.claw;
                            } else if (armStyle.tip) {
                                const mirrorTip = armStyle.tip === '⟩' ? '⟨' : (armStyle.tip === '>' ? '<' : armStyle.tip);
                                grid[ay][rightTipX] = mirrorTip;
                            }
                        }
                    }
                }

                // LEGS with TOES (using LEG_STYLES library - like /\ or ││ or ╱╲)
                const legY = bodyY + bodyH;
                const legPositions = numLegs === 2 ? [-2, 2] : (numLegs === 3 ? [-2, 0, 2] : [-3, -1, 1, 3]);

                for (let legPos of legPositions) {
                    const legX = cx + legPos;
                    // Leg segments
                    for (let i = 0; i < legStyle.chars.length; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            grid[legY + i][legX] = legStyle.chars[i];
                        }
                    }
                    // Foot
                    const footY = legY + legStyle.chars.length;
                    if (footY >= 0 && footY < size && legX >= 0 && legX < size) {
                        grid[footY][legX] = legStyle.foot;
                    }
                    // Toes (50% chance)
                    if (hasToes && footY + 1 >= 0 && footY + 1 < size && legX >= 0 && legX < size) {
                        grid[footY + 1][legX] = legStyle.toe;
                    }
                }

            } else if (species === 'skeletal') {
                // ═══ SKELETAL: DNA-based variations - MASSIVELY EXPANDED ═══

                // ═══ READ ALL VARIATIONS FROM DNA (NOT random during render!) ═══
                const jawStyle = dna.jawStyle || 0;
                const ribCount = dna.ribCount || 3;
                const ribStyle = dna.ribStyle || 0;
                const spineStyle = dna.spineStyle || 0;
                const skullShape = dna.skullShape || 0;
                const eyeSocketStyle = dna.eyeSocketStyle || 0;
                const nasalStyle = dna.nasalStyle || 0;
                const armBoneStyle = dna.armBoneStyle || 0;
                const legBoneStyle = dna.legBoneStyle || 0;
                const jointStyle = dna.jointStyle || 0;
                const fingerStyle = dna.fingerStyle || 0;
                const footStyle = dna.footStyle || 0;
                const hasCracks = dna.hasCracks || false;
                const hasSpinalCord = dna.hasSpinalCord || false;
                const hasExtraRibs = dna.hasExtraRibs || false;
                const hasHorns = dna.hasHorns || false;
                const hasTeeth = dna.hasTeeth || false;
                const teethStyle = dna.teethStyle || 0;
                const boneThickness = dna.boneThickness || 1;
                const hasTail = dna.hasTail !== false; // Default true
                const tailBoneCount = dna.tailBoneCount || 4;

                const skullY = isChild ? 5 : 6;
                const spineY = isChild ? 8 : 10;
                const spineH = isChild ? (4 + dna.spineHeightVariant) : (5 + dna.spineHeightVariant);

                // VARIABLE SKULL SHAPE
                if (skullShape === 0) {
                    // Round skull
                    for (let y = -2; y <= 1; y++) {
                        for (let x = -2; x <= 2; x++) {
                            if (skullY + y >= 0 && skullY + y < size && cx + x >= 0 && cx + x < size) {
                                if (y === -2 || y === 1 || x === -2 || x === 2) {
                                    grid[skullY + y][cx + x] = '▓';
                                }
                            }
                        }
                    }
                } else if (skullShape === 1) {
                    // Angular skull
                    for (let y = -2; y <= 1; y++) {
                        for (let x = -2; x <= 2; x++) {
                            if (skullY + y >= 0 && skullY + y < size && cx + x >= 0 && cx + x < size) {
                                if (y === -2 || y === 1 || x === -2 || x === 2) {
                                    grid[skullY + y][cx + x] = '▪';
                                }
                            }
                        }
                    }
                } else {
                    // Elongated skull
                    for (let y = -2; y <= 2; y++) {
                        for (let x = -2; x <= 2; x++) {
                            if (skullY + y >= 0 && skullY + y < size && cx + x >= 0 && cx + x < size) {
                                if (y === -2 || y === 2 || x === -2 || x === 2) {
                                    grid[skullY + y][cx + x] = '▓';
                                }
                            }
                        }
                    }
                }

                // VARIABLE EYE SOCKETS with multiple styles
                const eyeSocketChars = ['◯', '◉', '●', '○'];
                const eyeSocketChar = eyeSocketChars[eyeSocketStyle] || '◯';
                if (skullY >= 0 && skullY < size) {
                    if (cx - 1 >= 0) grid[skullY][cx - 1] = eyeSocketChar;
                    if (cx + 1 < size) grid[skullY][cx + 1] = eyeSocketChar;
                }

                // VARIABLE NASAL CAVITY
                if (skullY + 1 >= 0 && skullY + 1 < size && cx >= 0 && cx < size) {
                    if (nasalStyle === 0) {
                        grid[skullY + 1][cx] = '▽';
                    } else if (nasalStyle === 1) {
                        grid[skullY + 1][cx] = '○';
                    } else {
                        // Double nasal holes
                        if (cx - 1 >= 0) grid[skullY + 1][cx - 1] = '·';
                        if (cx + 1 < size) grid[skullY + 1][cx + 1] = '·';
                    }
                }

                // VARIABLE JAW with 3 styles
                for (let x = -2; x <= 2; x++) {
                    if (skullY + 2 >= 0 && skullY + 2 < size && cx + x >= 0 && cx + x < size) {
                        if (jawStyle === 0) {
                            // Normal jaw
                            grid[skullY + 2][cx + x] = x % 2 === 0 ? '▓' : '▔';
                        } else if (jawStyle === 1) {
                            // Fanged jaw
                            grid[skullY + 2][cx + x] = x % 2 === 0 ? '▓' : 'V';
                        } else {
                            // Gapped/broken jaw
                            grid[skullY + 2][cx + x] = Math.abs(x) === 2 ? '▓' : (x === 0 ? ' ' : '▔');
                        }
                    }
                }

                // VARIABLE SPINE with 3 styles
                const jointChars = ['◉', '○', '■'];
                const jointChar = jointChars[jointStyle] || '◉';

                for (let v = 0; v < spineH; v++) {
                    const vY = spineY + v;
                    if (vY >= 0 && vY < size && cx >= 0 && cx < size) {
                        if (spineStyle === 0) {
                            // Vertebrae style
                            grid[vY][cx] = v % 2 === 0 ? jointChar : '│';
                        } else if (spineStyle === 1) {
                            // Solid spine
                            grid[vY][cx] = '│';
                        } else {
                            // Segmented spine
                            grid[vY][cx] = v % 2 === 0 ? '━' : '│';
                        }

                        // Optional spinal cord
                        if (hasSpinalCord && v % 2 === 1 && cx - 1 >= 0 && cx + 1 < size) {
                            if (grid[vY][cx - 1] === ' ') grid[vY][cx - 1] = '·';
                            if (grid[vY][cx + 1] === ' ') grid[vY][cx + 1] = '·';
                        }
                    }
                }

                // VARIABLE RIBCAGE with 3 styles (2-4 ribs)
                for (let rib = 0; rib < ribCount; rib++) {
                    const ribY = spineY + rib;
                    if (ribY >= 0 && ribY < size) {
                        if (ribStyle === 0) {
                            // Curved ribs
                            if (cx - 1 >= 0) grid[ribY][cx - 1] = '(';
                            if (cx - 2 >= 0) grid[ribY][cx - 2] = '─';
                            if (cx + 1 < size) grid[ribY][cx + 1] = ')';
                            if (cx + 2 < size) grid[ribY][cx + 2] = '─';
                        } else if (ribStyle === 1) {
                            // Straight ribs
                            if (cx - 1 >= 0) grid[ribY][cx - 1] = '─';
                            if (cx - 2 >= 0) grid[ribY][cx - 2] = '─';
                            if (cx + 1 < size) grid[ribY][cx + 1] = '─';
                            if (cx + 2 < size) grid[ribY][cx + 2] = '─';
                        } else {
                            // Broken ribs
                            if (cx - 1 >= 0 && rib % 2 === 0) grid[ribY][cx - 1] = '(';
                            if (cx - 2 >= 0 && rib % 2 === 0) grid[ribY][cx - 2] = '╌';
                            if (cx + 1 < size && rib % 2 === 1) grid[ribY][cx + 1] = ')';
                            if (cx + 2 < size && rib % 2 === 1) grid[ribY][cx + 2] = '╌';
                        }
                    }
                }

                // Add bone cracks randomly if hasCracks
                if (hasCracks) {
                    for (let i = 0; i < 3; i++) {
                        const crackY = skullY + Math.floor(random() * 4);
                        const crackX = cx + Math.floor(random() * 3) - 1;
                        if (crackY >= 0 && crackY < size && crackX >= 0 && crackX < size) {
                            if (grid[crackY][crackX] === '▓' || grid[crackY][crackX] === '▪') {
                                grid[crackY][crackX] = '░';
                            }
                        }
                    }
                }

                // VARIABLE ARM BONES with joints
                const armY = spineY + 1;
                const armLen = isChild ? 2 : 3;
                const armBoneChars = [['─', jointChar], ['═', jointChar], ['╌', jointChar]];
                const [armChar, armJoint] = armBoneChars[armBoneStyle] || armBoneChars[0];

                if (armY >= 0 && armY < size) {
                    for (let i = 1; i <= armLen; i++) {
                        if (cx - 3 - i >= 0) {
                            grid[armY][cx - 3 - i] = i === Math.floor(armLen/2) ? armJoint : armChar;
                        }
                        if (cx + 3 + i < size) {
                            grid[armY][cx + 3 + i] = i === Math.floor(armLen/2) ? armJoint : armChar;
                        }
                    }
                    // VARIABLE FINGER bones
                    const fingerChars = ['╦', '┬', 'Ψ', '⊤'];
                    const fingerChar = fingerChars[fingerStyle] || '╦';
                    if (cx - 3 - armLen - 1 >= 0) grid[armY][cx - 3 - armLen - 1] = fingerChar;
                    if (cx + 3 + armLen + 1 < size) grid[armY][cx + 3 + armLen + 1] = fingerChar;
                }

                // VARIABLE LEG BONES
                const legY = spineY + spineH;
                const legBoneChars = [['│', jointChar], ['║', jointChar], ['┆', jointChar]];
                const [legChar, legJoint] = legBoneChars[legBoneStyle] || legBoneChars[0];

                for (let leg of [-1, 1]) {
                    const legX = cx + leg * 2;
                    const legLen = isChild ? 2 : 3;
                    for (let i = 0; i < legLen; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            grid[legY + i][legX] = i === Math.floor(legLen/2) ? legJoint : legChar;
                        }
                    }
                    // VARIABLE FOOT bones
                    const footChars = ['⊥', '┴', '┻'];
                    const footChar = footChars[footStyle] || '⊥';
                    if (legY + legLen >= 0 && legY + legLen < size && legX >= 0 && legX < size) {
                        grid[legY + legLen][legX] = footChar;
                    }
                }

            } else if (species === 'alien') {
                // ═══ ALIEN: MASSIVELY EXPANDED DNA variations ═══

                // ═══ READ ALL VARIATIONS FROM DNA ═══
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const headVariant = dna.alienHeadVariant;
                const hasAntennae = dna.hasAntennae;
                const numTentacles = dna.numTentacles;
                const bellyMarkIdx = dna.bellyMarkIdx || 0;

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 10 : 12;
                const bodyH = isChild ? 2 : 3;

                // VARIABLE HEAD SIZE
                const headH = headVariant === 0 ? (isChild ? 5 : 6) : (isChild ? 4 : 5);
                const headW = headVariant === 0 ? (isChild ? 4 : 5) : (isChild ? 3 : 4);

                // Top of head (rounded dome)
                if (headY >= 0 && headY < size) {
                    if (cx - headW >= 0) grid[headY][cx - headW] = '╭';
                    for (let x = cx - headW + 1; x < cx + headW; x++) {
                        if (x >= 0 && x < size) grid[headY][x] = '─';
                    }
                    if (cx + headW < size) grid[headY][cx + headW] = '╮';
                }

                // Upper head sides (bulging)
                for (let y = headY + 1; y < headY + Math.floor(headH * 0.6); y++) {
                    if (y >= 0 && y < size) {
                        if (cx - headW >= 0) grid[y][cx - headW] = '(';
                        if (cx + headW < size) grid[y][cx + headW] = ')';
                    }
                }

                // Lower head sides (narrowing)
                for (let y = headY + Math.floor(headH * 0.6); y < headY + headH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - 2 >= 0) grid[y][cx - 2] = '│';
                        if (cx + 2 < size) grid[y][cx + 2] = '│';
                    }
                }

                // Bottom of head (chin)
                if (headY + headH - 1 >= 0 && headY + headH - 1 < size) {
                    if (cx - 2 >= 0) grid[headY + headH - 1][cx - 2] = '╰';
                    for (let x = cx - 1; x <= cx + 1; x++) {
                        if (x >= 0 && x < size) grid[headY + headH - 1][x] = '─';
                    }
                    if (cx + 2 < size) grid[headY + headH - 1][cx + 2] = '╯';
                }

                // VARIABLE ALIEN EYES (2-5 eyes with different styles)
                const alienEyeStyles = ['◉', '⊙', '◎', '●', '○', '◯', '⊚', '◕', '◔'];
                const eyeChar = alienEyeStyles[eyeStyleIdx % alienEyeStyles.length];
                const eyeY = headY + Math.floor(headH * 0.4);

                if (numEyes === 2) {
                    if (eyeY >= 0 && eyeY < size) {
                        if (cx - 2 >= 0) grid[eyeY][cx - 2] = eyeChar;
                        if (cx + 2 < size) grid[eyeY][cx + 2] = eyeChar;
                    }
                } else if (numEyes === 3) {
                    if (eyeY >= 0 && eyeY < size) {
                        if (cx - 2 >= 0) grid[eyeY][cx - 2] = eyeChar;
                        if (cx >= 0 && cx < size) grid[eyeY - 1][cx] = eyeChar;
                        if (cx + 2 < size) grid[eyeY][cx + 2] = eyeChar;
                    }
                } else if (numEyes >= 4) {
                    // Multiple eyes scattered
                    if (eyeY >= 0 && eyeY < size) {
                        if (cx - 3 >= 0) grid[eyeY][cx - 3] = eyeChar;
                        if (cx - 1 >= 0) grid[eyeY][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[eyeY][cx + 1] = eyeChar;
                        if (cx + 3 < size) grid[eyeY][cx + 3] = eyeChar;
                        if (numEyes >= 5 && cx >= 0 && cx < size) grid[eyeY - 1][cx] = eyeChar;
                    }
                }

                // VARIABLE MOUTH
                const alienMouthStyles = ['~', '≈', '∼', '▂', '▁', '═', 'w', '∪'];
                const mouthChar = alienMouthStyles[mouthStyleIdx % alienMouthStyles.length];
                if (eyeY + 2 >= 0 && eyeY + 2 < size && cx >= 0 && cx < size) {
                    grid[eyeY + 2][cx] = mouthChar;
                }

                // ANTENNAE (variable)
                if (hasAntennae && !isChild) {
                    const antennaTip = dna.antennaTip || '○';
                    for (let ant of [-1, 1]) {
                        const antX = cx + ant * 2;
                        if (headY - 1 >= 0 && antX >= 0 && antX < size) {
                            grid[headY - 1][antX] = '│';
                        }
                        if (headY - 2 >= 0 && antX >= 0 && antX < size) {
                            grid[headY - 2][antX] = antennaTip;
                        }
                    }
                }

                // SMALL BODY (neck/torso)
                for (let y = 0; y < bodyH; y++) {
                    if (bodyY + y >= 0 && bodyY + y < size) {
                        if (y === 0 || y === bodyH - 1) {
                            // Top and bottom edges
                            for (let x = -1; x <= 1; x++) {
                                if (cx + x >= 0 && cx + x < size) {
                                    grid[bodyY + y][cx + x] = '─';
                                }
                            }
                        } else {
                            // Sides
                            if (cx - 1 >= 0) grid[bodyY + y][cx - 1] = '│';
                            if (cx + 1 < size) grid[bodyY + y][cx + 1] = '│';
                        }
                    }
                }

                // TENTACLE ARMS (2 wavy arms)
                const armY = bodyY + 1;
                if (armY >= 0 && armY < size) {
                    // Left arm
                    for (let i = 1; i <= 3; i++) {
                        if (cx - 2 - i >= 0) {
                            grid[armY][cx - 2 - i] = i === 3 ? '≈' : '~';
                        }
                    }
                    // Right arm
                    for (let i = 1; i <= 3; i++) {
                        if (cx + 2 + i < size) {
                            grid[armY][cx + 2 + i] = i === 3 ? '≈' : '~';
                        }
                    }
                }

                // VARIABLE TENTACLE LEGS (3-4 tentacles)
                const legY = bodyY + bodyH;
                const legPositions = numTentacles === 3 ? [-2, 0, 2] : [-3, -1, 1, 3];

                for (let legX of legPositions) {
                    const tentX = cx + legX;
                    const legLen = isChild ? 2 : 3;
                    const legStyle = dna.legStyle || 'block';
                    for (let i = 0; i < legLen; i++) {
                        const py = legY + i;
                        if (py >= 0 && py < size && tentX >= 0 && tentX < size) {
                            if (i === 0) {
                                grid[py][tentX] = '│';
                            } else if (i === legLen - 1) {
                                grid[py][tentX] = legStyle === 'line' ? '▼' : '▽';
                            } else {
                                grid[py][tentX] = i % 2 === 0 ? '│' : '┃';
                            }
                        }
                    }
                }

            } else if (species === 'aquatic') {
                // ═══ AQUATIC: MASSIVELY EXPANDED DNA-based variations ═══

                // ═══ READ ALL VARIATIONS FROM DNA ═══
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const headVariant = dna.headVariant || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const hasDorsalFin = dna.hasDorsalFin;
                const tailShape = dna.tailShape;
                const numGills = dna.numGills;
                const armStyleIdx = dna.armStyleIdx || 0; // For fin variation
                const bellyMarkIdx = dna.bellyMarkIdx || 0;

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 8 : 10;
                const bodyH = isChild ? 3 : 4;

                // VARIABLE HEAD SHAPES (3 variants)
                const headChar = headVariant % 3 === 0 ? '▓' : (headVariant % 3 === 1 ? '█' : '▒');
                for (let y = 0; y < 3; y++) {
                    const w = y === 1 ? 2 : 1;
                    for (let x = -w; x <= w; x++) {
                        if (headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            grid[headY + y][cx + x] = headChar;
                        }
                    }
                }

                // VARIABLE EYES (2-5 eyes with different styles)
                const eyeStyles = ['●', '◉', '○', '◎', '⊙', '◕', '◔', '◐', '◑'];
                const eyeChar = eyeStyles[eyeStyleIdx % eyeStyles.length];

                if (numEyes === 2) {
                    // Standard 2 eyes
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                    }
                } else if (numEyes === 3) {
                    // 3 eyes (one in middle)
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY][cx] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                    }
                } else if (numEyes === 4) {
                    // 4 eyes (2 rows)
                    if (headY >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) {
                            grid[headY][cx - 1] = eyeChar;
                            grid[headY + 1][cx - 1] = eyeChar;
                        }
                        if (cx + 1 < size) {
                            grid[headY][cx + 1] = eyeChar;
                            grid[headY + 1][cx + 1] = eyeChar;
                        }
                    }
                } else {
                    // 5+ eyes (scattered)
                    if (headY >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY][cx] = eyeChar;
                        if (cx - 2 >= 0) grid[headY][cx - 2] = eyeChar;
                        if (cx + 2 < size) grid[headY][cx + 2] = eyeChar;
                    }
                }

                // VARIABLE MOUTH (using mouthStyleIdx)
                const mouthStyles = ['~', '≈', '∼', '〜', '▂', '▁', '═', '━'];
                const mouthChar = mouthStyles[mouthStyleIdx % mouthStyles.length];
                if (headY + 2 >= 0 && headY + 2 < size && cx >= 0 && cx < size) {
                    grid[headY + 2][cx] = mouthChar;
                    if (mouthStyleIdx % 4 >= 2) {
                        // Wider mouth
                        if (cx - 1 >= 0) grid[headY + 2][cx - 1] = mouthChar;
                        if (cx + 1 < size) grid[headY + 2][cx + 1] = mouthChar;
                    }
                }

                // VARIABLE GILLS (2-3 slits)
                for (let g = 0; g < numGills; g++) {
                    const gillY = headY + 2 + g;
                    if (gillY >= 0 && gillY < size) {
                        if (cx - 2 >= 0) grid[gillY][cx - 2] = ')';
                        if (cx + 2 < size) grid[gillY][cx + 2] = '(';
                    }
                }

                // VARIABLE BODY with multiple scale/texture patterns
                const bodyTextures = [
                    ['◊', '◇'], ['▒', '░'], ['▓', '▒'], ['~', '≈'],
                    ['∼', '~'], ['◦', '∘'], ['·', '∙'], ['═', '─'],
                    ['▪', '▫'], ['○', '●']
                ];
                const [tex1, tex2] = bodyTextures[bodyTextureIdx % bodyTextures.length];

                for (let y = 0; y < bodyH; y++) {
                    for (let x = -3; x <= 3; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (x === -3 || x === 3) {
                                grid[bodyY + y][cx + x] = '▓';
                            } else {
                                // Variable texture pattern
                                grid[bodyY + y][cx + x] = (x + y) % 2 === 0 ? tex1 : tex2;
                            }
                        }
                    }
                }

                // VARIABLE BELLY MARK (using bellyMarkIdx)
                const bellyMarks = ['◉', '●', '▣', '◆', '◈', '⊕', '⊗', '⊛'];
                if (bellyMarkIdx < 6) { // Only show on some creatures
                    const markY = bodyY + Math.floor(bodyH / 2);
                    const markChar = bellyMarks[bellyMarkIdx % bellyMarks.length];
                    if (markY >= 0 && markY < size && cx >= 0 && cx < size) {
                        grid[markY][cx] = markChar;
                    }
                }

                // VARIABLE PECTORAL FINS (using armStyleIdx)
                const finStyles = [
                    {char: '─', tip: '▶', angle: '╱'},  // swept back
                    {char: '═', tip: '►', angle: '╱'},  // thick
                    {char: '╌', tip: '▷', angle: '╱'},  // dotted
                    {char: '~', tip: '▸', angle: '╱'},  // wavy
                    {char: '▬', tip: '▶', angle: '╱'},  // solid
                    {char: '━', tip: '▶', angle: '╱'},  // heavy
                ];
                const finStyle = finStyles[armStyleIdx % finStyles.length];
                const finY = bodyY + 1;

                if (finY >= 0 && finY < size) {
                    // Left fin
                    for (let i = 1; i <= 3; i++) {
                        if (cx - 3 - i >= 0) {
                            grid[finY][cx - 3 - i] = i === 1 ? finStyle.angle : finStyle.char;
                        }
                    }
                    if (cx - 3 - 4 >= 0) grid[finY][cx - 3 - 4] = finStyle.tip;

                    // Right fin (mirrored)
                    for (let i = 1; i <= 3; i++) {
                        if (cx + 3 + i < size) {
                            grid[finY][cx + 3 + i] = i === 1 ? '╲' : finStyle.char;
                        }
                    }
                    const mirrorTip = finStyle.tip === '▶' ? '◀' : (finStyle.tip === '►' ? '◄' : '◁');
                    if (cx + 3 + 4 < size) grid[finY][cx + 3 + 4] = mirrorTip;
                }

                // DORSAL FIN (variable)
                if (hasDorsalFin && !isChild) {
                    const dorsalY = bodyY - 1;
                    if (dorsalY >= 0 && cx >= 0 && cx < size) {
                        grid[dorsalY][cx] = '▲';
                    }
                }

                // VENTRAL FINS (bottom, like legs)
                const vFinY = bodyY + bodyH;
                for (let fin of [-1, 1]) {
                    const finX = cx + fin * 2;
                    for (let i = 0; i < 2; i++) {
                        if (vFinY + i >= 0 && vFinY + i < size && finX >= 0 && finX < size) {
                            grid[vFinY + i][finX] = i === 0 ? '╲' : '▼';
                        }
                    }
                }

                // VARIABLE TAIL FIN (3 shapes)
                const tailStart = bodyY + bodyH;
                const tailLen = isChild ? 3 : 5;
                for (let i = 0; i < tailLen; i++) {
                    const ty = tailStart + i;
                    if (ty >= 0 && ty < size) {
                        if (i < tailLen - 2) {
                            // Tail body
                            if (cx >= 0 && cx < size) {
                                grid[ty][cx] = '│';
                            }
                        } else {
                            // Variable tail shapes
                            if (tailShape === 0) {
                                // Fan shape (spread out)
                                for (let spread of [-2, -1, 0, 1, 2]) {
                                    const fanX = cx + spread;
                                    if (fanX >= 0 && fanX < size) {
                                        grid[ty][fanX] = i === tailLen - 1 ? '▼' : '╲';
                                    }
                                }
                            } else if (tailShape === 1) {
                                // Forked tail
                                if (i === tailLen - 1) {
                                    if (cx - 1 >= 0) grid[ty][cx - 1] = '◄';
                                    if (cx + 1 < size) grid[ty][cx + 1] = '►';
                                } else {
                                    if (cx >= 0 && cx < size) grid[ty][cx] = '│';
                                }
                            } else {
                                // Round tail
                                if (i === tailLen - 1) {
                                    if (cx >= 0 && cx < size) grid[ty][cx] = '◯';
                                } else {
                                    if (cx >= 0 && cx < size) grid[ty][cx] = '│';
                                }
                            }
                        }
                    }
                }

            } else {
                // Fallback - shouldn't happen but just in case
                // Draw a simple default creature
                if (cy >= 0 && cy < size && cx >= 0 && cx < size) {
                    grid[cy][cx] = '◉';
                }
            }

            // Convert grid to string
            const ascii = grid.map(row => row.join('')).join('\n');

            return {
                ascii,
                family,
                seed,
                id: Math.random().toString(36).substr(2, 9),
                dna: dna,
                traits: {
                    species: dna.species, // SPECIES IS THE PRIMARY IDENTIFIER
                    bodyType,
                    armCount,
                    legCount,
                    antennaCount,
                    armStyle,
                    legStyle,
                    hatType: dna.hatType,
                    hasCigarette: dna.hasCigarette,
                    eyeSize: dna.eyeSize
                }
            };
        }

        function selectFamily(family) {
            currentFamily = family;

            document.querySelectorAll('.family-btn').forEach(btn => {
                if (btn.dataset.family === family) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            document.getElementById('currentFamilyName').textContent = families[family].name;

            displayFamily(family);
        }

        let spreaderCounter = 0;

        function generateSpreader() {
            // CRITICAL: Pass null to use centralized unique seed generation
            // The seed tracking system guarantees NO duplicates
            const spreader = generateASCIICreature(24, currentFamily, null);
            familyData[currentFamily].spreaders.push(spreader);
            displayFamily(currentFamily);
            updateStats();
        }

        // ═══ DRAMATIC & RANDOM CHARACTER-LEVEL ANIMATIONS ═══
        function applyAnimations(asciiDiv, creature) {
            const dna = creature.dna;
            if (!dna || !dna.animationStage) return;

            let currentAscii = asciiDiv.textContent;

            // EXPANDED eye blink characters - more variety
            const eyeChars = ['●', '◉', '◎', '○', '◯', '⬡', '■', '◆', '▣', '⊙', '◐', '◑', '◔', '◕', '⊗', '⊕', '◈', '◘', '•', '∘', '⊚'];
            const blinkChars = ['-', '‾', '¯', '_', '~', '˜', '⁃'];

            // EXPANDED limb swaps - MANY more variations for dramatic effect
            const limbSwapSets = [
                // Diagonal limbs
                {from: '╱', to: ['╲', '∕', '⟋', '⟍', '/', '\\']},
                {from: '╲', to: ['╱', '∖', '⟍', '⟋', '\\', '/']},
                {from: '∕', to: ['∖', '╱', '╲', '/', '\\']},
                {from: '∖', to: ['∕', '╲', '╱', '\\', '/']},

                // Vertical limbs (legs)
                {from: '│', to: ['┃', '║', '┆', '┇', '┊', '┋', '╎', '╏', '|', 'ǀ', 'ⵏ']},
                {from: '┃', to: ['│', '║', '┆', '┊', '|', 'ǀ']},
                {from: '║', to: ['│', '┃', '|']},

                // Endpoints (feet, hands)
                {from: '▼', to: ['▽', '▿', '∇', 'v', 'V', '⌄']},
                {from: '▽', to: ['▼', '▿', 'v', 'V']},
                {from: '▲', to: ['△', '▴', '∆', '^', 'Λ', '⌃']},
                {from: '△', to: ['▲', '▴', '^', 'Λ']},

                // Horizontal limbs (arms)
                {from: '┤', to: ['├', '┼', '┬', '┴', '╪', '╫', '┿', '+']},
                {from: '├', to: ['┤', '┼', '┬', '┴', '+']},
                {from: '╮', to: ['╭', '╯', '╰', '┐', '┌', '┘', '└']},
                {from: '╭', to: ['╮', '╰', '╯', '┌', '┐']},
                {from: '╯', to: ['╰', '╮', '╭', '┘', '└']},
                {from: '╰', to: ['╯', '╭', '╮', '└', '┘']},

                // Additional body parts
                {from: '╿', to: ['╽', '│', '┃', '|']},
                {from: '╽', to: ['╿', '│', '┃', '|']},
                {from: '╼', to: ['╾', '─', '━', '-']},
                {from: '╾', to: ['╼', '─', '━', '-']}
            ];

            // EXPANDED antenna swaps - more dramatic
            const antennaSwapSets = [
                {from: '●', to: ['○', '◉', '◎', '⊙', '◯', '☉', '⊚', '◌']},
                {from: '○', to: ['●', '◎', '◉', '◯', '⊙']},
                {from: '◉', to: ['◎', '●', '○', '⊙', '⊚']},
                {from: '◎', to: ['◉', '●', '○', '⊙']},
                {from: '✦', to: ['✧', '✶', '✷', '✸', '✹', '✺', '✻', '✼', '*', '＊', '⁎']},
                {from: '✧', to: ['✦', '✶', '✷', '✸', '*']},
                {from: '★', to: ['☆', '✪', '✫', '✬', '✭', '✮', '✯', '✰']},
                {from: '☆', to: ['★', '✪', '✫', '✬']},
                {from: '╱', to: ['╲', '∕', '/', '\\']},
                {from: '╲', to: ['╱', '∖', '\\', '/']},
                {from: '∕', to: ['∖', '╱', '╲', '/', '\\']},
                {from: '∖', to: ['∕', '╲', '╱', '\\', '/']}
            ];

            // BLINK - random blink character each time
            function blink() {
                let ascii = asciiDiv.textContent;
                const blinkChar = blinkChars[Math.floor(Math.random() * blinkChars.length)];

                eyeChars.forEach(char => {
                    ascii = ascii.split(char).join(blinkChar);
                });
                asciiDiv.textContent = ascii;

                setTimeout(() => {
                    asciiDiv.textContent = currentAscii;
                    if (dna.blinkSpeed) setTimeout(blink, dna.blinkSpeed);
                }, 80 + Math.random() * 60); // Random blink duration 80-140ms
            }

            // LIMB SWAP - RANDOM selection from multiple options
            function swapLimbs() {
                let ascii = currentAscii;

                // Randomly pick which limbs to animate this cycle
                limbSwapSets.forEach(swapSet => {
                    if (Math.random() < 0.7) { // 70% chance each limb type animates
                        const randomReplacement = swapSet.to[Math.floor(Math.random() * swapSet.to.length)];
                        ascii = ascii.split(swapSet.from).join(randomReplacement);
                    }
                });

                currentAscii = ascii;
                asciiDiv.textContent = currentAscii;

                if (dna.limbSpeed) setTimeout(swapLimbs, dna.limbSpeed);
            }

            // ANTENNA SWAP - RANDOM and more dramatic
            function swapAntennas() {
                let lines = currentAscii.split('\n');
                const topLineCount = Math.floor(lines.length * 0.35); // Top 35% for antennas

                for (let i = 0; i < topLineCount; i++) {
                    let line = lines[i];

                    // Randomly swap antenna characters
                    antennaSwapSets.forEach(swapSet => {
                        if (Math.random() < 0.6) { // 60% chance each antenna char animates
                            const randomReplacement = swapSet.to[Math.floor(Math.random() * swapSet.to.length)];
                            line = line.split(swapSet.from).join(randomReplacement);
                        }
                    });

                    lines[i] = line;
                }

                currentAscii = lines.join('\n');
                asciiDiv.textContent = currentAscii;

                if (dna.antennaSpeed) setTimeout(swapAntennas, dna.antennaSpeed);
            }

            // Start animations with random initial delays
            if (dna.blinkSpeed) setTimeout(blink, dna.blinkDelay || 0);
            if (dna.limbSpeed) setTimeout(swapLimbs, dna.limbDelay || 0);
            if (dna.antennaSpeed) setTimeout(swapAntennas, dna.antennaDelay || 0);
        }

        function generateChildren(spreaderData, count = 3) {
            for (let i = 0; i < count; i++) {
                // CRITICAL: Pass sibling index to ensure diversity between siblings
                // Each sibling gets different mutation patterns based on their index
                const child = generateASCIICreature(16, spreaderData.family, null, spreaderData.dna, i);
                child.parentId = spreaderData.id;
                familyData[spreaderData.family].children.push(child);
            }
            displayFamily(currentFamily);
            updateStats();
        }

        function displayFamily(family) {
            document.getElementById('spreaders').innerHTML = '';
            document.getElementById('children').innerHTML = '';

            // Display spreaders
            familyData[family].spreaders.forEach(spreader => {
                const card = document.createElement('div');
                card.className = 'spreader-card';
                card.dataset.spreaderId = spreader.id;
                card.onclick = () => generateChildren(spreader);

                // Hover effect to highlight children
                card.onmouseenter = () => {
                    document.querySelectorAll(`.child-card[data-parent-id="${spreader.id}"]`).forEach(c => {
                        c.classList.add('highlight-parent');
                    });
                };
                card.onmouseleave = () => {
                    document.querySelectorAll('.child-card').forEach(c => {
                        c.classList.remove('highlight-parent');
                    });
                };

                const asciiDiv = document.createElement('div');
                asciiDiv.className = `ascii-display spreader-ascii bg-${family}`;
                asciiDiv.textContent = spreader.ascii;
                applyAnimations(asciiDiv, spreader);

                const info = document.createElement('div');
                info.className = 'creature-info';
                info.textContent = `ID: ${spreader.id.substr(0,6)} | Seed: ${Math.floor(spreader.seed % 1000000)} | CLICK TO BREED`;

                // DNA traits display
                const traitsDiv = document.createElement('div');
                traitsDiv.className = 'dna-traits';

                // Species icon mapping
                const speciesIcons = {
                    'insectoid': '⬡',
                    'reptilian': '▓',
                    'mammalian': '░',
                    'viral': '◎',
                    'alien': '※',
                    'aquatic': '≋',
                    'skeletal': '◯'
                };
                const speciesIcon = speciesIcons[spreader.traits.species] || '●';

                const stageEmoji = {calm: '😌', nervous: '😰', adhd: '🤪', crazy: '🤯'}[spreader.dna.animationStage] || '●';

                traitsDiv.innerHTML = `
                    <div class="dna-trait species-trait">${speciesIcon} ${spreader.traits.species.toUpperCase()}</div>
                    <div class="dna-trait species-trait">${stageEmoji} ${spreader.dna.animationStage.toUpperCase()}</div>
                    <div class="dna-trait">Body: ${spreader.dna.bodyType}</div>
                    <div class="dna-trait">Fill: ${spreader.dna.bodyChar}</div>
                    <div class="dna-trait">Eyes: ${spreader.dna.eyeChar}</div>
                    <div class="dna-trait">Arms: ${spreader.dna.armStyle}</div>
                    <div class="dna-trait">Legs: ${spreader.dna.legStyle}</div>
                    ${spreader.dna.hatType !== 'none' ? `<div class="dna-trait">Hat: ${spreader.dna.hatType}</div>` : ''}
                    ${spreader.dna.hasCigarette ? `<div class="dna-trait">🚬</div>` : ''}
                `;

                // Zoom button
                const zoomBtn = document.createElement('button');
                zoomBtn.className = 'zoom-btn';
                zoomBtn.textContent = '🔍 ZOOM';
                zoomBtn.onclick = (e) => {
                    e.stopPropagation();
                    openZoom(spreader, false);
                };

                card.appendChild(asciiDiv);
                card.appendChild(info);
                card.appendChild(traitsDiv);
                card.appendChild(zoomBtn);
                document.getElementById('spreaders').appendChild(card);
            });

            // Display children
            familyData[family].children.forEach(child => {
                const card = document.createElement('div');
                card.className = 'child-card';
                card.dataset.parentId = child.parentId;

                // Find parent
                const parent = familyData[family].spreaders.find(s => s.id === child.parentId);

                const asciiDiv = document.createElement('div');
                asciiDiv.className = `ascii-display child-ascii bg-${family}`;
                asciiDiv.textContent = child.ascii;
                applyAnimations(asciiDiv, child);

                // Click to zoom
                card.onclick = () => {
                    openZoom(child, true, parent);
                };

                // Hover on card to highlight parent
                card.onmouseenter = () => {
                    const parentCard = document.querySelector(`.spreader-card[data-spreader-id="${child.parentId}"]`);
                    if (parentCard) {
                        parentCard.classList.add('selected');
                    }
                };
                card.onmouseleave = () => {
                    document.querySelectorAll('.spreader-card').forEach(c => {
                        c.classList.remove('selected');
                    });
                };

                // Parent link
                const parentLink = document.createElement('div');
                parentLink.className = 'parent-link';
                parentLink.textContent = `↑ ${child.parentId.substr(0,6)}`;

                const info = document.createElement('div');
                info.className = 'creature-info';
                info.textContent = `ID: ${child.id.substr(0,6)}`;

                // DNA traits with inheritance indicators
                const traitsDiv = document.createElement('div');
                traitsDiv.className = 'dna-traits';

                if (parent) {
                    // Species icon mapping
                    const speciesIcons = {
                        'insectoid': '⬡',
                        'reptilian': '▓',
                        'mammalian': '░',
                        'viral': '◎',
                        'alien': '※',
                        'aquatic': '≋',
                        'skeletal': '◯'
                    };
                    const speciesIcon = speciesIcons[child.traits.species] || '●';
                    const stageEmoji = {calm: '😌', nervous: '😰', adhd: '🤪', crazy: '🤯'}[child.dna.animationStage] || '●';

                    // Compare DNA and show inheritance
                    const speciesMatch = child.traits.species === parent.traits.species;
                    const stageMatch = child.dna.animationStage === parent.dna.animationStage;
                    const bodyMatch = child.dna.bodyType === parent.dna.bodyType;
                    const bodyCharMatch = child.dna.bodyChar === parent.dna.bodyChar;
                    const eyeMatch = child.dna.eyeChar === parent.dna.eyeChar;
                    const armMatch = child.dna.armStyle === parent.dna.armStyle;
                    const legMatch = child.dna.legStyle === parent.dna.legStyle;
                    const hatMatch = child.dna.hatType === parent.dna.hatType;

                    traitsDiv.innerHTML = `
                        <div class="dna-trait ${speciesMatch ? 'inherited' : 'mutated'}">${speciesIcon} ${child.traits.species.toUpperCase().substr(0,4)}</div>
                        <div class="dna-trait ${stageMatch ? 'inherited' : 'mutated'}">${stageEmoji} ${child.dna.animationStage.toUpperCase().substr(0,4)}</div>
                        <div class="dna-trait ${bodyMatch ? 'inherited' : 'mutated'}">Body: ${child.dna.bodyType.substr(0,4)}</div>
                        <div class="dna-trait ${bodyCharMatch ? 'inherited' : 'mutated'}">Fill: ${child.dna.bodyChar}</div>
                        <div class="dna-trait ${eyeMatch ? 'inherited' : 'mutated'}">Eye: ${child.dna.eyeChar}</div>
                        <div class="dna-trait ${armMatch ? 'inherited' : 'mutated'}">Arm: ${child.dna.armStyle.substr(0,3)}</div>
                        <div class="dna-trait ${legMatch ? 'inherited' : 'mutated'}">Leg: ${child.dna.legStyle.substr(0,3)}</div>
                        ${child.dna.hatType !== 'none' ? `<div class="dna-trait ${hatMatch ? 'inherited' : 'mutated'}">Hat: ${child.dna.hatType.substr(0,3)}</div>` : ''}
                        ${child.dna.hasCigarette ? `<div class="dna-trait mutated">🚬</div>` : ''}
                    `;
                } else {
                    traitsDiv.innerHTML = `<div style="color: #cc0000;">Parent not found</div>`;
                }

                card.appendChild(parentLink);
                card.appendChild(asciiDiv);
                card.appendChild(info);
                card.appendChild(traitsDiv);
                document.getElementById('children').appendChild(card);
            });
        }

        function clearFamily() {
            familyData[currentFamily] = { spreaders: [], children: [] };
            displayFamily(currentFamily);
            updateStats();
        }

        function clearAll() {
            Object.keys(families).forEach(key => {
                familyData[key] = { spreaders: [], children: [] };
            });
            displayFamily(currentFamily);
            updateStats();
        }

        function updateStats() {
            let activeFamilies = 0;
            let totalSpreaders = 0;
            let totalChildren = 0;

            Object.keys(familyData).forEach(key => {
                if (familyData[key].spreaders.length > 0) activeFamilies++;
                totalSpreaders += familyData[key].spreaders.length;
                totalChildren += familyData[key].children.length;
            });

            document.getElementById('activeFamilies').textContent = activeFamilies;
            document.getElementById('totalSpreaders').textContent = totalSpreaders;
            document.getElementById('totalChildren').textContent = totalChildren;
        }

        function exportData() {
            const data = {
                protocol: 'ASCII_PROTOCOLITE_VI',
                version: '6.0',
                timestamp: new Date().toISOString(),
                families: {}
            };

            Object.keys(familyData).forEach(key => {
                if (familyData[key].spreaders.length > 0) {
                    data.families[key] = {
                        spreaders: familyData[key].spreaders.map(s => ({
                            id: s.id,
                            seed: s.seed,
                            ascii: s.ascii,
                            dna: s.dna,
                            traits: s.traits
                        })),
                        children: familyData[key].children.map(c => ({
                            id: c.id,
                            parentId: c.parentId,
                            seed: c.seed,
                            ascii: c.ascii,
                            dna: c.dna,
                            traits: c.traits
                        }))
                    };
                }
            });

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ascii_protocolite_v5_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Zoom Modal Functions
        function openZoom(creature, isChild = false, parent = null) {
            const modal = document.getElementById('zoomModal');
            const title = document.getElementById('zoomTitle');
            const id = document.getElementById('zoomId');
            const ascii = document.getElementById('zoomAscii');
            const dnaGrid = document.getElementById('zoomDnaGrid');

            // Set title and ID
            title.textContent = isChild ? 'CHILD' : 'SPREADER';
            id.textContent = `ID: ${creature.id}`;

            // Set ASCII art with colored background
            ascii.textContent = creature.ascii;
            ascii.className = `zoom-ascii bg-${creature.family}`;

            // Apply animations to zoomed creature
            applyAnimations(ascii, creature);

            // Build DNA traits grid
            let dnaHtml = '';

            if (isChild && parent) {
                // Show inheritance comparison for children
                const speciesMatch = creature.traits.species === parent.traits.species;
                const bodyMatch = creature.dna.bodyType === parent.dna.bodyType;
                const bodyCharMatch = creature.dna.bodyChar === parent.dna.bodyChar;
                const eyeMatch = creature.dna.eyeChar === parent.dna.eyeChar;
                const armMatch = creature.dna.armStyle === parent.dna.armStyle;
                const legMatch = creature.dna.legStyle === parent.dna.legStyle;
                const hatMatch = creature.dna.hatType === parent.dna.hatType;

                // Species icon mapping
                const speciesIcons = {
                    'insectoid': '⬡',
                    'reptilian': '▓',
                    'mammalian': '░',
                    'viral': '◎',
                    'alien': '※',
                    'aquatic': '≋',
                    'skeletal': '◯'
                };
                const speciesIcon = speciesIcons[creature.traits.species] || '●';

                dnaHtml = `
                    <div class="zoom-dna-item ${speciesMatch ? 'inherited' : 'mutated'}" style="grid-column: 1 / -1; font-size: 14px; font-weight: 300;">
                        <div class="zoom-dna-label">SPECIES ${speciesMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${speciesIcon} ${creature.traits.species.toUpperCase()}</div>
                    </div>
                    <div class="zoom-dna-item ${bodyMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Body Type ${bodyMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.bodyType}</div>
                    </div>
                    <div class="zoom-dna-item ${bodyCharMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Body Fill ${bodyCharMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.bodyChar}</div>
                    </div>
                    <div class="zoom-dna-item ${eyeMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Eye Character ${eyeMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.eyeChar}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Eye Size</div>
                        <div class="zoom-dna-value">${creature.dna.eyeSize || 'normal'}</div>
                    </div>
                    <div class="zoom-dna-item ${armMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Arm Style ${armMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.armStyle}</div>
                    </div>
                    <div class="zoom-dna-item ${legMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Leg Style ${legMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.legStyle}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Antenna Tip</div>
                        <div class="zoom-dna-value">${creature.dna.antennaTip}</div>
                    </div>
                    ${creature.dna.hatType !== 'none' ? `
                    <div class="zoom-dna-item ${hatMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Hat ${hatMatch ? '✓ Inherited' : '✗ Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.hatType}</div>
                    </div>
                    ` : ''}
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Cigarette</div>
                        <div class="zoom-dna-value">${creature.dna.hasCigarette ? 'Yes 🚬' : 'No'}</div>
                    </div>
                    <div class="zoom-dna-item inherited" style="grid-column: 1 / -1;">
                        <div class="zoom-dna-label">Parent ID</div>
                        <div class="zoom-dna-value">${creature.parentId}</div>
                    </div>
                `;
            } else {
                // Show DNA for spreaders
                // Species icon mapping
                const speciesIcons = {
                    'insectoid': '⬡',
                    'reptilian': '▓',
                    'mammalian': '░',
                    'viral': '◎',
                    'alien': '※',
                    'aquatic': '≋',
                    'skeletal': '◯'
                };
                const speciesIcon = speciesIcons[creature.traits.species] || '●';

                dnaHtml = `
                    <div class="zoom-dna-item" style="grid-column: 1 / -1; font-size: 14px; font-weight: 300;">
                        <div class="zoom-dna-label">SPECIES</div>
                        <div class="zoom-dna-value">${speciesIcon} ${creature.traits.species.toUpperCase()}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Body Type</div>
                        <div class="zoom-dna-value">${creature.dna.bodyType}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Body Fill</div>
                        <div class="zoom-dna-value">${creature.dna.bodyChar}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Eye Character</div>
                        <div class="zoom-dna-value">${creature.dna.eyeChar}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Eye Size</div>
                        <div class="zoom-dna-value">${creature.dna.eyeSize || 'normal'}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Arm Style</div>
                        <div class="zoom-dna-value">${creature.dna.armStyle}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Leg Style</div>
                        <div class="zoom-dna-value">${creature.dna.legStyle}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Antenna Tip</div>
                        <div class="zoom-dna-value">${creature.dna.antennaTip}</div>
                    </div>
                    ${creature.dna.hatType !== 'none' ? `
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Hat</div>
                        <div class="zoom-dna-value">${creature.dna.hatType}</div>
                    </div>
                    ` : ''}
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Cigarette</div>
                        <div class="zoom-dna-value">${creature.dna.hasCigarette ? 'Yes 🚬' : 'No'}</div>
                    </div>
                    <div class="zoom-dna-item" style="grid-column: 1 / -1;">
                        <div class="zoom-dna-label">Seed</div>
                        <div class="zoom-dna-value">${creature.seed}</div>
                    </div>
                `;
            }

            dnaGrid.innerHTML = dnaHtml;

            // Show modal
            modal.classList.add('active');

            // Add escape key listener
            document.addEventListener('keydown', handleEscapeKey);
        }

        function closeZoom(event) {
            const modal = document.getElementById('zoomModal');
            modal.classList.remove('active');
            document.removeEventListener('keydown', handleEscapeKey);
        }

        function handleEscapeKey(event) {
            if (event.key === 'Escape') {
                closeZoom();
            }
        }

        // Initialize
        selectFamily('red');
        updateStats();
    </script>
</body>
</html>
