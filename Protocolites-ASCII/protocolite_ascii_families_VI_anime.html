<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éó„É≠„Éà„Ç≥„É©„Ç§„Éà // ASCII PROTOCOLITE VI ANIMATED</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100;200;300;400&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #000000;
            color: #ffffff;
            line-height: 1;
            font-size: 12px;
            font-weight: 200;
            padding: 0;
            margin: 0;
        }

        .header {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 30px;
        }

        h1 {
            font-size: 13px;
            font-weight: 200;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        .subtitle {
            font-size: 10px;
            color: #999;
            letter-spacing: 0.2em;
        }

        /* Creatures are all white, backgrounds are colored by family */
        .ascii-display { color: #ffffff; }

        /* Family background colors */
        .bg-red { background-color: #cc0000; }
        .bg-green { background-color: #008800; }
        .bg-blue { background-color: #0044cc; }
        .bg-yellow { background-color: #cc9900; }
        .bg-purple { background-color: #8800cc; }
        .bg-cyan { background-color: #0088aa; }

        .main-container {
            display: flex;
            height: calc(100vh - 120px);
        }

        .sidebar {
            width: 320px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            padding: 30px 20px;
            overflow-y: auto;
        }

        .content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: #000000;
        }

        .control-section {
            margin-bottom: 30px;
        }

        .control-title {
            font-size: 10px;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #999;
            margin-bottom: 15px;
        }

        .family-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }

        .family-btn {
            padding: 12px;
            background: #2a2a2a;
            color: #ffffff;
            border: 1px solid #444;
            font-family: inherit;
            font-size: 9px;
            font-weight: 300;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
        }

        .family-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }

        .family-btn.active {
            background: #ffffff;
            color: #000000;
            border-color: #ffffff;
        }

        .family-btn[data-family="red"] { border-left: 3px solid #ff3333; }
        .family-btn[data-family="green"] { border-left: 3px solid #33ff33; }
        .family-btn[data-family="blue"] { border-left: 3px solid #3366ff; }
        .family-btn[data-family="yellow"] { border-left: 3px solid #ffff33; }
        .family-btn[data-family="purple"] { border-left: 3px solid #ff33ff; }
        .family-btn[data-family="cyan"] { border-left: 3px solid #33ffff; }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #ffffff;
            font-family: inherit;
            font-size: 10px;
            font-weight: 300;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: #cccccc;
            border-color: #cccccc;
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #ffffff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
            border-color: #666;
        }

        .stats-panel {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 10px;
            color: #999;
        }

        .stat-value {
            color: #fff;
            font-weight: 400;
        }

        .creatures-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            height: 100%;
        }

        .spreaders-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .children-panel {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #999;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .spreader-card {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .spreader-card:hover {
            transform: translateX(5px);
            box-shadow: -5px 0 15px rgba(255,255,255,0.1);
        }

        .ascii-display {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            line-height: 10px;
            letter-spacing: 0;
            white-space: pre;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }

        .spreader-ascii {
            font-size: 9px;
            line-height: 9px;
        }

        .child-ascii {
            font-size: 8px;
            line-height: 8px;
        }

        .creature-info {
            font-size: 9px;
            color: #888;
            margin-top: 8px;
        }

        .children-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .child-card {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 10px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .child-card:hover {
            background: #2a2a2a;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }

        /* Removed - creatures are all white, only backgrounds are colored */

        .dna-documentation {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 15px;
            margin-top: 20px;
            font-size: 9px;
            line-height: 1.6;
        }

        .dna-doc-title {
            font-weight: 400;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-size: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            color: #fff;
        }

        .dna-section {
            margin-bottom: 12px;
        }

        .dna-section-title {
            font-weight: 400;
            color: #fff;
            margin-bottom: 5px;
            font-size: 9px;
        }

        .dna-item {
            padding: 3px 0;
            color: #999;
            padding-left: 10px;
        }

        .dna-example {
            background: #1a1a1a;
            border: 1px solid #444;
            padding: 8px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            color: #ccc;
        }

        .inheritance-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .inherited-100 { background: #00cc00; }
        .inherited-80 { background: #ffcc00; }
        .inherited-random { background: #cc0000; }

        .dna-traits {
            font-size: 8px;
            color: #ccc;
            margin-top: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 3px;
            line-height: 1.5;
        }

        .dna-trait {
            display: inline-block;
            margin-right: 8px;
            padding: 2px 4px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 2px;
        }

        .dna-trait.inherited {
            background: #1a3a1a;
            border-color: #4a8;
        }

        .dna-trait.mutated {
            background: #3a1a1a;
            border-color: #a44;
        }

        /* Species badge - prominent display */
        .species-trait {
            font-weight: 300;
            font-size: 10px;
            background: #333;
            border: 1px solid #666;
            padding: 3px 6px;
            letter-spacing: 0.05em;
        }

        .parent-link {
            display: inline-block;
            padding: 2px 6px;
            background: #fff;
            color: #000;
            font-size: 8px;
            border-radius: 2px;
            margin-bottom: 5px;
        }

        .spreader-card.selected {
            border: 2px solid #fff;
            background: #3a3a20;
        }

        .child-card[data-parent-id] {
            position: relative;
        }

        .child-card[data-parent-id]::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .child-card.highlight-parent::before {
            border-color: #ffcc00;
        }

        /* Zoom Modal */
        .zoom-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s ease;
        }

        .zoom-modal.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .zoom-content {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 4px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
            animation: zoomIn 0.3s ease;
            border: 1px solid #444;
        }

        @keyframes zoomIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .zoom-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background: #000;
            color: #fff;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-close:hover {
            background: #ff0000;
            transform: rotate(90deg);
        }

        .zoom-ascii {
            font-family: 'Courier New', monospace;
            line-height: 1.2;
            white-space: pre;
            font-size: 20px;
            margin: 20px 0;
            text-align: center;
            padding: 20px;
            border-radius: 4px;
        }

        .zoom-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e8e8e8;
        }

        .zoom-title {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .zoom-id {
            font-size: 11px;
            color: #666;
            letter-spacing: 0.1em;
        }

        .zoom-dna-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #333;
        }

        .zoom-dna-title {
            font-size: 11px;
            font-weight: 400;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 15px;
            color: #fff;
        }

        .zoom-dna-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .zoom-dna-item {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 3px;
            font-size: 10px;
        }

        .zoom-dna-item.inherited {
            background: #1a3a1a;
            border-left: 3px solid #4a8;
        }

        .zoom-dna-item.mutated {
            background: #3a1a1a;
            border-left: 3px solid #a44;
        }

        .zoom-dna-label {
            font-weight: 400;
            color: #999;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.1em;
        }

        .zoom-dna-value {
            color: #fff;
            font-size: 12px;
            margin-top: 5px;
        }

        .zoom-btn {
            padding: 6px 12px;
            background: #fff;
            color: #000;
            border: none;
            font-family: inherit;
            font-size: 8px;
            font-weight: 300;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
            width: 100%;
        }

        .zoom-btn:hover {
            background: #ccc;
        }

        .spreader-card {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Zoom Modal -->
    <div class="zoom-modal" id="zoomModal" onclick="closeZoom(event)">
        <div class="zoom-content" onclick="event.stopPropagation()">
            <button class="zoom-close" onclick="closeZoom()">&times;</button>
            <div class="zoom-header">
                <div class="zoom-title" id="zoomTitle">SPREADER</div>
                <div class="zoom-id" id="zoomId">ID: ---</div>
            </div>
            <div class="zoom-ascii" id="zoomAscii"></div>
            <div class="zoom-dna-section">
                <div class="zoom-dna-title">DNA TRAITS</div>
                <div class="zoom-dna-grid" id="zoomDnaGrid"></div>
            </div>
        </div>
    </div>

    <div class="header">
        <h1>„Éó„É≠„Éà„Ç≥„É©„Ç§„Éà // ASCII PROTOCOLITE VI ANIMATED</h1>
        <div class="subtitle">MULTI-SPECIES DNA SYSTEM ‚Äî 7 ANATOMICALLY DISTINCT CREATURES ‚Äî GENERATIVE ASCII ART PROTOCOL ‚Äî ANIMATED</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="control-section">
                <div class="control-title">Family Selection</div>
                <div class="family-grid">
                    <button class="family-btn" data-family="red" onclick="selectFamily('red')">RED<br>Ëµ§</button>
                    <button class="family-btn" data-family="green" onclick="selectFamily('green')">GREEN<br>Á∑ë</button>
                    <button class="family-btn" data-family="blue" onclick="selectFamily('blue')">BLUE<br>Èùí</button>
                    <button class="family-btn" data-family="yellow" onclick="selectFamily('yellow')">YELLOW<br>ÈªÑ</button>
                    <button class="family-btn" data-family="purple" onclick="selectFamily('purple')">PURPLE<br>Á¥´</button>
                    <button class="family-btn" data-family="cyan" onclick="selectFamily('cyan')">CYAN<br>Ê∞¥</button>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">Actions</div>
                <div class="action-buttons">
                    <button class="btn" onclick="generateSpreader()">GENERATE SPREADER</button>
                    <button class="btn btn-secondary" onclick="clearFamily()">CLEAR FAMILY</button>
                    <button class="btn btn-secondary" onclick="clearAll()">CLEAR ALL</button>
                    <button class="btn btn-secondary" onclick="exportData()">EXPORT DATA</button>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <span>Active Families:</span>
                    <span class="stat-value" id="activeFamilies">0</span>
                </div>
                <div class="stat-item">
                    <span>Total Spreaders:</span>
                    <span class="stat-value" id="totalSpreaders">0</span>
                </div>
                <div class="stat-item">
                    <span>Total Children:</span>
                    <span class="stat-value" id="totalChildren">0</span>
                </div>
                <div class="stat-item">
                    <span>Current Family:</span>
                    <span class="stat-value" id="currentFamilyName">RED</span>
                </div>
            </div>

            <div class="dna-documentation">
                <div class="dna-doc-title">DNA System Documentation</div>

                <div class="dna-section">
                    <div class="dna-section-title">üß¨ Color Inheritance</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Family color (100% inherited)</div>
                    <div class="dna-item">‚Ä¢ Children always match parent's family</div>
                </div>

                <div class="dna-section">
                    <div class="dna-section-title">üé® ASCII Attributes</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Body Type: 100% inherited</div>
                    <div class="dna-item">‚Ä¢ square, round, diamond, mushroom, etc.</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Body Char: 80% inherited</div>
                    <div class="dna-item">‚Ä¢ ‚ñà ‚ñì ‚ñí ‚ñë (20% mutation chance)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Eye Char: 80% inherited</div>
                    <div class="dna-item">‚Ä¢ ‚óè ‚óâ ‚óé ‚óã (always present!)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Antenna Tip: 80% inherited</div>
                    <div class="dna-item">‚Ä¢ ‚óè ‚óâ ‚óã ‚óé ‚ú¶ ‚úß ‚òÖ</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Arm Style: 100% inherited</div>
                    <div class="dna-item">‚Ä¢ block (‚ñà) or line (‚îÄ)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-100"></span>Leg Style: 100% inherited</div>
                    <div class="dna-item">‚Ä¢ block (‚ñà) or line (‚îÇ)</div>
                </div>

                <div class="dna-section">
                    <div class="dna-section-title">‚ú® New Attributes (V)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Hat: 80% inherited</div>
                    <div class="dna-item">‚Ä¢ ‚ñÄ ‚ñÑ ‚ïê ‚ïî‚ïó (if parent has hat)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-random"></span>Cigarette: Random</div>
                    <div class="dna-item">‚Ä¢ ‚âà ‚àº ~ (10% chance)</div>
                    <div class="dna-item"><span class="inheritance-indicator inherited-80"></span>Eye Size: 80% inherited</div>
                    <div class="dna-item">‚Ä¢ Regular or MEGA eyes</div>
                </div>

                <div class="dna-section">
                    <div class="dna-section-title">üìä DNA Code Format</div>
                    <div class="dna-example">[BODY-CHAR-EYE-ARM-LEG-HAT]<br>Example: [sq-‚ñà-‚óè-blo-blo-‚ñÄ]<br><br>sq = square body<br>‚ñà = solid body fill<br>‚óè = round eyes<br>blo = block limbs<br>‚ñÄ = top hat</div>
                </div>
            </div>
        </div>

        <div class="content">
            <div class="creatures-grid">
                <div class="spreaders-panel">
                    <div class="panel-title">SPREADERS (24√ó24) ‚Äî Click to breed</div>
                    <div id="spreaders"></div>
                </div>

                <div class="children-panel">
                    <div class="panel-title">CHILDREN (16√ó16)</div>
                    <div class="children-grid" id="children"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const families = {
            red: { name: 'RED', class: 'ascii-red' },
            green: { name: 'GREEN', class: 'ascii-green' },
            blue: { name: 'BLUE', class: 'ascii-blue' },
            yellow: { name: 'YELLOW', class: 'ascii-yellow' },
            purple: { name: 'PURPLE', class: 'ascii-purple' },
            cyan: { name: 'CYAN', class: 'ascii-cyan' }
        };

        let currentFamily = 'red';
        let familyData = {};

        // CRITICAL: Unique seed tracking to prevent duplicates
        let seedCounter = 0;
        let usedSeeds = new Set();

        // Initialize family data
        Object.keys(families).forEach(key => {
            familyData[key] = { spreaders: [], children: [] };
        });

        function generateASCIICreature(size, family, seed = null, parentDNA = null, siblingIndex = 0) {
            // If no seed provided, generate a GUARANTEED UNIQUE one
            if (seed === null) {
                // Use multiple sources of entropy + counter to ensure uniqueness
                let newSeed;
                let attempts = 0;
                do {
                    seedCounter++;
                    newSeed = Date.now() + seedCounter * 1000000 + Math.random() * 999999999;
                    attempts++;
                    if (attempts > 100) {
                        // Failsafe: just use counter if we can't find unused seed
                        newSeed = Date.now() + seedCounter * 1000000000;
                        break;
                    }
                } while (usedSeeds.has(newSeed));

                seed = newSeed;
                usedSeeds.add(seed);
            }

            // Seeded random
            let s = seed;
            function random() {
                s = (s * 9301 + 49297) % 233280;
                return s / 233280;
            }

            // DNA INHERITANCE SYSTEM
            const isChild = size === 16;
            let dna = {};

            if (parentDNA) {
                // CHILD: Inherit DNA from parent with mutations
                dna.species = parentDNA.species; // 100% inherited - SPECIES NEVER CHANGES
                dna.bodyType = parentDNA.bodyType; // 100% inherited
                dna.armStyle = parentDNA.armStyle; // 100% inherited
                dna.legStyle = parentDNA.legStyle; // 100% inherited

                // Body character: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.bodyChar = parentDNA.bodyChar;
                } else {
                    const bodyChars = ['‚ñà', '‚ñì', '‚ñí', '‚ñë'];
                    dna.bodyChar = bodyChars[Math.floor(random() * bodyChars.length)];
                }

                // Eye style: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.eyeChar = parentDNA.eyeChar;
                } else {
                    const eyeChars = ['‚óè', '‚óâ', '‚óé', '‚óã'];
                    dna.eyeChar = eyeChars[Math.floor(random() * eyeChars.length)];
                }

                // Eye size: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.eyeSize = parentDNA.eyeSize;
                } else {
                    dna.eyeSize = random() > 0.5 ? 'normal' : 'mega';
                }

                // Antenna tip: 40% inherit, 60% mutate (REDUCED from 80%)
                if (random() < 0.40) {
                    dna.antennaTip = parentDNA.antennaTip;
                } else {
                    const antennaTips = ['‚óè', '‚óâ', '‚óã', '‚óé', '‚ú¶', '‚úß', '‚òÖ'];
                    dna.antennaTip = antennaTips[Math.floor(random() * antennaTips.length)];
                }

                // Hat: 50% inherit if parent has hat (REDUCED from 80%)
                if (parentDNA.hatType && parentDNA.hatType !== 'none') {
                    if (random() < 0.50) {
                        dna.hatType = parentDNA.hatType;
                    } else {
                        const hatTypes = ['none', 'top', 'flat', 'double', 'fancy'];
                        dna.hatType = hatTypes[Math.floor(random() * hatTypes.length)];
                    }
                } else {
                    // Parent has no hat, HIGHER chance child gets one (30% up from 15%)
                    dna.hatType = random() < 0.30 ? ['top', 'flat', 'double', 'fancy'][Math.floor(random() * 4)] : 'none';
                }

                // Cigarette: Random 25% chance (INCREASED from 10%)
                dna.hasCigarette = random() < 0.25;

                // ‚ïê‚ïê‚ïê VI EXTENDED DNA INHERITANCE WITH HIGH SIBLING DIVERSITY ‚ïê‚ïê‚ïê
                // Each sibling focuses mutations on DIFFERENT property groups
                // Sibling 0: Facial features mutate AGGRESSIVELY (eyes, mouth, nose)
                // Sibling 1: Body features mutate AGGRESSIVELY (texture, marks, head)
                // Sibling 2: Limb features mutate AGGRESSIVELY (arms, legs, claws)
                // This creates DRAMATICALLY DIFFERENT siblings while maintaining species identity

                // EXTREME mutation probabilities for DRAMATIC visual diversity
                // Children should look significantly different from parents!
                const facialMutationRate = siblingIndex === 0 ? 0.90 : 0.70;  // 90% vs 70% - MUCH higher!
                const bodyMutationRate = siblingIndex === 1 ? 0.90 : 0.70;    // 90% vs 70%
                const limbMutationRate = siblingIndex === 2 ? 0.90 : 0.70;    // 90% vs 70%
                const detailMutationRate = 0.75; // 75% for all details (up from 50%)
                const wildMutationChance = 0.40; // 40% chance of complete randomization (up from 15%!)

                // EYES - Sibling 0 mutates these more + wild mutation chance
                dna.numEyes = (random() < wildMutationChance) ? (Math.floor(random() * 4) + 2) :
                              (random() < (1 - facialMutationRate) ? parentDNA.numEyes : (Math.floor(random() * 4) + 2));
                dna.eyeStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                  (random() < (1 - facialMutationRate) ? parentDNA.eyeStyleIdx : Math.floor(random() * 18));
                dna.pupilStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 9) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.pupilStyleIdx : Math.floor(random() * 9));
                dna.hasPupils = (random() < wildMutationChance) ? (random() < 0.7) :
                                (random() < (1 - facialMutationRate) ? parentDNA.hasPupils : (random() < 0.7));
                dna.eyebrowStyleIdx = random() < (1 - facialMutationRate) ? parentDNA.eyebrowStyleIdx : Math.floor(random() * 7);
                dna.hasEyebrows = random() < (1 - facialMutationRate) ? parentDNA.hasEyebrows : (random() < 0.4);

                // MOUTH - Sibling 0 mutates these more + wild mutation chance
                dna.mouthStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 19) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.mouthStyleIdx : Math.floor(random() * 19));
                dna.teethStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 12) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.teethStyleIdx : Math.floor(random() * 12));
                dna.hasTeeth = random() < (1 - facialMutationRate) ? parentDNA.hasTeeth : (random() < 0.5);

                // NOSE - Sibling 0 mutates these more
                dna.noseStyleIdx = random() < (1 - facialMutationRate) ? parentDNA.noseStyleIdx : Math.floor(random() * 15);
                dna.hasNose = random() < (1 - facialMutationRate) ? parentDNA.hasNose : (random() < 0.3);

                // BODY - Sibling 1 mutates these more + wild mutation chance
                dna.headVariant = (random() < wildMutationChance) ? Math.floor(random() * 7) :
                                  (random() < (1 - bodyMutationRate) ? parentDNA.headVariant : Math.floor(random() * 7));
                dna.bodyTextureIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                     (random() < (1 - bodyMutationRate) ? parentDNA.bodyTextureIdx : Math.floor(random() * 18));
                dna.bellyMarkIdx = (random() < wildMutationChance) ? Math.floor(random() * 8) :
                                   (random() < (1 - bodyMutationRate) ? parentDNA.bellyMarkIdx : Math.floor(random() * 8));

                // LIMBS - Sibling 2 mutates these more + wild mutation chance
                dna.armStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 12) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.armStyleIdx : Math.floor(random() * 12));
                dna.legStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 11) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.legStyleIdx : Math.floor(random() * 11));
                dna.numArms = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                              (random() < (1 - limbMutationRate) ? parentDNA.numArms : (Math.floor(random() * 3) + 2));
                dna.numLegs = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                              (random() < (1 - limbMutationRate) ? parentDNA.numLegs : (Math.floor(random() * 3) + 2));
                dna.hasClaws = (random() < wildMutationChance) ? (random() < 0.6) :
                               (random() < (1 - limbMutationRate) ? parentDNA.hasClaws : (random() < 0.6));
                dna.hasToes = random() < (1 - limbMutationRate) ? parentDNA.hasToes : (random() < 0.5);

                // DETAILS - All siblings get 30% mutation
                dna.faceMarkIdx = random() < (1 - detailMutationRate) ? parentDNA.faceMarkIdx : Math.floor(random() * 9);
                dna.hasSpots = random() < (1 - detailMutationRate) ? parentDNA.hasSpots : (random() < 0.6);
                dna.scarMarkIdx = random() < (1 - detailMutationRate) ? parentDNA.scarMarkIdx : Math.floor(random() * 6);
                dna.hasScars = random() < (1 - detailMutationRate) ? parentDNA.hasScars : (random() < 0.2);

                // SPECIES-SPECIFIC - Apply same diversity pattern
                // Use bodyMutationRate for structural traits, facialMutationRate for appendages

                // Insectoid - EXPANDED with ALL trait mutations for maximum variety!
                dna.legStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 11) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.legStyleIdx : Math.floor(random() * 11));
                dna.eyeStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                  (random() < (1 - facialMutationRate) ? parentDNA.eyeStyleIdx : Math.floor(random() * 18));
                dna.antennaTip = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.antennaTip : Math.floor(random() * 18));
                dna.antennaLength = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                                    (random() < (1 - facialMutationRate) ? parentDNA.antennaLength : (Math.floor(random() * 3) + 2));
                dna.bodyTextureIdx = (random() < wildMutationChance) ? Math.floor(random() * 18) :
                                     (random() < (1 - bodyMutationRate) ? parentDNA.bodyTextureIdx : Math.floor(random() * 18));
                dna.segmentWidth = (random() < wildMutationChance) ? Math.floor(random() * 2) :
                                   (random() < (1 - bodyMutationRate) ? parentDNA.segmentWidth : Math.floor(random() * 2));
                dna.hasWings = (random() < wildMutationChance) ? (random() < 0.5) :
                               (random() < (1 - limbMutationRate) ? parentDNA.hasWings : (random() < 0.5));
                dna.wingCharIdx = (random() < wildMutationChance) ? Math.floor(random() * 6) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.wingCharIdx : Math.floor(random() * 6));
                dna.mandibleStyleIdx = (random() < wildMutationChance) ? Math.floor(random() * 4) :
                                       (random() < (1 - facialMutationRate) ? parentDNA.mandibleStyleIdx : Math.floor(random() * 4));
                // New insectoid traits for even more variety
                dna.hasAntennae = (random() < wildMutationChance) ? (random() < 0.9) :
                                  (random() < (1 - facialMutationRate) ? (parentDNA.hasAntennae !== false) : (random() < 0.9));
                dna.legCount = (random() < wildMutationChance) ? (Math.floor(random() * 2) + 3) :
                               (random() < (1 - limbMutationRate) ? (parentDNA.legCount || 3) : (Math.floor(random() * 2) + 3));
                dna.hasStingers = (random() < wildMutationChance) ? (random() < 0.3) :
                                  (random() < (1 - detailMutationRate) ? parentDNA.hasStingers : (random() < 0.3));

                // Reptilian - EXPANDED with wild mutations
                dna.hasTongue = (random() < wildMutationChance) ? (random() < 0.7) :
                                (random() < (1 - facialMutationRate) ? parentDNA.hasTongue : (random() < 0.7));
                dna.hasSpines = (random() < wildMutationChance) ? (random() < 0.6) :
                                (random() < (1 - bodyMutationRate) ? parentDNA.hasSpines : (random() < 0.6));
                dna.tailStyle = (random() < wildMutationChance) ? Math.floor(random() * 3) :
                                (random() < (1 - limbMutationRate) ? parentDNA.tailStyle : Math.floor(random() * 3));
                dna.bodyHeightVariant = (random() < wildMutationChance) ? Math.floor(random() * 2) :
                                        (random() < (1 - bodyMutationRate) ? parentDNA.bodyHeightVariant : Math.floor(random() * 2));
                // New reptilian traits with HIGH mutation
                dna.hasHorns = (random() < wildMutationChance) ? (random() < 0.4) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasHorns : (random() < 0.4));
                dna.hasFrill = (random() < wildMutationChance) ? (random() < 0.3) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasFrill : (random() < 0.3));
                dna.spineCount = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 2) :
                                 (random() < (1 - bodyMutationRate) ? parentDNA.spineCount : (Math.floor(random() * 3) + 2));
                dna.scaleSize = (random() < wildMutationChance) ? Math.floor(random() * 3) :
                                (random() < (1 - bodyMutationRate) ? parentDNA.scaleSize : Math.floor(random() * 3));

                // Mammalian
                dna.earStyle = random() < (1 - facialMutationRate) ? parentDNA.earStyle : Math.floor(random() * 3);
                dna.hasTail = random() < (1 - limbMutationRate) ? parentDNA.hasTail : (random() < 0.8);
                dna.hasWhiskers = random() < (1 - facialMutationRate) ? parentDNA.hasWhiskers : (random() < 0.7);

                // Skeletal - MASSIVELY EXPANDED with EXTREME wild mutation for maximum diversity
                // Each sibling can have dramatically different skeletal structure
                dna.jawStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                               (random() < (1 - facialMutationRate) ? parentDNA.jawStyle : Math.floor(random() * 5));
                dna.ribCount = (random() < wildMutationChance) ? (Math.floor(random() * 4) + 2) :
                               (random() < (1 - bodyMutationRate) ? parentDNA.ribCount : (Math.floor(random() * 4) + 2));
                dna.ribStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                               (random() < (1 - bodyMutationRate) ? parentDNA.ribStyle : Math.floor(random() * 5));
                dna.spineStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - bodyMutationRate) ? parentDNA.spineStyle : Math.floor(random() * 5));
                dna.spineHeightVariant = (random() < wildMutationChance) ? Math.floor(random() * 4) :
                                         (random() < (1 - bodyMutationRate) ? parentDNA.spineHeightVariant : Math.floor(random() * 4));
                dna.skullShape = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.skullShape : Math.floor(random() * 5));
                dna.eyeSocketStyle = (random() < wildMutationChance) ? Math.floor(random() * 6) :
                                     (random() < (1 - facialMutationRate) ? parentDNA.eyeSocketStyle : Math.floor(random() * 6));
                dna.nasalStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.nasalStyle : Math.floor(random() * 5));
                dna.armBoneStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                   (random() < (1 - limbMutationRate) ? parentDNA.armBoneStyle : Math.floor(random() * 5));
                dna.legBoneStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                   (random() < (1 - limbMutationRate) ? parentDNA.legBoneStyle : Math.floor(random() * 5));
                dna.jointStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                 (random() < (1 - limbMutationRate) ? parentDNA.jointStyle : Math.floor(random() * 5));
                dna.fingerStyle = (random() < wildMutationChance) ? Math.floor(random() * 6) :
                                  (random() < (1 - limbMutationRate) ? parentDNA.fingerStyle : Math.floor(random() * 6));
                dna.footStyle = (random() < wildMutationChance) ? Math.floor(random() * 5) :
                                (random() < (1 - limbMutationRate) ? parentDNA.footStyle : Math.floor(random() * 5));
                // Boolean traits - higher mutation for dramatic variation
                dna.hasCracks = (random() < wildMutationChance) ? (random() < 0.4) :
                                (random() < (1 - detailMutationRate) ? parentDNA.hasCracks : (random() < 0.4));
                dna.hasSpinalCord = (random() < wildMutationChance) ? (random() < 0.3) :
                                    (random() < (1 - detailMutationRate) ? parentDNA.hasSpinalCord : (random() < 0.3));
                dna.hasExtraRibs = (random() < wildMutationChance) ? (random() < 0.3) :
                                   (random() < (1 - bodyMutationRate) ? parentDNA.hasExtraRibs : (random() < 0.3));
                dna.hasHorns = (random() < wildMutationChance) ? (random() < 0.4) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasHorns : (random() < 0.4));
                dna.hasTeeth = (random() < wildMutationChance) ? (random() < 0.7) :
                               (random() < (1 - facialMutationRate) ? parentDNA.hasTeeth : (random() < 0.7));
                dna.teethStyle = (random() < wildMutationChance) ? Math.floor(random() * 4) :
                                 (random() < (1 - facialMutationRate) ? parentDNA.teethStyle : Math.floor(random() * 4));
                dna.boneThickness = (random() < wildMutationChance) ? Math.floor(random() * 3) :
                                    (random() < (1 - bodyMutationRate) ? parentDNA.boneThickness : Math.floor(random() * 3));
                dna.hasTail = (random() < wildMutationChance) ? (random() < 0.6) :
                              (random() < (1 - limbMutationRate) ? (parentDNA.hasTail !== false) : (random() < 0.6));
                dna.tailBoneCount = (random() < wildMutationChance) ? (Math.floor(random() * 3) + 3) :
                                    (random() < (1 - limbMutationRate) ? (parentDNA.tailBoneCount || 4) : (Math.floor(random() * 3) + 3));

                // Alien
                dna.alienHeadVariant = random() < (1 - bodyMutationRate) ? parentDNA.alienHeadVariant : Math.floor(random() * 2);
                dna.hasAntennae = random() < (1 - facialMutationRate) ? parentDNA.hasAntennae : (random() < 0.7);
                dna.numTentacles = random() < (1 - limbMutationRate) ? parentDNA.numTentacles : (Math.floor(random() * 2) + 3);

                // Aquatic
                dna.hasDorsalFin = random() < (1 - bodyMutationRate) ? parentDNA.hasDorsalFin : (random() < 0.7);
                dna.tailShape = random() < (1 - limbMutationRate) ? parentDNA.tailShape : Math.floor(random() * 3);
                dna.numGills = random() < (1 - facialMutationRate) ? parentDNA.numGills : (Math.floor(random() * 2) + 2);

                // ‚ïê‚ïê‚ïê SPONTANEOUS MUTATIONS - Random features that can appear completely randomly! ‚ïê‚ïê‚ïê
                // These override inherited traits to create truly surprising variations
                const spontaneousMutationChance = 0.20; // 20% chance for each trait to spontaneously mutate

                if (random() < spontaneousMutationChance) {
                    // Spontaneous body texture change
                    dna.bodyTextureIdx = Math.floor(random() * 18);
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous number of eyes change
                    dna.numEyes = Math.floor(random() * 4) + 2;
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous mouth style change
                    dna.mouthStyleIdx = Math.floor(random() * 19);
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous arm/leg count change
                    dna.numArms = Math.floor(random() * 3) + 2;
                    dna.numLegs = Math.floor(random() * 3) + 2;
                }
                if (random() < spontaneousMutationChance) {
                    // Spontaneous head variant change
                    dna.headVariant = Math.floor(random() * 7);
                }
                // Random trait additions
                if (random() < 0.15) dna.hasTeeth = !dna.hasTeeth; // 15% flip teeth
                if (random() < 0.15) dna.hasNose = !dna.hasNose;   // 15% flip nose
                if (random() < 0.15) dna.hasEyebrows = !dna.hasEyebrows; // 15% flip eyebrows
                if (random() < 0.15) dna.hasClaws = !dna.hasClaws; // 15% flip claws

                // ‚ïê‚ïê‚ïê ANIMATION INHERITANCE - 30% chance to mutate stage ‚ïê‚ïê‚ïê
                const stages = ['calm', 'nervous', 'adhd', 'crazy'];
                if (random() < 0.70) {
                    dna.animationStage = parentDNA.animationStage; // Inherit
                } else {
                    dna.animationStage = stages[Math.floor(random() * 4)]; // MUTATE!
                }

                // Apply speeds based on stage
                if (dna.animationStage === 'calm') {
                    dna.blinkSpeed = 7000 + Math.floor(random() * 5000);
                    dna.limbSpeed = 4000 + Math.floor(random() * 3000);
                    dna.antennaSpeed = 3500 + Math.floor(random() * 2500);
                } else if (dna.animationStage === 'nervous') {
                    dna.blinkSpeed = 2000 + Math.floor(random() * 2000);
                    dna.limbSpeed = 1000 + Math.floor(random() * 1000);
                    dna.antennaSpeed = 800 + Math.floor(random() * 700);
                } else if (dna.animationStage === 'adhd') {
                    dna.blinkSpeed = 500 + Math.floor(random() * 700);
                    dna.limbSpeed = 250 + Math.floor(random() * 350);
                    dna.antennaSpeed = 200 + Math.floor(random() * 300);
                } else { // crazy
                    dna.blinkSpeed = 100 + Math.floor(random() * 200);
                    dna.limbSpeed = 80 + Math.floor(random() * 120);
                    dna.antennaSpeed = 60 + Math.floor(random() * 90);
                }

                dna.blinkDelay = Math.floor(random() * 2000);
                dna.limbDelay = Math.floor(random() * 1000);
                dna.antennaDelay = Math.floor(random() * 800);

            } else {
                // SPREADER: Generate random DNA with SPECIES + ALL VARIATIONS
                const speciesTypes = ['insectoid', 'reptilian', 'mammalian', 'viral', 'alien', 'aquatic', 'skeletal'];
                dna.species = speciesTypes[Math.floor(random() * speciesTypes.length)];

                // OLD ATTRIBUTES (kept for compatibility)
                const bodyChars = ['‚ñà', '‚ñì', '‚ñí', '‚ñë'];
                const eyeChars = ['‚óè', '‚óâ', '‚óé', '‚óã'];
                const antennaTips = ['‚óè', '‚óâ', '‚óã', '‚óé', '‚ú¶', '‚úß', '‚òÖ'];
                const armStyles = ['block', 'line'];
                const legStyles = ['block', 'line'];
                const hatTypes = ['none', 'none', 'none', 'top', 'flat', 'double', 'fancy'];

                dna.bodyChar = bodyChars[Math.floor(random() * bodyChars.length)];
                dna.eyeChar = eyeChars[Math.floor(random() * eyeChars.length)];
                dna.eyeSize = random() > 0.7 ? 'mega' : 'normal';
                dna.antennaTip = antennaTips[Math.floor(random() * antennaTips.length)];
                dna.armStyle = armStyles[Math.floor(random() * armStyles.length)];
                dna.legStyle = legStyles[Math.floor(random() * legStyles.length)];
                dna.hatType = hatTypes[Math.floor(random() * hatTypes.length)];
                dna.hasCigarette = random() < 0.10;

                // ‚ïê‚ïê‚ïê NEW: COMPREHENSIVE VARIATION DNA (seed-deterministic) ‚ïê‚ïê‚ïê
                // Store ALL visual choices in DNA so different seeds = different appearance

                // EYES
                dna.numEyes = Math.floor(random() * 4) + 2; // 2-5
                dna.eyeStyleIdx = Math.floor(random() * 18); // 18 eye styles
                dna.pupilStyleIdx = Math.floor(random() * 9); // 9 pupil styles
                dna.hasPupils = random() < 0.7;
                dna.eyebrowStyleIdx = Math.floor(random() * 7);
                dna.hasEyebrows = random() < 0.4;

                // MOUTH
                dna.mouthStyleIdx = Math.floor(random() * 19); // 19 mouth styles
                dna.teethStyleIdx = Math.floor(random() * 12);
                dna.hasTeeth = random() < 0.5;

                // NOSE
                dna.noseStyleIdx = Math.floor(random() * 15);
                dna.hasNose = random() < 0.3;

                // BODY
                dna.headVariant = Math.floor(random() * 7);
                dna.bodyTextureIdx = Math.floor(random() * 18);
                dna.bellyMarkIdx = Math.floor(random() * 8);

                // LIMBS
                dna.armStyleIdx = Math.floor(random() * 12); // 12 arm styles
                dna.legStyleIdx = Math.floor(random() * 11); // 11 leg styles
                dna.numArms = Math.floor(random() * 3) + 2; // 2-4
                dna.numLegs = Math.floor(random() * 3) + 2; // 2-4
                dna.hasClaws = random() < 0.6;
                dna.hasToes = random() < 0.5;

                // DETAILS
                dna.faceMarkIdx = Math.floor(random() * 9);
                dna.hasSpots = random() < 0.6;
                dna.scarMarkIdx = Math.floor(random() * 6);
                dna.hasScars = random() < 0.2;

                // SPECIES-SPECIFIC
                // Insectoid - EXPANDED TRAITS
                dna.antennaLength = Math.floor(random() * 3) + 2; // 2-4
                dna.segmentWidth = Math.floor(random() * 2); // narrow or wide
                dna.hasWings = random() < 0.5;
                dna.wingCharIdx = Math.floor(random() * 6);
                dna.mandibleStyleIdx = Math.floor(random() * 4);
                dna.hasAntennae = random() < 0.9; // Most have antennae
                dna.legCount = Math.floor(random() * 2) + 3; // 3-4 pairs (6-8 legs)
                dna.hasStingers = random() < 0.3; // Tail stingers

                // Reptilian - EXPANDED TRAITS
                dna.hasTongue = random() < 0.7;
                dna.hasSpines = random() < 0.6;
                dna.tailStyle = Math.floor(random() * 3); // 0=serpentine, 1=spiked, 2=club
                dna.bodyHeightVariant = Math.floor(random() * 2); // Variable height
                dna.hasHorns = random() < 0.4; // Head horns/crests
                dna.hasFrill = random() < 0.3; // Neck frill
                dna.spineCount = Math.floor(random() * 3) + 2; // 2-4 dorsal spines
                dna.scaleSize = Math.floor(random() * 3); // 0=small, 1=medium, 2=large

                // Mammalian
                dna.earStyle = Math.floor(random() * 3); // 0=pointy, 1=round, 2=floppy
                dna.hasTail = random() < 0.8;
                dna.hasWhiskers = random() < 0.7;

                // Skeletal - MASSIVELY EXPANDED VARIETY
                dna.jawStyle = Math.floor(random() * 5); // 0-4 jaw types
                dna.ribCount = Math.floor(random() * 4) + 2; // 2-5 ribs per side
                dna.ribStyle = Math.floor(random() * 5); // 0-4 rib styles
                dna.spineStyle = Math.floor(random() * 5); // 0-4 spine styles
                dna.spineHeightVariant = Math.floor(random() * 4); // 0-3 height variants
                dna.skullShape = Math.floor(random() * 5); // 0-4 skull shapes
                dna.eyeSocketStyle = Math.floor(random() * 6); // 0-5 socket shapes
                dna.nasalStyle = Math.floor(random() * 5); // 0-4 nasal styles
                dna.armBoneStyle = Math.floor(random() * 5); // 0-4 arm styles
                dna.legBoneStyle = Math.floor(random() * 5); // 0-4 leg styles
                dna.jointStyle = Math.floor(random() * 5); // 0-4 joint styles
                dna.fingerStyle = Math.floor(random() * 6); // 0-5 finger patterns
                dna.footStyle = Math.floor(random() * 5); // 0-4 foot shapes
                dna.hasCracks = random() < 0.4; // Random bone cracks/damage
                dna.hasSpinalCord = random() < 0.3; // Internal spinal cord visible
                dna.hasExtraRibs = random() < 0.3; // Extra rib pairs
                dna.hasHorns = random() < 0.4; // Skull horns/protrusions
                dna.hasTeeth = random() < 0.7; // Teeth in skull
                dna.teethStyle = Math.floor(random() * 4); // Tooth patterns
                dna.boneThickness = Math.floor(random() * 3); // 0=thin, 1=normal, 2=thick
                dna.hasTail = random() < 0.6; // Skeletal tail
                dna.tailBoneCount = Math.floor(random() * 3) + 3; // 3-5 tail vertebrae

                // Alien
                dna.alienHeadVariant = Math.floor(random() * 2); // 0=huge, 1=medium
                dna.hasAntennae = random() < 0.7;
                dna.numTentacles = Math.floor(random() * 2) + 3; // 3-4 legs

                // Aquatic
                dna.hasDorsalFin = random() < 0.7;
                dna.tailShape = Math.floor(random() * 3); // 0=fan, 1=forked, 2=round
                dna.numGills = Math.floor(random() * 2) + 2; // 2-3 gill slits

                // ‚ïê‚ïê‚ïê ANIMATION PERSONALITY STAGES ‚ïê‚ïê‚ïê
                const stages = ['calm', 'nervous', 'adhd', 'crazy'];
                dna.animationStage = stages[Math.floor(random() * 4)];

                // Set speeds based on stage - MORE EXTREME
                if (dna.animationStage === 'calm') {
                    dna.blinkSpeed = 7000 + Math.floor(random() * 5000);     // 7-12 seconds
                    dna.limbSpeed = 4000 + Math.floor(random() * 3000);      // 4-7 seconds
                    dna.antennaSpeed = 3500 + Math.floor(random() * 2500);   // 3.5-6 seconds
                } else if (dna.animationStage === 'nervous') {
                    dna.blinkSpeed = 2000 + Math.floor(random() * 2000);     // 2-4 seconds
                    dna.limbSpeed = 1000 + Math.floor(random() * 1000);      // 1-2 seconds
                    dna.antennaSpeed = 800 + Math.floor(random() * 700);     // 0.8-1.5 seconds
                } else if (dna.animationStage === 'adhd') {
                    dna.blinkSpeed = 500 + Math.floor(random() * 700);       // 0.5-1.2 seconds
                    dna.limbSpeed = 250 + Math.floor(random() * 350);        // 0.25-0.6 seconds
                    dna.antennaSpeed = 200 + Math.floor(random() * 300);     // 0.2-0.5 seconds
                } else { // crazy
                    dna.blinkSpeed = 100 + Math.floor(random() * 200);       // 0.1-0.3 seconds
                    dna.limbSpeed = 80 + Math.floor(random() * 120);         // 0.08-0.2 seconds
                    dna.antennaSpeed = 60 + Math.floor(random() * 90);       // 0.06-0.15 seconds
                }

                dna.blinkDelay = Math.floor(random() * 2000);
                dna.limbDelay = Math.floor(random() * 1000);
                dna.antennaDelay = Math.floor(random() * 800);
            }

            // Create grid
            const grid = Array(size).fill().map(() => Array(size).fill(' '));

            // Center coordinates
            const cx = Math.floor(size / 2);
            const cy = Math.floor(size / 2);

            // BODY TYPE - Inherited or random
            let bodyType;
            if (parentDNA && parentDNA.bodyType) {
                // CHILD: 100% inherit parent's body type
                bodyType = parentDNA.bodyType;
            } else {
                // SPREADER: Random body type
                const bodyTypes = isChild ?
                    ['square', 'round', 'diamond', 'mushroom'] :
                    ['square', 'round', 'invader', 'mushroom', 'ghost', 'diamond'];
                const bodyTypeIndex = Math.floor(random() * bodyTypes.length);
                bodyType = bodyTypes[bodyTypeIndex];
                dna.bodyType = bodyType; // Store in DNA
            }

            const bodyWidth = size === 24 ? 6 : 3;
            const bodyHeight = size === 24 ? 8 : 4;
            const bodyStartY = size === 24 ? 7 : 6;

            // Draw OUTLINED body using box-drawing characters
            // First pass: mark interior cells
            const bodyInterior = Array(size).fill().map(() => Array(size).fill(false));

            for (let y = 0; y < bodyHeight; y++) {
                for (let x = -bodyWidth; x <= bodyWidth; x++) {
                    const posY = bodyStartY + y;
                    const posX = cx + x;
                    const relX = x / bodyWidth;
                    const relY = (y - bodyHeight/2) / (bodyHeight/2);

                    let inBody = false;
                    switch(bodyType) {
                        case 'square':
                            inBody = true;
                            break;
                        case 'round':
                            inBody = Math.sqrt(relX*relX + relY*relY) <= 1.0;
                            break;
                        case 'diamond':
                            inBody = Math.abs(relX) + Math.abs(relY) <= 1.0;
                            break;
                        case 'mushroom':
                            if (isChild) {
                                inBody = relY < -0.2 ? true : Math.abs(relX) <= 0.7;
                            } else {
                                inBody = relY < 0 ? true : Math.abs(relX) <= 0.6;
                            }
                            break;
                        case 'invader':
                            if (relY < -0.3) inBody = Math.abs(relX) <= 0.7;
                            else if (relY < 0.3) inBody = true;
                            else inBody = Math.abs(relX) <= 0.85;
                            break;
                        case 'ghost':
                            if (relY < 0.5) inBody = Math.sqrt(relX*relX + relY*relY) <= 1.0;
                            else inBody = Math.abs(relX) <= 0.9 && (Math.floor(x + bodyWidth) % 2 === 0 || relY < 0.8);
                            break;
                    }

                    if (inBody && posX >= 0 && posX < size && posY >= 0 && posY < size) {
                        bodyInterior[posY][posX] = true;
                    }
                }
            }

            // Second pass: draw outlines only (edges of interior)
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (bodyInterior[y][x]) {
                        const isTop = y === 0 || !bodyInterior[y-1][x];
                        const isBottom = y === size-1 || !bodyInterior[y+1][x];
                        const isLeft = x === 0 || !bodyInterior[y][x-1];
                        const isRight = x === size-1 || !bodyInterior[y][x+1];

                        // Draw box-drawing characters for edges
                        if (isTop && isLeft) grid[y][x] = '‚îå';
                        else if (isTop && isRight) grid[y][x] = '‚îê';
                        else if (isBottom && isLeft) grid[y][x] = '‚îî';
                        else if (isBottom && isRight) grid[y][x] = '‚îò';
                        else if (isTop || isBottom) grid[y][x] = '‚îÄ';
                        else if (isLeft || isRight) grid[y][x] = '‚îÇ';
                        else grid[y][x] = ' '; // Interior is hollow
                    }
                }
            }

            // Helper to check if cell is part of body structure
            const isBodyChar = (char) => ['‚îå', '‚îê', '‚îî', '‚îò', '‚îÄ', '‚îÇ', '‚ïî', '‚ïó', '‚ïö', '‚ïù', '‚ïê', '‚ïë'].includes(char);

            // EYES - ALWAYS PRESENT (using DNA eye character and size)
            const eyeY = bodyStartY + 1;
            const hasMegaEyes = dna.eyeSize === 'mega';

            if (isChild) {
                // CHILDREN - Always have 1-3 eyes, bigger and more visible
                const eyeCount = 1 + Math.floor(random() * 3);

                if (eyeCount === 1) {
                    // Single cyclops eye
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            grid[eyeY + dy][cx + dx] = ' ';
                        }
                    }
                    grid[eyeY][cx] = dna.eyeChar;
                } else if (eyeCount === 2) {
                    // Two eyes
                    const eyeSpacing = 1;
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = -1; dx <= 0; dx++) {
                            grid[eyeY + dy][cx - eyeSpacing + dx] = ' ';
                            grid[eyeY + dy][cx + eyeSpacing + dx] = ' ';
                        }
                    }
                    grid[eyeY][cx - eyeSpacing] = dna.eyeChar;
                    grid[eyeY][cx + eyeSpacing] = dna.eyeChar;
                } else {
                    // Three eyes
                    for (let dx of [-2, 0, 2]) {
                        grid[eyeY][cx + dx] = dna.eyeChar;
                    }
                }
            } else {
                // SPREADERS - Always have BIG eyes (1-3 eyes, always prominent)
                const eyeCount = 1 + Math.floor(random() * 3); // 1, 2, or 3 eyes

                if (eyeCount === 1) {
                    // Giant cyclops eye
                    for (let dy = 0; dy < 3; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            grid[eyeY + dy][cx + dx] = ' ';
                        }
                    }
                    grid[eyeY + 1][cx - 1] = dna.eyeChar;
                    grid[eyeY + 1][cx] = dna.eyeChar;
                    grid[eyeY + 1][cx + 1] = dna.eyeChar;
                } else if (eyeCount === 2) {
                    // Two BIG eyes
                    const blockSpacing = 2;
                    for (let dy = 0; dy < 3; dy++) {
                        for (let dx = 0; dx < 3; dx++) {
                            grid[eyeY + dy][cx - blockSpacing - 2 + dx] = ' ';
                            grid[eyeY + dy][cx + blockSpacing + dx] = ' ';
                        }
                    }
                    grid[eyeY + 1][cx - blockSpacing - 1] = dna.eyeChar;
                    grid[eyeY + 1][cx + blockSpacing + 1] = dna.eyeChar;
                } else {
                    // Three eyes
                    for (let i of [-3, 0, 3]) {
                        grid[eyeY + 1][cx + i] = dna.eyeChar;
                    }
                }
            }

            // EYEBROWS - Above eyes (NEW)
            const browY = eyeY - 1;
            if (browY >= 0 && random() > 0.5) {
                const browChars = ['¬Ø', '‚Äæ', '‚ÅÄ', '‚å¢', '‚å£', '‚Äø', '‚Åî'];
                const browStyle = Math.floor(random() * 3);

                if (browStyle === 0) {
                    // Straight brows
                    if (grid[browY][cx - 1] === ' ') grid[browY][cx - 1] = '¬Ø';
                    if (grid[browY][cx] === ' ') grid[browY][cx] = '¬Ø';
                    if (grid[browY][cx + 1] === ' ') grid[browY][cx + 1] = '¬Ø';
                } else if (browStyle === 1) {
                    // Angry brows
                    if (grid[browY][cx - 2] === ' ') grid[browY][cx - 2] = '\\';
                    if (grid[browY][cx + 2] === ' ') grid[browY][cx + 2] = '/';
                } else {
                    // Curved brows
                    const brow = browChars[Math.floor(random() * browChars.length)];
                    if (grid[browY][cx - 1] === ' ') grid[browY][cx - 1] = brow;
                    if (grid[browY][cx + 1] === ' ') grid[browY][cx + 1] = brow;
                }
            }

            // EARS - Side projections (NEW)
            if (random() > 0.6) {
                const earY = eyeY;
                const earChars = [')', '(', '>', '<', '‚ü©', '‚ü®', 'D', 'C'];

                // Find body edges at ear level
                let leftEar = cx, rightEar = cx;
                for (let x = cx; x >= 0; x--) {
                    if (isBodyChar(grid[earY][x])) leftEar = x;
                    else break;
                }
                for (let x = cx; x < size; x++) {
                    if (isBodyChar(grid[earY][x])) rightEar = x;
                    else break;
                }

                // Add ears outside body
                if (leftEar - 1 >= 0 && grid[earY][leftEar - 1] === ' ') {
                    grid[earY][leftEar - 1] = earChars[Math.floor(random() * earChars.length)];
                }
                if (rightEar + 1 < size && grid[earY][rightEar + 1] === ' ') {
                    grid[earY][rightEar + 1] = earChars[Math.floor(random() * earChars.length)];
                }
            }

            // NOSE - Add above mouth (NEW)
            const noseY = eyeY + (isChild ? 1 : 2);
            if (random() > 0.4 && noseY < size && grid[noseY][cx] === ' ') {
                const noseChars = ['v', 'V', '‚à®', ' å', '‚ñ≥', '‚ñΩ'];
                grid[noseY][cx] = noseChars[Math.floor(random() * noseChars.length)];
            }

            // MOUTH - More detailed with teeth
            if (random() > 0.2) {
                const mouthY = eyeY + (isChild ? 2 : 3);
                if (mouthY < size) {
                    const mouthStyle = Math.floor(random() * 4);

                    if (mouthStyle === 0) {
                        // Simple line mouth
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = '‚îÄ';
                        if (random() > 0.5 && grid[mouthY][cx - 1] === ' ') grid[mouthY][cx - 1] = '‚îÄ';
                        if (random() > 0.5 && grid[mouthY][cx + 1] === ' ') grid[mouthY][cx + 1] = '‚îÄ';
                    } else if (mouthStyle === 1) {
                        // Teeth mouth
                        const teethChars = ['‚à©', '‚à™', 'w', 'W', 'm', 'M'];
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = teethChars[Math.floor(random() * teethChars.length)];
                    } else if (mouthStyle === 2) {
                        // Fangs
                        if (grid[mouthY][cx - 1] === ' ') grid[mouthY][cx - 1] = 'v';
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = '‚îÄ';
                        if (grid[mouthY][cx + 1] === ' ') grid[mouthY][cx + 1] = 'v';
                    } else {
                        // Open mouth with tongue
                        if (grid[mouthY][cx] === ' ') grid[mouthY][cx] = 'o';
                        if (mouthY + 1 < size && grid[mouthY + 1][cx] === ' ') grid[mouthY + 1][cx] = 'U';
                    }
                }
            }

            // CIGARETTE
            if (dna.hasCigarette) {
                const cigY = eyeY + (isChild ? 2 : 3);
                const cigChars = ['‚âà', '‚àº', '~'];
                const cigChar = cigChars[Math.floor(random() * cigChars.length)];
                const cigX = cx + (random() > 0.5 ? (isChild ? 3 : 4) : (isChild ? -3 : -4));
                if (cigX >= 0 && cigX < size && cigY >= 0 && cigY < size) {
                    grid[cigY][cigX] = cigChar;
                    if (cigX + 1 < size && cigX + 1 >= 0) {
                        grid[cigY][cigX + 1] = '‚àô';
                    }
                }
            }

            // INTERNAL DETAILS - Skeleton, organs, patterns (NEW)
            const detailStartY = bodyStartY + (isChild ? 1 : 2);
            const detailEndY = bodyStartY + bodyHeight - (isChild ? 1 : 2);
            const detailStyle = Math.floor(random() * 5);

            if (detailStyle === 0) {
                // Spine/vertebrae down center
                for (let y = detailStartY; y < detailEndY; y++) {
                    if (grid[y][cx] === ' ') {
                        grid[y][cx] = Math.floor(random() * 2) === 0 ? '|' : '‚îÇ';
                    }
                }
            } else if (detailStyle === 1) {
                // Ribcage pattern
                const ribY1 = detailStartY + 1;
                const ribY2 = detailStartY + 2;
                const ribY3 = detailStartY + 3;
                if (ribY1 < size) {
                    if (grid[ribY1][cx - 1] === ' ') grid[ribY1][cx - 1] = '(';
                    if (grid[ribY1][cx + 1] === ' ') grid[ribY1][cx + 1] = ')';
                }
                if (ribY2 < size) {
                    if (grid[ribY2][cx - 1] === ' ') grid[ribY2][cx - 1] = '(';
                    if (grid[ribY2][cx + 1] === ' ') grid[ribY2][cx + 1] = ')';
                }
                if (!isChild && ribY3 < size) {
                    if (grid[ribY3][cx - 1] === ' ') grid[ribY3][cx - 1] = '(';
                    if (grid[ribY3][cx + 1] === ' ') grid[ribY3][cx + 1] = ')';
                }
            } else if (detailStyle === 2) {
                // Internal organs (dots/circles)
                const organChars = ['‚óè', '‚óâ', '‚óã', '‚óé', '‚äô', '‚óå', '‚àò'];
                const organCount = isChild ? 2 : 4;
                for (let i = 0; i < organCount; i++) {
                    const orgX = cx + Math.floor((random() - 0.5) * (isChild ? 2 : 4));
                    const orgY = detailStartY + Math.floor(random() * (detailEndY - detailStartY));
                    if (orgX >= 0 && orgX < size && orgY >= 0 && orgY < size && grid[orgY][orgX] === ' ') {
                        grid[orgY][orgX] = organChars[Math.floor(random() * organChars.length)];
                    }
                }
            } else if (detailStyle === 3) {
                // Cross-hatch pattern
                for (let y = detailStartY; y < detailEndY; y += 2) {
                    for (let x = -1; x <= 1; x += 2) {
                        if (grid[y][cx + x] === ' ') {
                            grid[y][cx + x] = Math.floor(random() * 2) === 0 ? '/' : '\\';
                        }
                    }
                }
            } else {
                // Cellular/virus pattern
                const cellChars = ['‚ó¶', '¬∑', '‚Ä¢', '‚àô', '‚óò', '‚óô'];
                const cellCount = isChild ? 3 : 6;
                for (let i = 0; i < cellCount; i++) {
                    const cellX = cx + Math.floor((random() - 0.5) * (isChild ? 3 : 5));
                    const cellY = detailStartY + Math.floor(random() * (detailEndY - detailStartY));
                    if (cellX >= 0 && cellX < size && cellY >= 0 && cellY < size && grid[cellY][cellX] === ' ') {
                        grid[cellY][cellX] = cellChars[Math.floor(random() * cellChars.length)];
                    }
                }
            }

            // ARMS - ALWAYS PRESENT with detailed hands/claws
            const armCount = 1 + Math.floor(random() * 4);
            const armLength = isChild ? (1 + Math.floor(random() * 2)) : (2 + Math.floor(random() * 4));
            const armStyle = dna.armStyle;
            const hasClaws = random() > 0.5;

            for (let a = 0; a < armCount; a++) {
                const currentArmY = bodyStartY + 2 + a * (isChild ? 1 : 2);
                if (currentArmY >= bodyStartY + bodyHeight) break;

                let leftBodyEdge = cx;
                let rightBodyEdge = cx;

                for (let x = cx; x >= 0; x--) {
                    if (isBodyChar(grid[currentArmY][x])) {
                        leftBodyEdge = x;
                    } else {
                        break;
                    }
                }

                for (let x = cx; x < size; x++) {
                    if (isBodyChar(grid[currentArmY][x])) {
                        rightBodyEdge = x;
                    } else {
                        break;
                    }
                }

                const armChar = armStyle === 'block' ? '‚ñà' : '‚îÄ';

                // Draw arms
                for (let i = 1; i <= armLength; i++) {
                    if (leftBodyEdge - i >= 0) {
                        grid[currentArmY][leftBodyEdge - i] = armChar;
                    }
                    if (rightBodyEdge + i < size) {
                        grid[currentArmY][rightBodyEdge + i] = armChar;
                    }
                }

                // Add hands/claws at end of arms
                if (hasClaws) {
                    const clawChars = ['œà', 'Œ®', '‚ãî', '‚ãã', '‚ãå', ' É', '‚à´'];
                    const leftClawX = leftBodyEdge - armLength - 1;
                    const rightClawX = rightBodyEdge + armLength + 1;

                    if (leftClawX >= 0 && leftClawX < size) {
                        grid[currentArmY][leftClawX] = clawChars[Math.floor(random() * clawChars.length)];
                    }
                    if (rightClawX >= 0 && rightClawX < size) {
                        grid[currentArmY][rightClawX] = clawChars[Math.floor(random() * clawChars.length)];
                    }
                } else {
                    // Hands with fingers
                    const handChars = ['‚äÉ', '‚äÇ', 'Œµ', 'œ∂', '‚àà', '‚àã'];
                    const leftHandX = leftBodyEdge - armLength - 1;
                    const rightHandX = rightBodyEdge + armLength + 1;

                    if (leftHandX >= 0 && leftHandX < size) {
                        grid[currentArmY][leftHandX] = handChars[Math.floor(random() * handChars.length)];
                    }
                    if (rightHandX >= 0 && rightHandX < size) {
                        grid[currentArmY][rightHandX] = handChars[Math.floor(random() * handChars.length)];
                    }
                }
            }

            // LEGS - ALWAYS PRESENT, using DNA leg style
            const legCount = 1 + Math.floor(random() * 4);
            const legY = bodyStartY + bodyHeight;
            const legLength = isChild ? (1 + Math.floor(random() * 2)) : (2 + Math.floor(random() * 3));
            const legStyle = dna.legStyle;

            const bodyBottomPositions = [];
            for (let x = 0; x < size; x++) {
                if (grid[legY - 1] && isBodyChar(grid[legY - 1][x])) {
                    bodyBottomPositions.push(x);
                }
            }

            const legPositions = [];
            if (bodyBottomPositions.length > 0) {
                if (legCount === 1) {
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length / 2)]);
                } else if (legCount === 2) {
                    const leftPos = Math.floor(bodyBottomPositions.length * 0.25);
                    const rightPos = Math.floor(bodyBottomPositions.length * 0.75);
                    legPositions.push(bodyBottomPositions[leftPos]);
                    legPositions.push(bodyBottomPositions[rightPos]);
                } else if (legCount === 3) {
                    legPositions.push(bodyBottomPositions[0]);
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length / 2)]);
                    legPositions.push(bodyBottomPositions[bodyBottomPositions.length - 1]);
                } else {
                    legPositions.push(bodyBottomPositions[0]);
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length * 0.33)]);
                    legPositions.push(bodyBottomPositions[Math.floor(bodyBottomPositions.length * 0.66)]);
                    legPositions.push(bodyBottomPositions[bodyBottomPositions.length - 1]);
                }
            }

            const legChar = legStyle === 'block' ? '‚ñà' : '‚îÇ';
            const hasFeet = random() > 0.4;

            for (let legX of legPositions) {
                if (legX >= 0 && legX < size) {
                    // Draw leg
                    for (let i = 0; i < legLength; i++) {
                        if (legY + i < size) {
                            grid[legY + i][legX] = legChar;
                        }
                    }

                    // Add feet/claws at end of legs
                    const footY = legY + legLength;
                    if (hasFeet && footY < size) {
                        if (random() > 0.5) {
                            // Clawed feet
                            const footChars = [' å', '^', '‚àß', '‚äì', '…Ö', ' å'];
                            grid[footY][legX] = footChars[Math.floor(random() * footChars.length)];
                        } else {
                            // Flat feet/pads
                            const padChars = ['_', '‚ä•', '‚î¥', '‚ä¢', '‚ä£'];
                            grid[footY][legX] = padChars[Math.floor(random() * padChars.length)];
                        }
                    }
                }
            }

            // ANTENNAS - ALWAYS PRESENT, using DNA antenna tip
            const antennaCount = 1 + Math.floor(random() * 4);
            const antennaLength = isChild ? 1 : (1 + Math.floor(random() * 2));

            const bodyTopPositions = [];
            for (let x = 0; x < size; x++) {
                if (grid[bodyStartY] && isBodyChar(grid[bodyStartY][x])) {
                    bodyTopPositions.push(x);
                }
            }

            const antennaPositions = [];
            if (bodyTopPositions.length > 0) {
                if (antennaCount === 1) {
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length / 2)]);
                } else if (antennaCount === 2) {
                    const leftPos = Math.floor(bodyTopPositions.length * 0.25);
                    const rightPos = Math.floor(bodyTopPositions.length * 0.75);
                    antennaPositions.push(bodyTopPositions[leftPos]);
                    antennaPositions.push(bodyTopPositions[rightPos]);
                } else if (antennaCount === 3) {
                    antennaPositions.push(bodyTopPositions[0]);
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length / 2)]);
                    antennaPositions.push(bodyTopPositions[bodyTopPositions.length - 1]);
                } else {
                    antennaPositions.push(bodyTopPositions[0]);
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length * 0.33)]);
                    antennaPositions.push(bodyTopPositions[Math.floor(bodyTopPositions.length * 0.66)]);
                    antennaPositions.push(bodyTopPositions[bodyTopPositions.length - 1]);
                }
            }

            for (let antennaX of antennaPositions) {
                for (let i = 1; i <= antennaLength; i++) {
                    const antennaY = bodyStartY - i;
                    if (antennaY >= 0) {
                        if (i === antennaLength) {
                            // Antenna tip - use DNA antenna tip
                            grid[antennaY][antennaX] = dna.antennaTip;
                        } else {
                            // Antenna stem
                            grid[antennaY][antennaX] = '‚îÇ';
                        }

                        // Add bulbs/nodes along antenna for spreaders
                        if (!isChild && i === Math.floor(antennaLength / 2) && random() > 0.5) {
                            const bulbChars = ['‚óã', '‚óØ', '‚óå', '‚äô', '‚äö'];
                            grid[antennaY][antennaX] = bulbChars[Math.floor(random() * bulbChars.length)];
                        }
                    }
                }
            }

            // HORNS/SPIKES on body sides (NEW)
            if (random() > 0.6 && !isChild) {
                const hornCount = 1 + Math.floor(random() * 3);
                const hornChars = ['>', '<', '‚ü©', '‚ü®', '„Äâ', '„Äà', '‚ä≥', '‚ä≤'];
                for (let h = 0; h < hornCount; h++) {
                    const hornY = bodyStartY + 2 + h * 2;
                    if (hornY < bodyStartY + bodyHeight) {
                        // Left horn
                        let leftEdge = cx;
                        for (let x = cx; x >= 0; x--) {
                            if (isBodyChar(grid[hornY][x])) leftEdge = x;
                            else break;
                        }
                        if (leftEdge - 1 >= 0 && grid[hornY][leftEdge - 1] === ' ') {
                            grid[hornY][leftEdge - 1] = hornChars[Math.floor(random() * hornChars.length)];
                        }

                        // Right horn
                        let rightEdge = cx;
                        for (let x = cx; x < size; x++) {
                            if (isBodyChar(grid[hornY][x])) rightEdge = x;
                            else break;
                        }
                        if (rightEdge + 1 < size && grid[hornY][rightEdge + 1] === ' ') {
                            grid[hornY][rightEdge + 1] = hornChars[Math.floor(random() * hornChars.length)];
                        }
                    }
                }
            }

            // TENTACLES - Alternative to some arms/legs (NEW)
            if (random() > 0.7) {
                const tentacleCount = 1 + Math.floor(random() * 3);
                const tentacleChars = ['~', '‚âà', '‚àº', '‚åá', '‚å¢', '‚å£'];

                for (let t = 0; t < tentacleCount; t++) {
                    const tentacleY = bodyStartY + bodyHeight + t;
                    if (tentacleY < size) {
                        const tentacleX = cx + Math.floor((random() - 0.5) * (bodyWidth * 2));
                        if (tentacleX >= 0 && tentacleX < size && grid[tentacleY][tentacleX] === ' ') {
                            grid[tentacleY][tentacleX] = tentacleChars[Math.floor(random() * tentacleChars.length)];

                            // Extend tentacle
                            if (tentacleY + 1 < size && grid[tentacleY + 1][tentacleX] === ' ') {
                                grid[tentacleY + 1][tentacleX] = tentacleChars[Math.floor(random() * tentacleChars.length)];
                            }
                        }
                    }
                }
            }

            // TAIL - Protruding from bottom (NEW)
            if (random() > 0.65 && !isChild) {
                const tailLength = 2 + Math.floor(random() * 3);
                const tailChars = ['/', '\\', '|', '‚îÇ', '‚ï±', '‚ï≤'];
                const tailStartY = bodyStartY + bodyHeight;
                const tailX = cx + (random() > 0.5 ? 1 : -1);

                for (let t = 0; t < tailLength; t++) {
                    const ty = tailStartY + t;
                    const tx = tailX + Math.floor((random() - 0.5) * 2);
                    if (ty < size && tx >= 0 && tx < size && grid[ty][tx] === ' ') {
                        grid[ty][tx] = tailChars[Math.floor(random() * tailChars.length)];
                    }
                }

                // Tail tip
                const tipY = tailStartY + tailLength;
                const tipX = tailX;
                if (tipY < size && tipX >= 0 && tipX < size && grid[tipY][tipX] === ' ') {
                    const tipChars = ['‚ñº', '‚ñΩ', '‚ó¢', '‚ó£', '‚ó§', '‚ó•'];
                    grid[tipY][tipX] = tipChars[Math.floor(random() * tipChars.length)];
                }
            }

            // HAT - Drawn above antennas (NEW)
            if (dna.hatType && dna.hatType !== 'none') {
                const hatY = bodyStartY - antennaLength - 1;
                if (hatY >= 0) {
                    switch(dna.hatType) {
                        case 'top':
                            // Top hat: ‚ñÄ
                            for (let dx = -2; dx <= 2; dx++) {
                                if (cx + dx >= 0 && cx + dx < size) {
                                    grid[hatY][cx + dx] = '‚ñÄ';
                                }
                            }
                            if (hatY + 1 < size) {
                                grid[hatY + 1][cx] = '‚ñà';
                            }
                            break;
                        case 'flat':
                            // Flat cap: ‚ïê‚ïê‚ïê
                            for (let dx = -2; dx <= 2; dx++) {
                                if (cx + dx >= 0 && cx + dx < size) {
                                    grid[hatY][cx + dx] = '‚ïê';
                                }
                            }
                            break;
                        case 'double':
                            // Double layer: ‚ñÑ‚ñÑ‚ñÑ
                            for (let dx = -2; dx <= 2; dx++) {
                                if (cx + dx >= 0 && cx + dx < size && hatY - 1 >= 0) {
                                    grid[hatY - 1][cx + dx] = '‚ñÄ';
                                    grid[hatY][cx + dx] = '‚ñÑ';
                                }
                            }
                            break;
                        case 'fancy':
                            // Fancy: ‚ïî‚ïê‚ïó
                            if (cx - 2 >= 0 && cx + 2 < size) {
                                grid[hatY][cx - 2] = '‚ïî';
                                grid[hatY][cx - 1] = '‚ïê';
                                grid[hatY][cx] = '‚ïê';
                                grid[hatY][cx + 1] = '‚ïê';
                                grid[hatY][cx + 2] = '‚ïó';
                            }
                            break;
                    }
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SPECIES-SPECIFIC BEAUTIFUL RENDERING
            // Clear grid and redraw with proper anatomical structures
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            // Clear the grid completely
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    grid[y][x] = ' ';
                }
            }

            const species = dna.species;

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // COMPREHENSIVE ASCII MARK LIBRARY - MAXIMUM DETAIL & VARIETY
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            // ARM STYLES (horizontal appendages) with CLAWS
            const ARM_STYLES = [
                { chars: ['‚îÄ', '‚îÄ', '‚îÄ'], tip: '‚ü©', claw: '‚òÜ' },
                { chars: ['/', '\\', '/', '\\'], tip: '\\', claw: '‚óä' },
                { chars: ['~', '~', '~'], tip: '‚âà', claw: '‚âã' },
                { chars: ['‚îÄ', '‚îÄ', '>'], tip: '', claw: '‚ñ∫' },
                { chars: ['‚ïê', '‚ïê', '‚ñ∫'], tip: '', claw: '‚ñ∂' },
                { chars: [')', ')', ')'], tip: '¬ª', claw: '‚ü©' },
                { chars: ['>', '‚îÄ', '‚îÄ'], tip: '‚îÄ', claw: '‚ïå' },
                { chars: ['‚ï±', '‚îÄ', '‚ï≤'], tip: '‚ï≤', claw: '‚óÄ' },
                { chars: ['~', '‚îÄ', '~'], tip: '~', claw: '‚àø' },
                { chars: ['‚Ä¢', '‚îÄ', '‚Ä¢'], tip: '‚óâ', claw: '‚óé' },
                { chars: ['=', '=', '='], tip: '‚â°', claw: '‚ñ£' },
                { chars: ['‚ïå', '‚ïå', '‚ïå'], tip: '‚ïç', claw: '‚ñ™' },
            ];

            // LEG STYLES (vertical appendages) with FEET/TOES
            const LEG_STYLES = [
                { chars: ['‚îÇ', '‚îÇ'], foot: '‚ä•', toe: 'w' },
                { chars: ['/', '\\'], foot: '‚ñº', toe: 'v' },
                { chars: ['‚ï±', '‚ï≤'], foot: '‚ï≤', toe: '‚ó¢' },
                { chars: ['‚îÉ', '‚îÉ'], foot: '‚ñÄ', toe: '‚ñ†' },
                { chars: [')', ')'], foot: 'U', toe: '‚à™' },
                { chars: ['‚îÇ', '‚ï±'], foot: '‚ï≤', toe: '‚ï±' },
                { chars: ['‚ï≤', '‚îÇ'], foot: '‚ñÑ', toe: '‚ñÄ' },
                { chars: ['‚îä', '‚îä'], foot: '¬∑', toe: '‚à¥' },
                { chars: ['‚ïë', '‚ïë'], foot: '‚ñ†', toe: '‚ñ™' },
                { chars: ['‚ñº', '‚îÇ'], foot: '‚ñº', toe: '‚ñΩ' },
                { chars: [')', '‚îÇ'], foot: '‚ï∞', toe: '‚ó°' },
            ];

            // EYES with PUPILS
            const EYE_STYLES = ['‚óè', '‚óâ', '‚óé', '‚óã', '‚óØ', '‚¨°', '‚ñ†', '‚óÜ', '‚ñ£', '‚äô', '‚óê', '‚óë', '‚óî', '‚óï', '‚äó', '‚äï', '‚óà', '‚óò'];
            const PUPIL_STYLES = ['¬∑', '‚Ä¢', '‚ñ™', '‚óã', '-', '|', '+', 'x', '‚ó¶'];
            const EYEBROW_STYLES = ['‚Äæ', '¬Ø', '‚åÉ', '‚ï≤‚ï±', '/', '\\', '^'];

            // MOUTHS with TEETH
            const MOUTH_STYLES = ['o', 'œâ', '‚ñΩ', '‚ñ≥', '‚óá', '‚ïê', '‚îÄ', '‚ï∞‚ïØ', '‚å¢', '‚å£', '‚à™', '‚à©', ' ñ', '‚ó°', '„Ä∞', 'v', 'V', 'w', 'W'];
            const TEETH_STYLES = ['v', 'V', 'w', 'W', 'vv', 'VV', '‚àß', '‚à®', '‚ñ≤', '‚ñº', ' å', 'vVv'];

            // NOSE/NOSTRIL
            const NOSE_STYLES = ['‚ñº', '‚ñΩ', 'v', 'V', '‚óá', '‚óä', ':', '‚à¥', '‚åÑ', '‚àß', ')', '(', '‚Ä¢', '‚ñ™', '¬∑¬∑'];

            // HORNS/CRESTS
            const HORN_STYLES = ['‚ñ≤', '‚ñ≥', '‚ñ¥', '‚ñµ', '‚üÅ', '‚ãÄ', '‚ó¨', '‚ó≠', '‚óÆ', '‚ï±', '‚ï≤', '‚äº', '‚äΩ', '‚àß', 'Œõ', '^'];

            // SPIKES/SPINES
            const SPINE_STYLES = ['‚ñ≤', '‚ñ¥', '‚ñ≥', '‚ãÄ', '^', 'Œõ', '‚àß', '‚äº', '‚óä', '‚óà', '‚Äª', '‚ñ¥‚ñ¥', '‚ñ≤‚ñ≤'];

            // BODY TEXTURES & PATTERNS
            const BODY_TEXTURES = ['‚ñì', '‚ñí', '‚ñë', '‚ñ™', '‚ñ´', '‚óá', '‚óÜ', '‚óä', '‚Ä¢', '¬∑', ':', '‚Äª', '‚ú¶', '‚úß', '‚óà', '‚óâ', '‚äó', '‚äô'];
            const SCALE_PATTERNS = ['‚óá', '‚óä', '‚óà', '‚óÜ', '‚ñ´', '‚ñ™', '‚ãÑ', '‚óá‚óä', '‚ñ´‚ñ™'];
            const FUR_PATTERNS = ['‚ñë', '‚ñí', '‚ñì', '‚à¥', '‚àµ', ':', '¬∑', ':::'];

            // ANTENNA/HORN TIPS
            const ANTENNA_TIPS = ['‚óè', '‚óâ', '‚óã', '‚óé', '‚ú¶', '‚úß', '‚òÖ', '‚òÜ', '‚ñ≤', '‚ñ≥', '‚óÜ', '‚óá', '‚Äª', '‚öù', '‚óà', '‚äô', '‚äï', '‚óò'];

            // TAIL STYLES with TIPS
            const TAIL_STYLES = [
                { chars: ['‚ï≤', '‚ï≤'], tip: '‚ñº', spikes: false },
                { chars: ['‚îÇ', '‚îÇ'], tip: '‚óè', spikes: false },
                { chars: ['‚ï±', '‚ï≤'], tip: '‚óÜ', spikes: true },
                { chars: ['~', '~'], tip: '‚âà', spikes: false },
                { chars: ['‚âà', '‚âà'], tip: '‚âã', spikes: false },
                { chars: ['S', 'S'], tip: '‚óã', spikes: false },
                { chars: [')', ')'], tip: '‚ü©', spikes: false },
                { chars: ['‚ï≤', '‚îÇ'], tip: '‚ô¶', spikes: true },
            ];

            // WING PATTERNS
            const WING_PATTERNS = [
                ['/', '/', '/'],
                ['‚ï±', '‚ï±', '‚ï±'],
                [')', ')', ')'],
                ['‚âà', '‚âà', '‚âà'],
                ['~', '~', '~'],
                ['‚ü©', '>', '>'],
            ];

            // FACIAL/BODY MARKINGS
            const FACE_MARKS = ['¬∑', '‚Ä¢', ':', '‚Äª', '‚óä', '‚óà', '‚ñ™', '‚ñ´', '‚ó¶'];
            const BELLY_MARKS = ['‚óá', '‚óä', '‚óà', '‚ñ´', '‚óã', '‚óØ', '‚ó¶', '‚àò'];
            const SCAR_MARKS = ['/', '\\', 'X', 'x', '‚ï±', '‚ï≤'];

            // Render based on species type
            if (species === 'insectoid') {
                // ‚ïê‚ïê‚ïê INSECTOID: 6-legged creatures with EXTREME variety ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA (NOT random during render!) ‚ïê‚ïê‚ïê
                const legStyleIdx = dna.legStyleIdx || 0;
                const legStyle = LEG_STYLES[legStyleIdx];
                const eyeStyle = EYE_STYLES[dna.eyeStyleIdx || 0];
                const antennaTip = ANTENNA_TIPS[dna.antennaTip || 0]; // fallback for old DNA
                const antennaLength = dna.antennaLength || 3;
                const bodyTexture = BODY_TEXTURES[dna.bodyTextureIdx || 0];
                const hasWings = dna.hasWings && !isChild;
                const wingChar = dna.wingCharIdx < 3 ? '/' : '‚ï±';
                const mandibleStyle = dna.mandibleStyleIdx || 0;
                const segmentWidth = dna.segmentWidth || 0;
                const hasAntennae = dna.hasAntennae !== false; // Default true
                const legCount = dna.legCount || 3; // Default 3 pairs (6 legs)
                const hasStingers = dna.hasStingers || false;

                const segH = isChild ? 2 : 3;
                const baseY = isChild ? 5 : 6;

                // HEAD segment (variable width)
                const headW = segmentWidth === 0 ? 2 : (isChild ? 2 : 3);
                if (baseY >= 0 && baseY < size) {
                    // Top of head with curves
                    if (cx - headW >= 0) grid[baseY][cx - headW] = '‚ï≠';
                    for (let x = cx - headW + 1; x < cx + headW; x++) {
                        if (x >= 0 && x < size) grid[baseY][x] = '‚îÄ';
                    }
                    if (cx + headW < size) grid[baseY][cx + headW] = '‚ïÆ';
                }
                // Head sides
                for (let y = baseY + 1; y < baseY + segH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - headW >= 0) grid[y][cx - headW] = '‚îÇ';
                        if (cx + headW < size) grid[y][cx + headW] = '‚îÇ';
                    }
                }
                // Bottom of head with curves
                if (baseY + segH - 1 >= 0 && baseY + segH - 1 < size) {
                    if (cx - headW >= 0) grid[baseY + segH - 1][cx - headW] = '‚ï∞';
                    for (let x = cx - headW + 1; x < cx + headW; x++) {
                        if (x >= 0 && x < size) grid[baseY + segH - 1][x] = '‚îÄ';
                    }
                    if (cx + headW < size) grid[baseY + segH - 1][cx + headW] = '‚ïØ';
                }

                // COMPOUND EYES (from library)
                if (baseY + 1 >= 0 && baseY + 1 < size) {
                    if (cx - 1 >= 0) grid[baseY + 1][cx - 1] = eyeStyle;
                    if (cx + 1 < size) grid[baseY + 1][cx + 1] = eyeStyle;
                }

                // BODY TEXTURE
                if (baseY + 1 >= 0 && baseY + 1 < size && cx >= 0 && cx < size) {
                    grid[baseY + 1][cx] = bodyTexture;
                }

                // THORAX segment (widest, rounded)
                const thoraxY = baseY + segH;
                const thoraxW = 3;
                if (thoraxY >= 0 && thoraxY < size) {
                    // Top of thorax with curves
                    if (cx - thoraxW >= 0) grid[thoraxY][cx - thoraxW] = '‚ï≠';
                    for (let x = cx - thoraxW + 1; x < cx + thoraxW; x++) {
                        if (x >= 0 && x < size) grid[thoraxY][x] = '‚îÄ';
                    }
                    if (cx + thoraxW < size) grid[thoraxY][cx + thoraxW] = '‚ïÆ';
                }
                // Thorax sides
                for (let y = thoraxY + 1; y < thoraxY + segH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - thoraxW >= 0) grid[y][cx - thoraxW] = '‚îÇ';
                        if (cx + thoraxW < size) grid[y][cx + thoraxW] = '‚îÇ';
                    }
                }
                // Bottom of thorax with curves
                if (thoraxY + segH - 1 >= 0 && thoraxY + segH - 1 < size) {
                    if (cx - thoraxW >= 0) grid[thoraxY + segH - 1][cx - thoraxW] = '‚ï∞';
                    for (let x = cx - thoraxW + 1; x < cx + thoraxW; x++) {
                        if (x >= 0 && x < size) grid[thoraxY + segH - 1][x] = '‚îÄ';
                    }
                    if (cx + thoraxW < size) grid[thoraxY + segH - 1][cx + thoraxW] = '‚ïØ';
                }

                // ABDOMEN segment (rounded)
                const abdomenY = thoraxY + segH;
                const abdomenW = 2;
                if (abdomenY >= 0 && abdomenY < size) {
                    // Top of abdomen with curves
                    if (cx - abdomenW >= 0) grid[abdomenY][cx - abdomenW] = '‚ï≠';
                    for (let x = cx - abdomenW + 1; x < cx + abdomenW; x++) {
                        if (x >= 0 && x < size) grid[abdomenY][x] = '‚îÄ';
                    }
                    if (cx + abdomenW < size) grid[abdomenY][cx + abdomenW] = '‚ïÆ';
                }
                // Abdomen sides
                for (let y = abdomenY + 1; y < abdomenY + segH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - abdomenW >= 0) grid[y][cx - abdomenW] = '‚îÇ';
                        if (cx + abdomenW < size) grid[y][cx + abdomenW] = '‚îÇ';
                    }
                }
                // Bottom of abdomen with curves
                if (abdomenY + segH - 1 >= 0 && abdomenY + segH - 1 < size) {
                    if (cx - abdomenW >= 0) grid[abdomenY + segH - 1][cx - abdomenW] = '‚ï∞';
                    for (let x = cx - abdomenW + 1; x < cx + abdomenW; x++) {
                        if (x >= 0 && x < size) grid[abdomenY + segH - 1][x] = '‚îÄ';
                    }
                    if (cx + abdomenW < size) grid[abdomenY + segH - 1][cx + abdomenW] = '‚ïØ';
                }

                // VARIABLE LEGS (3-4 pairs) - Using DNA legStyle
                // Use ARM_STYLES for insect leg patterns (they work well for horizontal limbs)
                const legPattern = ARM_STYLES[legStyleIdx % ARM_STYLES.length];

                for (let leg = 0; leg < legCount; leg++) {
                    const legY = thoraxY + 1 + leg;
                    if (legY >= 0 && legY < size) {
                        // Left legs using style patterns like /\/\ or -->
                        if (cx - 4 >= 0) grid[legY][cx - 4] = '‚ï≤';
                        for (let i = 0; i < legPattern.chars.length; i++) {
                            if (cx - 5 - i >= 0) {
                                grid[legY][cx - 5 - i] = legPattern.chars[i];
                            }
                        }
                        if (legPattern.tip && cx - 5 - legPattern.chars.length >= 0) {
                            grid[legY][cx - 5 - legPattern.chars.length] = legPattern.tip;
                        }

                        // Right legs (mirror)
                        if (cx + 4 < size) grid[legY][cx + 4] = '‚ï±';
                        for (let i = 0; i < legPattern.chars.length; i++) {
                            if (cx + 5 + i < size) {
                                const char = legPattern.chars[i];
                                // Mirror slashes
                                const mirrorChar = char === '/' ? '\\' : (char === '\\' ? '/' : char);
                                grid[legY][cx + 5 + i] = mirrorChar;
                            }
                        }
                        if (legPattern.tip && cx + 5 + legPattern.chars.length < size) {
                            const mirrorTip = legPattern.tip === '‚ü©' ? '‚ü®' : (legPattern.tip === '>' ? '<' : legPattern.tip);
                            grid[legY][cx + 5 + legPattern.chars.length] = mirrorTip;
                        }
                    }
                }

                // ANTENNAE (variable length and tip) - only if hasAntennae
                if (hasAntennae) {
                    for (let ant of [-1, 1]) {
                        const antX = cx + ant;
                        for (let i = 1; i <= antennaLength; i++) {
                            const antY = baseY - i;
                            if (antY >= 0 && antX >= 0 && antX < size) {
                                if (i === antennaLength) {
                                    grid[antY][antX] = antennaTip;
                                } else {
                                    grid[antY][antX] = '‚îÇ';
                                }
                            }
                        }
                    }
                }

                // MANDIBLES (4 different styles)
                const MANDIBLES = [
                    ['‚äè', '‚äê'],
                    ['<', '>'],
                    ['‚ï∞', '‚ïØ'],
                    ['(', ')']
                ];
                if (baseY + 2 >= 0 && baseY + 2 < size) {
                    const mand = MANDIBLES[mandibleStyle];
                    if (cx - 1 >= 0) grid[baseY + 2][cx - 1] = mand[0];
                    if (cx + 1 < size) grid[baseY + 2][cx + 1] = mand[1];
                }

                // WINGS (50% chance for adults)
                if (hasWings) {
                    for (let w = 0; w < 3; w++) {
                        const wingY = thoraxY + w + 1;
                        if (wingY >= 0 && wingY < size) {
                            if (cx - 4 >= 0) grid[wingY][cx - 4] = w === 0 ? '‚ï±' : '/';
                            if (cx + 4 < size) grid[wingY][cx + 4] = w === 0 ? '‚ï≤' : '\\';
                        }
                    }
                }

                // STINGER (tail stinger like wasp/scorpion)
                if (hasStingers && !isChild) {
                    const stingerY = abdomenY + segH;
                    const stingerLen = 3;
                    for (let i = 0; i < stingerLen; i++) {
                        const sy = stingerY + i;
                        if (sy >= 0 && sy < size && cx >= 0 && cx < size) {
                            if (i === stingerLen - 1) {
                                grid[sy][cx] = '‚ñº'; // Stinger tip
                            } else {
                                grid[sy][cx] = i % 2 === 0 ? '‚îÇ' : '‚îÉ';
                            }
                        }
                    }
                }

            } else if (species === 'reptilian') {
                // ‚ïê‚ïê‚ïê REPTILIAN: MASSIVELY EXPANDED DNA variations ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA ‚ïê‚ïê‚ïê
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const headVariant = dna.headVariant || 0;
                const armStyleIdx = dna.armStyleIdx || 0;
                const legStyleIdx = dna.legStyleIdx || 0;
                const numArms = dna.numArms || 2;
                const numLegs = dna.numLegs || 2;
                const hasTongue = dna.hasTongue;
                const hasSpines = dna.hasSpines && !isChild;
                const hasTeeth = dna.hasTeeth || false;
                const hasClaws = dna.hasClaws || true;
                const tailStyle = dna.tailStyle;
                const bellyMarkIdx = dna.bellyMarkIdx || 0;
                const hasHorns = dna.hasHorns || (random() < 0.4); // New trait
                const hasFrill = dna.hasFrill || (random() < 0.3); // New trait
                const spineCount = dna.spineCount || Math.floor(random() * 3) + 2; // New trait
                const scaleSize = dna.scaleSize || Math.floor(random() * 3); // New trait

                const headY = isChild ? 4 : 5;
                const bodyY = isChild ? 7 : 9;
                const bodyH = isChild ? (3 + dna.bodyHeightVariant) : (4 + dna.bodyHeightVariant);

                // VARIABLE HEAD SHAPES with horns/crests
                const headChar = headVariant % 3 === 0 ? '‚ñì' : (headVariant % 3 === 1 ? '‚ñà' : '‚ñí');
                for (let y = 0; y < 3; y++) {
                    const w = 3 - y;
                    for (let x = -w; x <= w; x++) {
                        if (headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            grid[headY + y][cx + x] = headChar;
                        }
                    }
                }

                // HORNS/CRESTS (variable styles)
                if (hasHorns && !isChild) {
                    const hornStyles = [
                        ['‚ñ≤', '‚ñ≤'], // dual horns
                        ['‚óÜ'], // single crest
                        ['‚àß', '‚àß'], // small horns
                        ['‚ô¶', '‚ô¶'], // diamond crests
                    ];
                    const hornStyle = hornStyles[headVariant % hornStyles.length];
                    if (hornStyle.length === 2) {
                        // Dual horns
                        if (headY - 1 >= 0 && headY - 1 < size) {
                            if (cx - 2 >= 0) grid[headY - 1][cx - 2] = hornStyle[0];
                            if (cx + 2 < size) grid[headY - 1][cx + 2] = hornStyle[1];
                        }
                    } else {
                        // Single crest
                        if (headY - 1 >= 0 && headY - 1 < size && cx >= 0 && cx < size) {
                            grid[headY - 1][cx] = hornStyle[0];
                        }
                    }
                }

                // NECK FRILL (like dinosaur frill)
                if (hasFrill && !isChild) {
                    if (headY + 2 >= 0 && headY + 2 < size) {
                        if (cx - 3 >= 0) grid[headY + 2][cx - 3] = '‚ó¢';
                        if (cx - 2 >= 0) grid[headY + 2][cx - 2] = '‚ñì';
                        if (cx + 2 < size) grid[headY + 2][cx + 2] = '‚ñì';
                        if (cx + 3 < size) grid[headY + 2][cx + 3] = '‚ó£';
                    }
                }

                // VARIABLE SLIT EYES (2-4 eyes with different styles)
                const eyeSlits = ['|', '‚Äñ', '‚îÇ', '‚ïë'];
                const eyeChar = eyeSlits[eyeStyleIdx % eyeSlits.length];

                if (numEyes === 2) {
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                    }
                } else if (numEyes >= 3) {
                    // Multiple eyes
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 2 >= 0) grid[headY + 1][cx - 2] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY + 1][cx] = eyeChar;
                        if (cx + 2 < size) grid[headY + 1][cx + 2] = eyeChar;
                        if (numEyes >= 4 && cx + 1 < size) grid[headY][cx + 1] = eyeChar;
                    }
                }

                // VARIABLE MOUTH/SNOUT with teeth
                const mouthStyles = ['Y', 'V', 'W', '„Äà„Äâ', '‚ñº', '‚à®', 'Œ®', '‚óä'];
                if (hasTongue && headY + 3 >= 0 && headY + 3 < size && cx >= 0 && cx < size) {
                    const mouth = mouthStyles[mouthStyleIdx % mouthStyles.length];
                    grid[headY + 3][cx] = mouth;
                }

                // TEETH (visible on sides of mouth)
                if (hasTeeth && headY + 2 >= 0 && headY + 2 < size) {
                    const teethChars = ['V', 'v', 'Œª', 'Œõ'];
                    const toothChar = teethChars[mouthStyleIdx % teethChars.length];
                    if (cx - 2 >= 0) grid[headY + 2][cx - 2] = toothChar;
                    if (cx + 2 < size) grid[headY + 2][cx + 2] = toothChar;
                    // Extra teeth for bigger mouths
                    if (!isChild) {
                        if (cx - 3 >= 0) grid[headY + 2][cx - 3] = toothChar;
                        if (cx + 3 < size) grid[headY + 2][cx + 3] = toothChar;
                    }
                }

                // VARIABLE SCALED BODY with multiple patterns and sizes
                const scalePatterns = [['‚óá', '‚óÜ'], ['‚ñΩ', '‚ñº'], ['‚óä', '‚óà'], ['‚ñø', '‚ñæ'], ['‚àá', '‚àÜ'], ['‚óã', '‚óè']];
                const [scale1, scale2] = scalePatterns[bodyTextureIdx % scalePatterns.length];

                // Scale size affects density
                const scaleChars = scaleSize === 0 ? ['¬∑', '‚àô'] : (scaleSize === 1 ? [scale1, scale2] : ['‚ñì', '‚ñí']);

                for (let y = 0; y < bodyH; y++) {
                    for (let x = -3; x <= 3; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (x === -3 || x === 3) {
                                grid[bodyY + y][cx + x] = '‚ñì'; // Body outline
                            } else if ((x + y) % 2 === 0) {
                                grid[bodyY + y][cx + x] = scaleChars[0];
                            } else {
                                grid[bodyY + y][cx + x] = scaleChars[1];
                            }
                        }
                    }
                }

                // DORSAL RIDGE/STRIPES (based on body texture)
                if (bodyTextureIdx % 3 === 0) {
                    // Add central ridge stripe
                    for (let y = 0; y < bodyH; y++) {
                        const ridgeY = bodyY + y;
                        if (ridgeY >= 0 && ridgeY < size && cx >= 0 && cx < size) {
                            grid[ridgeY][cx] = '‚ïë';
                        }
                    }
                }

                // SIDE STRIPES (tiger-like)
                if (bodyTextureIdx % 3 === 1) {
                    for (let y = 0; y < bodyH; y += 2) {
                        const stripeY = bodyY + y;
                        if (stripeY >= 0 && stripeY < size) {
                            if (cx - 2 >= 0) grid[stripeY][cx - 2] = '‚ñì';
                            if (cx + 2 < size) grid[stripeY][cx + 2] = '‚ñì';
                        }
                    }
                }

                // BELLY MARK
                const bellyMarks = ['‚óâ', '‚óè', '‚ñ£', '‚óÜ'];
                if (bellyMarkIdx < 3 && bodyH > 1) {
                    const markY = bodyY + Math.floor(bodyH / 2);
                    if (markY >= 0 && markY < size && cx >= 0 && cx < size) {
                        grid[markY][cx] = bellyMarks[bellyMarkIdx % bellyMarks.length];
                    }
                }

                // CLAWED ARMS with proper joints
                const armY = bodyY + 1;
                const armLen = isChild ? 2 : 3;
                if (armY >= 0 && armY < size) {
                    // Left arm: shoulder -> forearm -> claw
                    if (cx - 4 >= 0) grid[armY][cx - 4] = '‚ï±';
                    for (let i = 1; i <= armLen; i++) {
                        if (cx - 4 - i >= 0) grid[armY][cx - 4 - i] = '‚îÄ';
                    }
                    if (cx - 4 - armLen >= 0) grid[armY][cx - 4 - armLen] = 'œà';

                    // Right arm
                    if (cx + 4 < size) grid[armY][cx + 4] = '‚ï≤';
                    for (let i = 1; i <= armLen; i++) {
                        if (cx + 4 + i < size) grid[armY][cx + 4 + i] = '‚îÄ';
                    }
                    if (cx + 4 + armLen < size) grid[armY][cx + 4 + armLen] = 'œà';
                }

                // LEGS with joints
                const legY = bodyY + bodyH;
                for (let leg of [-1, 1]) {
                    const legX = cx + leg * 2;
                    const legLen = isChild ? 2 : 3;
                    for (let i = 0; i < legLen; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            grid[legY + i][legX] = '‚îÇ';
                        }
                    }
                    // Clawed feet
                    if (legY + legLen >= 0 && legY + legLen < size && legX >= 0 && legX < size) {
                        grid[legY + legLen][legX] = '…Ö';
                    }
                }

                // VARIABLE TAIL STYLES
                const tailStart = bodyY + bodyH;
                const tailLen = isChild ? 3 : 5;
                for (let i = 0; i < tailLen; i++) {
                    const ty = tailStart + i;
                    if (tailStyle === 0) {
                        // Serpentine
                        const tx = cx + (i % 3 === 0 ? -1 : (i % 3 === 1 ? 0 : 1));
                        if (ty >= 0 && ty < size && tx >= 0 && tx < size) {
                            grid[ty][tx] = i === tailLen - 1 ? '‚ñº' : '‚ï≤';
                        }
                    } else if (tailStyle === 1) {
                        // Spiked straight
                        if (ty >= 0 && ty < size && cx >= 0 && cx < size) {
                            grid[ty][cx] = i === tailLen - 1 ? '‚ñº' : (i % 2 === 0 ? '‚îÉ' : '‚îÇ');
                        }
                    } else {
                        // Club tail
                        const tx = cx + (i > tailLen / 2 ? 1 : 0);
                        if (ty >= 0 && ty < size && tx >= 0 && tx < size) {
                            grid[ty][tx] = i === tailLen - 1 ? '‚ñà' : '‚îÇ';
                        }
                    }
                }

                // VARIABLE DORSAL SPINES along back
                if (hasSpines) {
                    const spineStyles = ['‚ñ≤', '‚ñ¥', '‚ñ≥', '‚ãÄ', '‚óÜ', '‚ô¶'];
                    const spineChar = spineStyles[headVariant % spineStyles.length];

                    // Variable spine count (2-4)
                    const spacing = Math.floor(bodyH / spineCount);
                    for (let s = 0; s < spineCount; s++) {
                        const spineY = bodyY + s * spacing;
                        if (spineY >= 0 && spineY < size && cx >= 0 && cx < size) {
                            grid[spineY][cx] = spineChar;
                            // Double spines for some variants
                            if (scaleSize >= 2 && cx - 1 >= 0 && cx + 1 < size) {
                                grid[spineY][cx - 1] = spineChar;
                                grid[spineY][cx + 1] = spineChar;
                            }
                        }
                    }
                }

            } else if (species === 'mammalian') {
                // ‚ïê‚ïê‚ïê MAMMALIAN: MASSIVELY EXPANDED DNA variations ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA ‚ïê‚ïê‚ïê
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const noseStyleIdx = dna.noseStyleIdx || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const headVariant = dna.headVariant || 0;
                const earStyle = dna.earStyle;
                const hasTail = dna.hasTail;
                const hasWhiskers = dna.hasWhiskers;
                const bellyMarkIdx = dna.bellyMarkIdx || 0;

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 8 : 10;
                const bodyH = isChild ? 3 : 4;

                // ROUND HEAD with fur texture
                for (let y = -2; y <= 2; y++) {
                    for (let x = -2; x <= 2; x++) {
                        const dist = Math.sqrt(x*x + y*y);
                        if (dist <= 2 && headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            if (dist > 1.5) {
                                grid[headY + y][cx + x] = '‚ñë'; // Fur outline
                            } else {
                                grid[headY + y][cx + x] = ' ';
                            }
                        }
                    }
                }

                // VARIABLE EYES (2-4 eyes with different styles)
                const eyeStyles = ['‚óè', '‚óâ', '‚óã', '‚óé', '‚äô', '‚óï'];
                const eyeChar = eyeStyles[eyeStyleIdx % eyeStyles.length];

                if (numEyes === 2) {
                    if (headY >= 0 && headY < size) {
                        if (cx - 1 >= 0) grid[headY][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY][cx + 1] = eyeChar;
                    }
                } else if (numEyes >= 3) {
                    if (headY >= 0 && headY < size) {
                        if (cx - 2 >= 0) grid[headY][cx - 2] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY][cx] = eyeChar;
                        if (cx + 2 < size) grid[headY][cx + 2] = eyeChar;
                        if (numEyes >= 4 && cx + 1 < size) grid[headY - 1][cx + 1] = eyeChar;
                    }
                }

                // VARIABLE NOSE
                const noseStyles = ['‚ñº', '‚óè', '‚óã', '‚óâ', '‚ñΩ', '‚óÜ'];
                const noseChar = noseStyles[noseStyleIdx % noseStyles.length];
                if (headY + 1 >= 0 && headY + 1 < size && cx >= 0 && cx < size) {
                    grid[headY + 1][cx] = noseChar;
                }

                // VARIABLE MOUTH
                const mouthStyles = ['w', '‚à™', 'U', 'v', '‚å£', '‚å¢'];
                const mouthChar = mouthStyles[mouthStyleIdx % mouthStyles.length];
                if (headY + 2 >= 0 && headY + 2 < size && cx >= 0 && cx < size) {
                    grid[headY + 2][cx] = mouthChar;
                }

                // WHISKERS (detailed variable styles)
                if (hasWhiskers) {
                    const whiskerStyles = [
                        ['‚îÄ', '‚îÄ', '‚îÄ'], // straight
                        ['‚ï±', '‚îÄ', '‚ï≤'], // angled
                        ['~', '~', '~'], // wavy
                        ['‚ïê', '‚ïê', '‚ïê'], // thick
                        ['‚ïå', '‚ïå', '‚ïå'], // dotted
                    ];
                    const whiskerStyle = whiskerStyles[mouthStyleIdx % whiskerStyles.length];

                    // Upper whiskers
                    if (headY >= 0 && headY < size) {
                        if (cx - 3 >= 0) grid[headY][cx - 3] = whiskerStyle[0];
                        if (cx - 4 >= 0) grid[headY][cx - 4] = whiskerStyle[1];
                        if (cx + 3 < size) grid[headY][cx + 3] = whiskerStyle[0];
                        if (cx + 4 < size) grid[headY][cx + 4] = whiskerStyle[1];
                    }

                    // Middle whiskers
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 3 >= 0) grid[headY + 1][cx - 3] = whiskerStyle[2];
                        if (cx + 3 < size) grid[headY + 1][cx + 3] = whiskerStyle[2];
                    }

                    // Lower whiskers (if not child)
                    if (!isChild && headY + 2 >= 0 && headY + 2 < size) {
                        if (cx - 3 >= 0) grid[headY + 2][cx - 3] = whiskerStyle[0];
                        if (cx + 3 < size) grid[headY + 2][cx + 3] = whiskerStyle[0];
                    }
                }

                // VARIABLE EARS
                if (headY - 2 >= 0) {
                    if (earStyle === 0) {
                        // Pointy
                        if (cx - 2 >= 0) grid[headY - 2][cx - 2] = '‚ñ≤';
                        if (cx + 2 < size) grid[headY - 2][cx + 2] = '‚ñ≤';
                    } else if (earStyle === 1) {
                        // Round
                        if (cx - 2 >= 0) grid[headY - 2][cx - 2] = '‚óØ';
                        if (cx + 2 < size) grid[headY - 2][cx + 2] = '‚óØ';
                    } else {
                        // Floppy (down)
                        if (headY >= 0) {
                            if (cx - 3 >= 0) grid[headY][cx - 3] = '‚ï≤';
                            if (cx + 3 < size) grid[headY][cx + 3] = '‚ï±';
                        }
                    }
                }

                // FURRY BODY with detailed patterns
                // Fur texture patterns
                const furPatterns = [
                    ['‚ñë', '‚ñí', '‚ñì'], // gradient
                    ['‚à¥', '‚àµ', '‚à∑'], // dots
                    ['‚âà', '~', '‚àº'], // waves
                    ['‚ñ™', '‚ñ´', '¬∑'], // spots
                    ['‚ïë', '‚îÇ', '‚îÉ'], // stripes vertical
                    ['‚ïê', '‚îÄ', '‚îÅ'], // stripes horizontal
                ];
                const furPattern = furPatterns[bodyTextureIdx % furPatterns.length];

                // Body outline and fill
                for (let y = 0; y < bodyH; y++) {
                    for (let x = -3; x <= 3; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (x === -3 || x === 3) {
                                grid[bodyY + y][cx + x] = '‚ñë'; // Fur outline
                            } else if (Math.abs(x) === 2) {
                                // Inner fur layer
                                grid[bodyY + y][cx + x] = furPattern[0];
                            } else if (Math.abs(x) === 1) {
                                // Middle layer
                                grid[bodyY + y][cx + x] = furPattern[1];
                            } else {
                                // Center/belly
                                grid[bodyY + y][cx + x] = furPattern[2];
                            }
                        }
                    }
                }

                // BELLY MARK (detailed)
                const bellyMarks = [
                    ['‚óâ', '‚óè'], // spots
                    ['‚ñ£', '‚ñ¢'], // squares
                    ['‚óÜ', '‚óá'], // diamonds
                    ['‚óã', '‚óé'], // circles
                    ['‚â°', '='], // stripes
                    ['‚à¥', '‚àµ'], // dots pattern
                ];
                if (bellyMarkIdx < bellyMarks.length) {
                    const [mark1, mark2] = bellyMarks[bellyMarkIdx];
                    const markY = bodyY + Math.floor(bodyH / 2);
                    if (markY >= 0 && markY < size) {
                        if (cx >= 0 && cx < size) grid[markY][cx] = mark1;
                        if (markY + 1 < size && cx >= 0 && cx < size) grid[markY + 1][cx] = mark2;
                    }
                }

                // CHEST TUFT (variable)
                if (headVariant % 3 === 0 && bodyY >= 0 && bodyY < size) {
                    if (cx >= 0 && cx < size) grid[bodyY][cx] = '‚àá';
                }

                // SPOTS/STRIPES on back (based on bodyTextureIdx)
                if (bodyTextureIdx % 4 < 2) {
                    // Add spots
                    for (let i = 0; i < 3; i++) {
                        const spotY = bodyY + Math.floor((i + 0.5) * bodyH / 3);
                        const spotX = cx + (i % 2 === 0 ? -2 : 2);
                        if (spotY >= 0 && spotY < size && spotX >= 0 && spotX < size) {
                            grid[spotY][spotX] = '‚óè';
                        }
                    }
                } else if (bodyTextureIdx % 4 >= 2) {
                    // Add stripes
                    for (let y = 0; y < bodyH; y += 2) {
                        const stripeY = bodyY + y;
                        if (stripeY >= 0 && stripeY < size) {
                            if (cx - 2 >= 0) grid[stripeY][cx - 2] = '‚ïë';
                            if (cx + 2 < size) grid[stripeY][cx + 2] = '‚ïë';
                        }
                    }
                }

                // FACE MARKINGS (like raccoon mask or forehead mark)
                if (headVariant % 2 === 0) {
                    // Eye mask
                    if (headY >= 0 && headY < size) {
                        if (cx - 2 >= 0) grid[headY][cx - 2] = '‚ñì';
                        if (cx + 2 < size) grid[headY][cx + 2] = '‚ñì';
                    }
                } else {
                    // Forehead mark
                    if (headY - 1 >= 0 && headY - 1 < size && cx >= 0 && cx < size) {
                        grid[headY - 1][cx] = '‚óÜ';
                    }
                }

                // CHEEK TUFTS (fluff on sides of face)
                if (noseStyleIdx % 3 === 0 && headY + 1 >= 0 && headY + 1 < size) {
                    if (cx - 2 >= 0) grid[headY + 1][cx - 2] = '‚âà';
                    if (cx + 2 < size) grid[headY + 1][cx + 2] = '‚âà';
                }

                // ARMS with detailed paws
                const armY = bodyY + 1;
                const armLen = isChild ? 2 : 3;
                const armStyleIdx = dna.armStyleIdx || 0;
                const pawStyles = ['‚äÇ', '‚óê', '‚äÉ', '‚óë', '‚äê', '‚äè'];

                if (armY >= 0 && armY < size) {
                    // Furry arms
                    for (let i = 1; i <= armLen; i++) {
                        const armChar = i % 2 === 0 ? '‚îÄ' : '‚ïê';
                        if (cx - 3 - i >= 0) grid[armY][cx - 3 - i] = armChar;
                        if (cx + 3 + i < size) grid[armY][cx + 3 + i] = armChar;
                    }
                    // Detailed paws with paw pads
                    const leftPaw = pawStyles[armStyleIdx % pawStyles.length];
                    const rightPaw = pawStyles[(armStyleIdx + 1) % pawStyles.length];
                    if (cx - 3 - armLen >= 0) grid[armY][cx - 3 - armLen] = leftPaw;
                    if (cx + 3 + armLen < size) grid[armY][cx + 3 + armLen] = rightPaw;

                    // Claws (if DNA has them)
                    if (dna.hasClaws && !isChild) {
                        if (cx - 3 - armLen - 1 >= 0 && armY >= 0 && armY < size) {
                            grid[armY][cx - 3 - armLen - 1] = '‚â∫';
                        }
                        if (cx + 3 + armLen + 1 < size && armY >= 0 && armY < size) {
                            grid[armY][cx + 3 + armLen + 1] = '‚âª';
                        }
                    }
                }

                // LEGS with detailed paws
                const legY = bodyY + bodyH;
                const footStyles = ['‚ä•', '‚ä§', '‚ñº', '‚ñΩ', '‚ïß', '‚ï®'];

                for (let leg of [-1, 1]) {
                    const legX = cx + leg * 2;
                    const legLen = isChild ? 2 : 3;
                    const legStyleIdx = dna.legStyleIdx || 0;

                    // Furry legs
                    for (let i = 0; i < legLen; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            const legChar = i % 2 === 0 ? '‚îÇ' : '‚ïë';
                            grid[legY + i][legX] = legChar;
                        }
                    }

                    // Detailed paw pads
                    const footChar = footStyles[legStyleIdx % footStyles.length];
                    if (legY + legLen >= 0 && legY + legLen < size && legX >= 0 && legX < size) {
                        grid[legY + legLen][legX] = footChar;
                    }

                    // Toe beans (paw pad details)
                    if (!isChild && legY + legLen + 1 >= 0 && legY + legLen + 1 < size) {
                        if (legX - 1 >= 0) grid[legY + legLen + 1][legX - 1] = '¬∑';
                        if (legX + 1 < size) grid[legY + legLen + 1][legX + 1] = '¬∑';
                    }
                }

                // TAIL (variable)
                if (hasTail) {
                    const tailStart = bodyY + bodyH;
                    const tailLen = isChild ? 3 : 4;
                    const tailStyle = Math.floor(random() * 2); // 0=curved, 1=straight
                    for (let i = 0; i < tailLen; i++) {
                        const ty = tailStart + i;
                        let tx;
                        if (tailStyle === 0) {
                            tx = cx + (i % 2 === 0 ? 1 : 2); // Curved
                        } else {
                            tx = cx + 2; // Straight up
                        }
                        if (ty >= 0 && ty < size && tx >= 0 && tx < size) {
                            grid[ty][tx] = i === tailLen - 1 ? '‚óØ' : (tailStyle === 0 ? '‚ï≤' : '‚îÇ');
                        }
                    }
                }

            } else if (species === 'viral') {
                // ‚ïê‚ïê‚ïê VIRAL: Blob creature with MAXIMUM DETAIL & VARIETY ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA (NOT random during render!) ‚ïê‚ïê‚ïê
                const numEyes = dna.numEyes;
                const eyeStyle = EYE_STYLES[dna.eyeStyleIdx];
                const hasPupils = dna.hasPupils;
                const pupilStyle = PUPIL_STYLES[dna.pupilStyleIdx];
                const hasEyebrows = dna.hasEyebrows;
                const eyebrowStyle = EYEBROW_STYLES[dna.eyebrowStyleIdx];

                const mouthStyle = MOUTH_STYLES[dna.mouthStyleIdx];
                const hasTeeth = dna.hasTeeth;
                const teethStyle = TEETH_STYLES[dna.teethStyleIdx];
                const hasNose = dna.hasNose;
                const noseStyle = NOSE_STYLES[dna.noseStyleIdx];

                const headVariant = dna.headVariant;
                const armStyleIdx = dna.armStyleIdx;
                const armStyle = ARM_STYLES[armStyleIdx];
                const numArms = dna.numArms;
                const hasClaws = dna.hasClaws;

                const legStyleIdx = dna.legStyleIdx;
                const legStyle = LEG_STYLES[legStyleIdx];
                const numLegs = dna.numLegs;
                const hasToes = dna.hasToes;

                const bodyTexture = BODY_TEXTURES[dna.bodyTextureIdx];
                const hasSpots = dna.hasSpots;
                const faceMark = FACE_MARKS[dna.faceMarkIdx];
                const bellyMark = BELLY_MARKS[dna.bellyMarkIdx];
                const hasScars = dna.hasScars;
                const scarMark = SCAR_MARKS[dna.scarMarkIdx];

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 8 : 10;
                const bodyH = isChild ? 3 : 4;

                // VARIABLE HEAD SHAPE (based on headVariant)
                let headW, headH;
                if (headVariant === 0) {
                    // Wide blob
                    headW = isChild ? 3 : 4;
                    headH = 3;
                } else if (headVariant === 1) {
                    // Tall blob
                    headW = isChild ? 2 : 3;
                    headH = 4;
                } else {
                    // Round blob
                    headW = isChild ? 2 : 3;
                    headH = 4;
                }

                // Draw head outline
                for (let y = 0; y < headH; y++) {
                    for (let x = -headW; x <= headW; x++) {
                        if (headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            if (y === 0) {
                                if (x === 0 || x === -headW) grid[headY + y][cx + x] = '‚ï≠';
                                else if (x === headW) grid[headY + y][cx + x] = '‚ïÆ';
                                else grid[headY + y][cx + x] = '‚îÄ';
                            } else if (y === headH - 1) {
                                if (x === 0 || x === -headW) grid[headY + y][cx + x] = '‚ï∞';
                                else if (x === headW) grid[headY + y][cx + x] = '‚ïØ';
                                else grid[headY + y][cx + x] = '‚îÄ';
                            } else if (Math.abs(x) === headW) {
                                grid[headY + y][cx + x] = '‚îÇ';
                            }
                        }
                    }
                }

                // EYEBROWS (40% chance, above eyes)
                if (hasEyebrows && headY - 1 >= 0) {
                    if (numEyes === 2) {
                        if (cx - 2 >= 0) grid[headY - 1][cx - 2] = eyebrowStyle;
                        if (cx + 2 < size) grid[headY - 1][cx + 2] = eyebrowStyle;
                    }
                }

                // EYES with PUPILS (from library, 2-5 eyes)
                const eyeY = headY + Math.floor(headH * 0.3);
                const eyePositions = [];
                if (eyeY >= 0 && eyeY < size) {
                    if (numEyes === 2) {
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    } else if (numEyes === 3) {
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx < size) { grid[eyeY][cx] = eyeStyle; eyePositions.push(cx); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    } else if (numEyes === 4) {
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx - 1 >= 0) { grid[eyeY][cx - 1] = eyeStyle; eyePositions.push(cx - 1); }
                        if (cx + 1 < size) { grid[eyeY][cx + 1] = eyeStyle; eyePositions.push(cx + 1); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    } else {
                        // 5 eyes
                        if (cx - 2 >= 0) { grid[eyeY][cx - 2] = eyeStyle; eyePositions.push(cx - 2); }
                        if (cx - 1 >= 0) { grid[eyeY][cx - 1] = eyeStyle; eyePositions.push(cx - 1); }
                        if (cx < size) { grid[eyeY][cx] = eyeStyle; eyePositions.push(cx); }
                        if (cx + 1 < size) { grid[eyeY][cx + 1] = eyeStyle; eyePositions.push(cx + 1); }
                        if (cx + 2 < size) { grid[eyeY][cx + 2] = eyeStyle; eyePositions.push(cx + 2); }
                    }

                    // PUPILS inside eyes (70% chance)
                    if (hasPupils && ['‚óâ', '‚óé', '‚óã', '‚óØ', '‚äô', '‚óê', '‚óë'].includes(eyeStyle)) {
                        for (let eyeX of eyePositions) {
                            if (eyeX >= 0 && eyeX < size) {
                                grid[eyeY][eyeX] = pupilStyle;
                            }
                        }
                    }
                }

                // NOSE/NOSTRILS (30% chance, between eyes and mouth)
                if (hasNose) {
                    const noseY = eyeY + 1;
                    if (noseY >= 0 && noseY < size && cx >= 0 && cx < size) {
                        grid[noseY][cx] = noseStyle;
                    }
                }

                // MOUTH with TEETH (from library)
                const mouthY = headY + Math.floor(headH * 0.6);
                if (mouthY >= 0 && mouthY < size && cx >= 0 && cx < size) {
                    if (mouthStyle === '‚ï∞‚ïØ' && cx + 1 < size) {
                        grid[mouthY][cx] = '‚ï∞';
                        grid[mouthY][cx + 1] = '‚ïØ';
                    } else {
                        grid[mouthY][cx] = mouthStyle;
                    }

                    // TEETH showing (50% chance)
                    if (hasTeeth && mouthY + 1 >= 0 && mouthY + 1 < size) {
                        if (teethStyle.length > 2) {
                            // Multi-char teeth like 'vv' or 'VV'
                            const startX = cx - 1;
                            for (let i = 0; i < teethStyle.length && startX + i < size; i++) {
                                if (startX + i >= 0) grid[mouthY + 1][startX + i] = teethStyle[i];
                            }
                        } else {
                            if (cx >= 0 && cx < size) grid[mouthY + 1][cx] = teethStyle;
                        }
                    }
                }

                // FACIAL MARKINGS/SPOTS (60% chance)
                if (hasSpots && headH > 2) {
                    const markY = headY + 2;
                    if (markY >= 0 && markY < size) {
                        // Cheek marks
                        if (cx - headW + 1 >= 0 && grid[markY][cx - headW + 1] === ' ') {
                            grid[markY][cx - headW + 1] = faceMark;
                        }
                        if (cx + headW - 1 < size && grid[markY][cx + headW - 1] === ' ') {
                            grid[markY][cx + headW - 1] = faceMark;
                        }
                    }
                }

                // SCARS (20% chance - battle-worn look)
                if (hasScars) {
                    const scarY = headY + 1;
                    if (scarY >= 0 && scarY < size && cx + 1 < size) {
                        grid[scarY][cx + 1] = scarMark;
                    }
                }

                // VARIABLE BODY SHAPE with BELLY PATTERN
                const bodyW = headVariant === 0 ? 3 : 2;
                for (let y = 0; y < bodyH; y++) {
                    for (let x = -bodyW; x <= bodyW; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (y === 0 && Math.abs(x) <= bodyW - 1) {
                                grid[bodyY + y][cx + x] = '‚îÄ';
                            } else if (y === bodyH - 1 && Math.abs(x) <= bodyW - 1) {
                                grid[bodyY + y][cx + x] = '‚îÄ';
                            } else if (Math.abs(x) === bodyW) {
                                grid[bodyY + y][cx + x] = '‚îÇ';
                            }
                            // BELLY MARKING (center of body)
                            else if (x === 0 && y === Math.floor(bodyH / 2)) {
                                grid[bodyY + y][cx + x] = bellyMark;
                            }
                        }
                    }
                }

                // TENTACLE ARMS with CLAWS (using ARM_STYLES library - like /\/\ or --> or ~~~)
                for (let arm = 0; arm < numArms; arm++) {
                    const ay = bodyY + arm;
                    if (ay >= 0 && ay < size) {
                        // Left arms
                        for (let i = 0; i < armStyle.chars.length; i++) {
                            if (cx - bodyW - 1 - i >= 0) {
                                grid[ay][cx - bodyW - 1 - i] = armStyle.chars[i];
                            }
                        }
                        // Tip or Claw at end
                        const leftTipX = cx - bodyW - 1 - armStyle.chars.length;
                        if (leftTipX >= 0) {
                            if (hasClaws) {
                                grid[ay][leftTipX] = armStyle.claw;
                            } else if (armStyle.tip) {
                                grid[ay][leftTipX] = armStyle.tip;
                            }
                        }

                        // Right arms (mirror)
                        for (let i = 0; i < armStyle.chars.length; i++) {
                            if (cx + bodyW + 1 + i < size) {
                                const char = armStyle.chars[i];
                                const mirrorChar = char === '/' ? '\\' : (char === '\\' ? '/' : char);
                                grid[ay][cx + bodyW + 1 + i] = mirrorChar;
                            }
                        }
                        // Tip or Claw at end
                        const rightTipX = cx + bodyW + 1 + armStyle.chars.length;
                        if (rightTipX < size) {
                            if (hasClaws) {
                                grid[ay][rightTipX] = armStyle.claw;
                            } else if (armStyle.tip) {
                                const mirrorTip = armStyle.tip === '‚ü©' ? '‚ü®' : (armStyle.tip === '>' ? '<' : armStyle.tip);
                                grid[ay][rightTipX] = mirrorTip;
                            }
                        }
                    }
                }

                // LEGS with TOES (using LEG_STYLES library - like /\ or ‚îÇ‚îÇ or ‚ï±‚ï≤)
                const legY = bodyY + bodyH;
                const legPositions = numLegs === 2 ? [-2, 2] : (numLegs === 3 ? [-2, 0, 2] : [-3, -1, 1, 3]);

                for (let legPos of legPositions) {
                    const legX = cx + legPos;
                    // Leg segments
                    for (let i = 0; i < legStyle.chars.length; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            grid[legY + i][legX] = legStyle.chars[i];
                        }
                    }
                    // Foot
                    const footY = legY + legStyle.chars.length;
                    if (footY >= 0 && footY < size && legX >= 0 && legX < size) {
                        grid[footY][legX] = legStyle.foot;
                    }
                    // Toes (50% chance)
                    if (hasToes && footY + 1 >= 0 && footY + 1 < size && legX >= 0 && legX < size) {
                        grid[footY + 1][legX] = legStyle.toe;
                    }
                }

            } else if (species === 'skeletal') {
                // ‚ïê‚ïê‚ïê SKELETAL: DNA-based variations - MASSIVELY EXPANDED ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA (NOT random during render!) ‚ïê‚ïê‚ïê
                const jawStyle = dna.jawStyle || 0;
                const ribCount = dna.ribCount || 3;
                const ribStyle = dna.ribStyle || 0;
                const spineStyle = dna.spineStyle || 0;
                const skullShape = dna.skullShape || 0;
                const eyeSocketStyle = dna.eyeSocketStyle || 0;
                const nasalStyle = dna.nasalStyle || 0;
                const armBoneStyle = dna.armBoneStyle || 0;
                const legBoneStyle = dna.legBoneStyle || 0;
                const jointStyle = dna.jointStyle || 0;
                const fingerStyle = dna.fingerStyle || 0;
                const footStyle = dna.footStyle || 0;
                const hasCracks = dna.hasCracks || false;
                const hasSpinalCord = dna.hasSpinalCord || false;
                const hasExtraRibs = dna.hasExtraRibs || false;
                const hasHorns = dna.hasHorns || false;
                const hasTeeth = dna.hasTeeth || false;
                const teethStyle = dna.teethStyle || 0;
                const boneThickness = dna.boneThickness || 1;
                const hasTail = dna.hasTail !== false; // Default true
                const tailBoneCount = dna.tailBoneCount || 4;

                const skullY = isChild ? 5 : 6;
                const spineY = isChild ? 8 : 10;
                const spineH = isChild ? (4 + dna.spineHeightVariant) : (5 + dna.spineHeightVariant);

                // VARIABLE SKULL SHAPE
                if (skullShape === 0) {
                    // Round skull
                    for (let y = -2; y <= 1; y++) {
                        for (let x = -2; x <= 2; x++) {
                            if (skullY + y >= 0 && skullY + y < size && cx + x >= 0 && cx + x < size) {
                                if (y === -2 || y === 1 || x === -2 || x === 2) {
                                    grid[skullY + y][cx + x] = '‚ñì';
                                }
                            }
                        }
                    }
                } else if (skullShape === 1) {
                    // Angular skull
                    for (let y = -2; y <= 1; y++) {
                        for (let x = -2; x <= 2; x++) {
                            if (skullY + y >= 0 && skullY + y < size && cx + x >= 0 && cx + x < size) {
                                if (y === -2 || y === 1 || x === -2 || x === 2) {
                                    grid[skullY + y][cx + x] = '‚ñ™';
                                }
                            }
                        }
                    }
                } else {
                    // Elongated skull
                    for (let y = -2; y <= 2; y++) {
                        for (let x = -2; x <= 2; x++) {
                            if (skullY + y >= 0 && skullY + y < size && cx + x >= 0 && cx + x < size) {
                                if (y === -2 || y === 2 || x === -2 || x === 2) {
                                    grid[skullY + y][cx + x] = '‚ñì';
                                }
                            }
                        }
                    }
                }

                // VARIABLE EYE SOCKETS with multiple styles
                const eyeSocketChars = ['‚óØ', '‚óâ', '‚óè', '‚óã'];
                const eyeSocketChar = eyeSocketChars[eyeSocketStyle] || '‚óØ';
                if (skullY >= 0 && skullY < size) {
                    if (cx - 1 >= 0) grid[skullY][cx - 1] = eyeSocketChar;
                    if (cx + 1 < size) grid[skullY][cx + 1] = eyeSocketChar;
                }

                // VARIABLE NASAL CAVITY
                if (skullY + 1 >= 0 && skullY + 1 < size && cx >= 0 && cx < size) {
                    if (nasalStyle === 0) {
                        grid[skullY + 1][cx] = '‚ñΩ';
                    } else if (nasalStyle === 1) {
                        grid[skullY + 1][cx] = '‚óã';
                    } else {
                        // Double nasal holes
                        if (cx - 1 >= 0) grid[skullY + 1][cx - 1] = '¬∑';
                        if (cx + 1 < size) grid[skullY + 1][cx + 1] = '¬∑';
                    }
                }

                // VARIABLE JAW with 3 styles
                for (let x = -2; x <= 2; x++) {
                    if (skullY + 2 >= 0 && skullY + 2 < size && cx + x >= 0 && cx + x < size) {
                        if (jawStyle === 0) {
                            // Normal jaw
                            grid[skullY + 2][cx + x] = x % 2 === 0 ? '‚ñì' : '‚ñî';
                        } else if (jawStyle === 1) {
                            // Fanged jaw
                            grid[skullY + 2][cx + x] = x % 2 === 0 ? '‚ñì' : 'V';
                        } else {
                            // Gapped/broken jaw
                            grid[skullY + 2][cx + x] = Math.abs(x) === 2 ? '‚ñì' : (x === 0 ? ' ' : '‚ñî');
                        }
                    }
                }

                // VARIABLE SPINE with 3 styles
                const jointChars = ['‚óâ', '‚óã', '‚ñ†'];
                const jointChar = jointChars[jointStyle] || '‚óâ';

                for (let v = 0; v < spineH; v++) {
                    const vY = spineY + v;
                    if (vY >= 0 && vY < size && cx >= 0 && cx < size) {
                        if (spineStyle === 0) {
                            // Vertebrae style
                            grid[vY][cx] = v % 2 === 0 ? jointChar : '‚îÇ';
                        } else if (spineStyle === 1) {
                            // Solid spine
                            grid[vY][cx] = '‚îÇ';
                        } else {
                            // Segmented spine
                            grid[vY][cx] = v % 2 === 0 ? '‚îÅ' : '‚îÇ';
                        }

                        // Optional spinal cord
                        if (hasSpinalCord && v % 2 === 1 && cx - 1 >= 0 && cx + 1 < size) {
                            if (grid[vY][cx - 1] === ' ') grid[vY][cx - 1] = '¬∑';
                            if (grid[vY][cx + 1] === ' ') grid[vY][cx + 1] = '¬∑';
                        }
                    }
                }

                // VARIABLE RIBCAGE with 3 styles (2-4 ribs)
                for (let rib = 0; rib < ribCount; rib++) {
                    const ribY = spineY + rib;
                    if (ribY >= 0 && ribY < size) {
                        if (ribStyle === 0) {
                            // Curved ribs
                            if (cx - 1 >= 0) grid[ribY][cx - 1] = '(';
                            if (cx - 2 >= 0) grid[ribY][cx - 2] = '‚îÄ';
                            if (cx + 1 < size) grid[ribY][cx + 1] = ')';
                            if (cx + 2 < size) grid[ribY][cx + 2] = '‚îÄ';
                        } else if (ribStyle === 1) {
                            // Straight ribs
                            if (cx - 1 >= 0) grid[ribY][cx - 1] = '‚îÄ';
                            if (cx - 2 >= 0) grid[ribY][cx - 2] = '‚îÄ';
                            if (cx + 1 < size) grid[ribY][cx + 1] = '‚îÄ';
                            if (cx + 2 < size) grid[ribY][cx + 2] = '‚îÄ';
                        } else {
                            // Broken ribs
                            if (cx - 1 >= 0 && rib % 2 === 0) grid[ribY][cx - 1] = '(';
                            if (cx - 2 >= 0 && rib % 2 === 0) grid[ribY][cx - 2] = '‚ïå';
                            if (cx + 1 < size && rib % 2 === 1) grid[ribY][cx + 1] = ')';
                            if (cx + 2 < size && rib % 2 === 1) grid[ribY][cx + 2] = '‚ïå';
                        }
                    }
                }

                // Add bone cracks randomly if hasCracks
                if (hasCracks) {
                    for (let i = 0; i < 3; i++) {
                        const crackY = skullY + Math.floor(random() * 4);
                        const crackX = cx + Math.floor(random() * 3) - 1;
                        if (crackY >= 0 && crackY < size && crackX >= 0 && crackX < size) {
                            if (grid[crackY][crackX] === '‚ñì' || grid[crackY][crackX] === '‚ñ™') {
                                grid[crackY][crackX] = '‚ñë';
                            }
                        }
                    }
                }

                // VARIABLE ARM BONES with joints
                const armY = spineY + 1;
                const armLen = isChild ? 2 : 3;
                const armBoneChars = [['‚îÄ', jointChar], ['‚ïê', jointChar], ['‚ïå', jointChar]];
                const [armChar, armJoint] = armBoneChars[armBoneStyle] || armBoneChars[0];

                if (armY >= 0 && armY < size) {
                    for (let i = 1; i <= armLen; i++) {
                        if (cx - 3 - i >= 0) {
                            grid[armY][cx - 3 - i] = i === Math.floor(armLen/2) ? armJoint : armChar;
                        }
                        if (cx + 3 + i < size) {
                            grid[armY][cx + 3 + i] = i === Math.floor(armLen/2) ? armJoint : armChar;
                        }
                    }
                    // VARIABLE FINGER bones
                    const fingerChars = ['‚ï¶', '‚î¨', 'Œ®', '‚ä§'];
                    const fingerChar = fingerChars[fingerStyle] || '‚ï¶';
                    if (cx - 3 - armLen - 1 >= 0) grid[armY][cx - 3 - armLen - 1] = fingerChar;
                    if (cx + 3 + armLen + 1 < size) grid[armY][cx + 3 + armLen + 1] = fingerChar;
                }

                // VARIABLE LEG BONES
                const legY = spineY + spineH;
                const legBoneChars = [['‚îÇ', jointChar], ['‚ïë', jointChar], ['‚îÜ', jointChar]];
                const [legChar, legJoint] = legBoneChars[legBoneStyle] || legBoneChars[0];

                for (let leg of [-1, 1]) {
                    const legX = cx + leg * 2;
                    const legLen = isChild ? 2 : 3;
                    for (let i = 0; i < legLen; i++) {
                        if (legY + i >= 0 && legY + i < size && legX >= 0 && legX < size) {
                            grid[legY + i][legX] = i === Math.floor(legLen/2) ? legJoint : legChar;
                        }
                    }
                    // VARIABLE FOOT bones
                    const footChars = ['‚ä•', '‚î¥', '‚îª'];
                    const footChar = footChars[footStyle] || '‚ä•';
                    if (legY + legLen >= 0 && legY + legLen < size && legX >= 0 && legX < size) {
                        grid[legY + legLen][legX] = footChar;
                    }
                }

            } else if (species === 'alien') {
                // ‚ïê‚ïê‚ïê ALIEN: MASSIVELY EXPANDED DNA variations ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA ‚ïê‚ïê‚ïê
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const headVariant = dna.alienHeadVariant;
                const hasAntennae = dna.hasAntennae;
                const numTentacles = dna.numTentacles;
                const bellyMarkIdx = dna.bellyMarkIdx || 0;

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 10 : 12;
                const bodyH = isChild ? 2 : 3;

                // VARIABLE HEAD SIZE
                const headH = headVariant === 0 ? (isChild ? 5 : 6) : (isChild ? 4 : 5);
                const headW = headVariant === 0 ? (isChild ? 4 : 5) : (isChild ? 3 : 4);

                // Top of head (rounded dome)
                if (headY >= 0 && headY < size) {
                    if (cx - headW >= 0) grid[headY][cx - headW] = '‚ï≠';
                    for (let x = cx - headW + 1; x < cx + headW; x++) {
                        if (x >= 0 && x < size) grid[headY][x] = '‚îÄ';
                    }
                    if (cx + headW < size) grid[headY][cx + headW] = '‚ïÆ';
                }

                // Upper head sides (bulging)
                for (let y = headY + 1; y < headY + Math.floor(headH * 0.6); y++) {
                    if (y >= 0 && y < size) {
                        if (cx - headW >= 0) grid[y][cx - headW] = '(';
                        if (cx + headW < size) grid[y][cx + headW] = ')';
                    }
                }

                // Lower head sides (narrowing)
                for (let y = headY + Math.floor(headH * 0.6); y < headY + headH - 1; y++) {
                    if (y >= 0 && y < size) {
                        if (cx - 2 >= 0) grid[y][cx - 2] = '‚îÇ';
                        if (cx + 2 < size) grid[y][cx + 2] = '‚îÇ';
                    }
                }

                // Bottom of head (chin)
                if (headY + headH - 1 >= 0 && headY + headH - 1 < size) {
                    if (cx - 2 >= 0) grid[headY + headH - 1][cx - 2] = '‚ï∞';
                    for (let x = cx - 1; x <= cx + 1; x++) {
                        if (x >= 0 && x < size) grid[headY + headH - 1][x] = '‚îÄ';
                    }
                    if (cx + 2 < size) grid[headY + headH - 1][cx + 2] = '‚ïØ';
                }

                // VARIABLE ALIEN EYES (2-5 eyes with different styles)
                const alienEyeStyles = ['‚óâ', '‚äô', '‚óé', '‚óè', '‚óã', '‚óØ', '‚äö', '‚óï', '‚óî'];
                const eyeChar = alienEyeStyles[eyeStyleIdx % alienEyeStyles.length];
                const eyeY = headY + Math.floor(headH * 0.4);

                if (numEyes === 2) {
                    if (eyeY >= 0 && eyeY < size) {
                        if (cx - 2 >= 0) grid[eyeY][cx - 2] = eyeChar;
                        if (cx + 2 < size) grid[eyeY][cx + 2] = eyeChar;
                    }
                } else if (numEyes === 3) {
                    if (eyeY >= 0 && eyeY < size) {
                        if (cx - 2 >= 0) grid[eyeY][cx - 2] = eyeChar;
                        if (cx >= 0 && cx < size) grid[eyeY - 1][cx] = eyeChar;
                        if (cx + 2 < size) grid[eyeY][cx + 2] = eyeChar;
                    }
                } else if (numEyes >= 4) {
                    // Multiple eyes scattered
                    if (eyeY >= 0 && eyeY < size) {
                        if (cx - 3 >= 0) grid[eyeY][cx - 3] = eyeChar;
                        if (cx - 1 >= 0) grid[eyeY][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[eyeY][cx + 1] = eyeChar;
                        if (cx + 3 < size) grid[eyeY][cx + 3] = eyeChar;
                        if (numEyes >= 5 && cx >= 0 && cx < size) grid[eyeY - 1][cx] = eyeChar;
                    }
                }

                // VARIABLE MOUTH
                const alienMouthStyles = ['~', '‚âà', '‚àº', '‚ñÇ', '‚ñÅ', '‚ïê', 'w', '‚à™'];
                const mouthChar = alienMouthStyles[mouthStyleIdx % alienMouthStyles.length];
                if (eyeY + 2 >= 0 && eyeY + 2 < size && cx >= 0 && cx < size) {
                    grid[eyeY + 2][cx] = mouthChar;
                }

                // ANTENNAE (variable)
                if (hasAntennae && !isChild) {
                    const antennaTip = dna.antennaTip || '‚óã';
                    for (let ant of [-1, 1]) {
                        const antX = cx + ant * 2;
                        if (headY - 1 >= 0 && antX >= 0 && antX < size) {
                            grid[headY - 1][antX] = '‚îÇ';
                        }
                        if (headY - 2 >= 0 && antX >= 0 && antX < size) {
                            grid[headY - 2][antX] = antennaTip;
                        }
                    }
                }

                // SMALL BODY (neck/torso)
                for (let y = 0; y < bodyH; y++) {
                    if (bodyY + y >= 0 && bodyY + y < size) {
                        if (y === 0 || y === bodyH - 1) {
                            // Top and bottom edges
                            for (let x = -1; x <= 1; x++) {
                                if (cx + x >= 0 && cx + x < size) {
                                    grid[bodyY + y][cx + x] = '‚îÄ';
                                }
                            }
                        } else {
                            // Sides
                            if (cx - 1 >= 0) grid[bodyY + y][cx - 1] = '‚îÇ';
                            if (cx + 1 < size) grid[bodyY + y][cx + 1] = '‚îÇ';
                        }
                    }
                }

                // TENTACLE ARMS (2 wavy arms)
                const armY = bodyY + 1;
                if (armY >= 0 && armY < size) {
                    // Left arm
                    for (let i = 1; i <= 3; i++) {
                        if (cx - 2 - i >= 0) {
                            grid[armY][cx - 2 - i] = i === 3 ? '‚âà' : '~';
                        }
                    }
                    // Right arm
                    for (let i = 1; i <= 3; i++) {
                        if (cx + 2 + i < size) {
                            grid[armY][cx + 2 + i] = i === 3 ? '‚âà' : '~';
                        }
                    }
                }

                // VARIABLE TENTACLE LEGS (3-4 tentacles)
                const legY = bodyY + bodyH;
                const legPositions = numTentacles === 3 ? [-2, 0, 2] : [-3, -1, 1, 3];

                for (let legX of legPositions) {
                    const tentX = cx + legX;
                    const legLen = isChild ? 2 : 3;
                    const legStyle = dna.legStyle || 'block';
                    for (let i = 0; i < legLen; i++) {
                        const py = legY + i;
                        if (py >= 0 && py < size && tentX >= 0 && tentX < size) {
                            if (i === 0) {
                                grid[py][tentX] = '‚îÇ';
                            } else if (i === legLen - 1) {
                                grid[py][tentX] = legStyle === 'line' ? '‚ñº' : '‚ñΩ';
                            } else {
                                grid[py][tentX] = i % 2 === 0 ? '‚îÇ' : '‚îÉ';
                            }
                        }
                    }
                }

            } else if (species === 'aquatic') {
                // ‚ïê‚ïê‚ïê AQUATIC: MASSIVELY EXPANDED DNA-based variations ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê READ ALL VARIATIONS FROM DNA ‚ïê‚ïê‚ïê
                const numEyes = dna.numEyes || 2;
                const eyeStyleIdx = dna.eyeStyleIdx || 0;
                const mouthStyleIdx = dna.mouthStyleIdx || 0;
                const headVariant = dna.headVariant || 0;
                const bodyTextureIdx = dna.bodyTextureIdx || 0;
                const hasDorsalFin = dna.hasDorsalFin;
                const tailShape = dna.tailShape;
                const numGills = dna.numGills;
                const armStyleIdx = dna.armStyleIdx || 0; // For fin variation
                const bellyMarkIdx = dna.bellyMarkIdx || 0;

                const headY = isChild ? 5 : 6;
                const bodyY = isChild ? 8 : 10;
                const bodyH = isChild ? 3 : 4;

                // VARIABLE HEAD SHAPES (3 variants)
                const headChar = headVariant % 3 === 0 ? '‚ñì' : (headVariant % 3 === 1 ? '‚ñà' : '‚ñí');
                for (let y = 0; y < 3; y++) {
                    const w = y === 1 ? 2 : 1;
                    for (let x = -w; x <= w; x++) {
                        if (headY + y >= 0 && headY + y < size && cx + x >= 0 && cx + x < size) {
                            grid[headY + y][cx + x] = headChar;
                        }
                    }
                }

                // VARIABLE EYES (2-5 eyes with different styles)
                const eyeStyles = ['‚óè', '‚óâ', '‚óã', '‚óé', '‚äô', '‚óï', '‚óî', '‚óê', '‚óë'];
                const eyeChar = eyeStyles[eyeStyleIdx % eyeStyles.length];

                if (numEyes === 2) {
                    // Standard 2 eyes
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                    }
                } else if (numEyes === 3) {
                    // 3 eyes (one in middle)
                    if (headY + 1 >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY][cx] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                    }
                } else if (numEyes === 4) {
                    // 4 eyes (2 rows)
                    if (headY >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) {
                            grid[headY][cx - 1] = eyeChar;
                            grid[headY + 1][cx - 1] = eyeChar;
                        }
                        if (cx + 1 < size) {
                            grid[headY][cx + 1] = eyeChar;
                            grid[headY + 1][cx + 1] = eyeChar;
                        }
                    }
                } else {
                    // 5+ eyes (scattered)
                    if (headY >= 0 && headY + 1 < size) {
                        if (cx - 1 >= 0) grid[headY + 1][cx - 1] = eyeChar;
                        if (cx + 1 < size) grid[headY + 1][cx + 1] = eyeChar;
                        if (cx >= 0 && cx < size) grid[headY][cx] = eyeChar;
                        if (cx - 2 >= 0) grid[headY][cx - 2] = eyeChar;
                        if (cx + 2 < size) grid[headY][cx + 2] = eyeChar;
                    }
                }

                // VARIABLE MOUTH (using mouthStyleIdx)
                const mouthStyles = ['~', '‚âà', '‚àº', '„Äú', '‚ñÇ', '‚ñÅ', '‚ïê', '‚îÅ'];
                const mouthChar = mouthStyles[mouthStyleIdx % mouthStyles.length];
                if (headY + 2 >= 0 && headY + 2 < size && cx >= 0 && cx < size) {
                    grid[headY + 2][cx] = mouthChar;
                    if (mouthStyleIdx % 4 >= 2) {
                        // Wider mouth
                        if (cx - 1 >= 0) grid[headY + 2][cx - 1] = mouthChar;
                        if (cx + 1 < size) grid[headY + 2][cx + 1] = mouthChar;
                    }
                }

                // VARIABLE GILLS (2-3 slits)
                for (let g = 0; g < numGills; g++) {
                    const gillY = headY + 2 + g;
                    if (gillY >= 0 && gillY < size) {
                        if (cx - 2 >= 0) grid[gillY][cx - 2] = ')';
                        if (cx + 2 < size) grid[gillY][cx + 2] = '(';
                    }
                }

                // VARIABLE BODY with multiple scale/texture patterns
                const bodyTextures = [
                    ['‚óä', '‚óá'], ['‚ñí', '‚ñë'], ['‚ñì', '‚ñí'], ['~', '‚âà'],
                    ['‚àº', '~'], ['‚ó¶', '‚àò'], ['¬∑', '‚àô'], ['‚ïê', '‚îÄ'],
                    ['‚ñ™', '‚ñ´'], ['‚óã', '‚óè']
                ];
                const [tex1, tex2] = bodyTextures[bodyTextureIdx % bodyTextures.length];

                for (let y = 0; y < bodyH; y++) {
                    for (let x = -3; x <= 3; x++) {
                        if (bodyY + y >= 0 && bodyY + y < size && cx + x >= 0 && cx + x < size) {
                            if (x === -3 || x === 3) {
                                grid[bodyY + y][cx + x] = '‚ñì';
                            } else {
                                // Variable texture pattern
                                grid[bodyY + y][cx + x] = (x + y) % 2 === 0 ? tex1 : tex2;
                            }
                        }
                    }
                }

                // VARIABLE BELLY MARK (using bellyMarkIdx)
                const bellyMarks = ['‚óâ', '‚óè', '‚ñ£', '‚óÜ', '‚óà', '‚äï', '‚äó', '‚äõ'];
                if (bellyMarkIdx < 6) { // Only show on some creatures
                    const markY = bodyY + Math.floor(bodyH / 2);
                    const markChar = bellyMarks[bellyMarkIdx % bellyMarks.length];
                    if (markY >= 0 && markY < size && cx >= 0 && cx < size) {
                        grid[markY][cx] = markChar;
                    }
                }

                // VARIABLE PECTORAL FINS (using armStyleIdx)
                const finStyles = [
                    {char: '‚îÄ', tip: '‚ñ∂', angle: '‚ï±'},  // swept back
                    {char: '‚ïê', tip: '‚ñ∫', angle: '‚ï±'},  // thick
                    {char: '‚ïå', tip: '‚ñ∑', angle: '‚ï±'},  // dotted
                    {char: '~', tip: '‚ñ∏', angle: '‚ï±'},  // wavy
                    {char: '‚ñ¨', tip: '‚ñ∂', angle: '‚ï±'},  // solid
                    {char: '‚îÅ', tip: '‚ñ∂', angle: '‚ï±'},  // heavy
                ];
                const finStyle = finStyles[armStyleIdx % finStyles.length];
                const finY = bodyY + 1;

                if (finY >= 0 && finY < size) {
                    // Left fin
                    for (let i = 1; i <= 3; i++) {
                        if (cx - 3 - i >= 0) {
                            grid[finY][cx - 3 - i] = i === 1 ? finStyle.angle : finStyle.char;
                        }
                    }
                    if (cx - 3 - 4 >= 0) grid[finY][cx - 3 - 4] = finStyle.tip;

                    // Right fin (mirrored)
                    for (let i = 1; i <= 3; i++) {
                        if (cx + 3 + i < size) {
                            grid[finY][cx + 3 + i] = i === 1 ? '‚ï≤' : finStyle.char;
                        }
                    }
                    const mirrorTip = finStyle.tip === '‚ñ∂' ? '‚óÄ' : (finStyle.tip === '‚ñ∫' ? '‚óÑ' : '‚óÅ');
                    if (cx + 3 + 4 < size) grid[finY][cx + 3 + 4] = mirrorTip;
                }

                // DORSAL FIN (variable)
                if (hasDorsalFin && !isChild) {
                    const dorsalY = bodyY - 1;
                    if (dorsalY >= 0 && cx >= 0 && cx < size) {
                        grid[dorsalY][cx] = '‚ñ≤';
                    }
                }

                // VENTRAL FINS (bottom, like legs)
                const vFinY = bodyY + bodyH;
                for (let fin of [-1, 1]) {
                    const finX = cx + fin * 2;
                    for (let i = 0; i < 2; i++) {
                        if (vFinY + i >= 0 && vFinY + i < size && finX >= 0 && finX < size) {
                            grid[vFinY + i][finX] = i === 0 ? '‚ï≤' : '‚ñº';
                        }
                    }
                }

                // VARIABLE TAIL FIN (3 shapes)
                const tailStart = bodyY + bodyH;
                const tailLen = isChild ? 3 : 5;
                for (let i = 0; i < tailLen; i++) {
                    const ty = tailStart + i;
                    if (ty >= 0 && ty < size) {
                        if (i < tailLen - 2) {
                            // Tail body
                            if (cx >= 0 && cx < size) {
                                grid[ty][cx] = '‚îÇ';
                            }
                        } else {
                            // Variable tail shapes
                            if (tailShape === 0) {
                                // Fan shape (spread out)
                                for (let spread of [-2, -1, 0, 1, 2]) {
                                    const fanX = cx + spread;
                                    if (fanX >= 0 && fanX < size) {
                                        grid[ty][fanX] = i === tailLen - 1 ? '‚ñº' : '‚ï≤';
                                    }
                                }
                            } else if (tailShape === 1) {
                                // Forked tail
                                if (i === tailLen - 1) {
                                    if (cx - 1 >= 0) grid[ty][cx - 1] = '‚óÑ';
                                    if (cx + 1 < size) grid[ty][cx + 1] = '‚ñ∫';
                                } else {
                                    if (cx >= 0 && cx < size) grid[ty][cx] = '‚îÇ';
                                }
                            } else {
                                // Round tail
                                if (i === tailLen - 1) {
                                    if (cx >= 0 && cx < size) grid[ty][cx] = '‚óØ';
                                } else {
                                    if (cx >= 0 && cx < size) grid[ty][cx] = '‚îÇ';
                                }
                            }
                        }
                    }
                }

            } else {
                // Fallback - shouldn't happen but just in case
                // Draw a simple default creature
                if (cy >= 0 && cy < size && cx >= 0 && cx < size) {
                    grid[cy][cx] = '‚óâ';
                }
            }

            // Convert grid to string
            const ascii = grid.map(row => row.join('')).join('\n');

            return {
                ascii,
                family,
                seed,
                id: Math.random().toString(36).substr(2, 9),
                dna: dna,
                traits: {
                    species: dna.species, // SPECIES IS THE PRIMARY IDENTIFIER
                    bodyType,
                    armCount,
                    legCount,
                    antennaCount,
                    armStyle,
                    legStyle,
                    hatType: dna.hatType,
                    hasCigarette: dna.hasCigarette,
                    eyeSize: dna.eyeSize
                }
            };
        }

        function selectFamily(family) {
            currentFamily = family;

            document.querySelectorAll('.family-btn').forEach(btn => {
                if (btn.dataset.family === family) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            document.getElementById('currentFamilyName').textContent = families[family].name;

            displayFamily(family);
        }

        let spreaderCounter = 0;

        function generateSpreader() {
            // CRITICAL: Pass null to use centralized unique seed generation
            // The seed tracking system guarantees NO duplicates
            const spreader = generateASCIICreature(24, currentFamily, null);
            familyData[currentFamily].spreaders.push(spreader);
            displayFamily(currentFamily);
            updateStats();
        }

        // ‚ïê‚ïê‚ïê DRAMATIC & RANDOM CHARACTER-LEVEL ANIMATIONS ‚ïê‚ïê‚ïê
        function applyAnimations(asciiDiv, creature) {
            const dna = creature.dna;
            if (!dna || !dna.animationStage) return;

            let currentAscii = asciiDiv.textContent;

            // EXPANDED eye blink characters - more variety
            const eyeChars = ['‚óè', '‚óâ', '‚óé', '‚óã', '‚óØ', '‚¨°', '‚ñ†', '‚óÜ', '‚ñ£', '‚äô', '‚óê', '‚óë', '‚óî', '‚óï', '‚äó', '‚äï', '‚óà', '‚óò', '‚Ä¢', '‚àò', '‚äö'];
            const blinkChars = ['-', '‚Äæ', '¬Ø', '_', '~', 'Àú', '‚ÅÉ'];

            // EXPANDED limb swaps - MANY more variations for dramatic effect
            const limbSwapSets = [
                // Diagonal limbs
                {from: '‚ï±', to: ['‚ï≤', '‚àï', '‚üã', '‚üç', '/', '\\']},
                {from: '‚ï≤', to: ['‚ï±', '‚àñ', '‚üç', '‚üã', '\\', '/']},
                {from: '‚àï', to: ['‚àñ', '‚ï±', '‚ï≤', '/', '\\']},
                {from: '‚àñ', to: ['‚àï', '‚ï≤', '‚ï±', '\\', '/']},

                // Vertical limbs (legs)
                {from: '‚îÇ', to: ['‚îÉ', '‚ïë', '‚îÜ', '‚îá', '‚îä', '‚îã', '‚ïé', '‚ïè', '|', '«Ä', '‚µè']},
                {from: '‚îÉ', to: ['‚îÇ', '‚ïë', '‚îÜ', '‚îä', '|', '«Ä']},
                {from: '‚ïë', to: ['‚îÇ', '‚îÉ', '|']},

                // Endpoints (feet, hands)
                {from: '‚ñº', to: ['‚ñΩ', '‚ñø', '‚àá', 'v', 'V', '‚åÑ']},
                {from: '‚ñΩ', to: ['‚ñº', '‚ñø', 'v', 'V']},
                {from: '‚ñ≤', to: ['‚ñ≥', '‚ñ¥', '‚àÜ', '^', 'Œõ', '‚åÉ']},
                {from: '‚ñ≥', to: ['‚ñ≤', '‚ñ¥', '^', 'Œõ']},

                // Horizontal limbs (arms)
                {from: '‚î§', to: ['‚îú', '‚îº', '‚î¨', '‚î¥', '‚ï™', '‚ï´', '‚îø', '+']},
                {from: '‚îú', to: ['‚î§', '‚îº', '‚î¨', '‚î¥', '+']},
                {from: '‚ïÆ', to: ['‚ï≠', '‚ïØ', '‚ï∞', '‚îê', '‚îå', '‚îò', '‚îî']},
                {from: '‚ï≠', to: ['‚ïÆ', '‚ï∞', '‚ïØ', '‚îå', '‚îê']},
                {from: '‚ïØ', to: ['‚ï∞', '‚ïÆ', '‚ï≠', '‚îò', '‚îî']},
                {from: '‚ï∞', to: ['‚ïØ', '‚ï≠', '‚ïÆ', '‚îî', '‚îò']},

                // Additional body parts
                {from: '‚ïø', to: ['‚ïΩ', '‚îÇ', '‚îÉ', '|']},
                {from: '‚ïΩ', to: ['‚ïø', '‚îÇ', '‚îÉ', '|']},
                {from: '‚ïº', to: ['‚ïæ', '‚îÄ', '‚îÅ', '-']},
                {from: '‚ïæ', to: ['‚ïº', '‚îÄ', '‚îÅ', '-']}
            ];

            // EXPANDED antenna swaps - more dramatic
            const antennaSwapSets = [
                {from: '‚óè', to: ['‚óã', '‚óâ', '‚óé', '‚äô', '‚óØ', '‚òâ', '‚äö', '‚óå']},
                {from: '‚óã', to: ['‚óè', '‚óé', '‚óâ', '‚óØ', '‚äô']},
                {from: '‚óâ', to: ['‚óé', '‚óè', '‚óã', '‚äô', '‚äö']},
                {from: '‚óé', to: ['‚óâ', '‚óè', '‚óã', '‚äô']},
                {from: '‚ú¶', to: ['‚úß', '‚ú∂', '‚ú∑', '‚ú∏', '‚úπ', '‚ú∫', '‚úª', '‚úº', '*', 'Ôºä', '‚Åé']},
                {from: '‚úß', to: ['‚ú¶', '‚ú∂', '‚ú∑', '‚ú∏', '*']},
                {from: '‚òÖ', to: ['‚òÜ', '‚ú™', '‚ú´', '‚ú¨', '‚ú≠', '‚úÆ', '‚úØ', '‚ú∞']},
                {from: '‚òÜ', to: ['‚òÖ', '‚ú™', '‚ú´', '‚ú¨']},
                {from: '‚ï±', to: ['‚ï≤', '‚àï', '/', '\\']},
                {from: '‚ï≤', to: ['‚ï±', '‚àñ', '\\', '/']},
                {from: '‚àï', to: ['‚àñ', '‚ï±', '‚ï≤', '/', '\\']},
                {from: '‚àñ', to: ['‚àï', '‚ï≤', '‚ï±', '\\', '/']}
            ];

            // BLINK - random blink character each time
            function blink() {
                let ascii = asciiDiv.textContent;
                const blinkChar = blinkChars[Math.floor(Math.random() * blinkChars.length)];

                eyeChars.forEach(char => {
                    ascii = ascii.split(char).join(blinkChar);
                });
                asciiDiv.textContent = ascii;

                setTimeout(() => {
                    asciiDiv.textContent = currentAscii;
                    if (dna.blinkSpeed) setTimeout(blink, dna.blinkSpeed);
                }, 80 + Math.random() * 60); // Random blink duration 80-140ms
            }

            // LIMB SWAP - RANDOM selection from multiple options
            function swapLimbs() {
                let ascii = currentAscii;

                // Randomly pick which limbs to animate this cycle
                limbSwapSets.forEach(swapSet => {
                    if (Math.random() < 0.7) { // 70% chance each limb type animates
                        const randomReplacement = swapSet.to[Math.floor(Math.random() * swapSet.to.length)];
                        ascii = ascii.split(swapSet.from).join(randomReplacement);
                    }
                });

                currentAscii = ascii;
                asciiDiv.textContent = currentAscii;

                if (dna.limbSpeed) setTimeout(swapLimbs, dna.limbSpeed);
            }

            // ANTENNA SWAP - RANDOM and more dramatic
            function swapAntennas() {
                let lines = currentAscii.split('\n');
                const topLineCount = Math.floor(lines.length * 0.35); // Top 35% for antennas

                for (let i = 0; i < topLineCount; i++) {
                    let line = lines[i];

                    // Randomly swap antenna characters
                    antennaSwapSets.forEach(swapSet => {
                        if (Math.random() < 0.6) { // 60% chance each antenna char animates
                            const randomReplacement = swapSet.to[Math.floor(Math.random() * swapSet.to.length)];
                            line = line.split(swapSet.from).join(randomReplacement);
                        }
                    });

                    lines[i] = line;
                }

                currentAscii = lines.join('\n');
                asciiDiv.textContent = currentAscii;

                if (dna.antennaSpeed) setTimeout(swapAntennas, dna.antennaSpeed);
            }

            // Start animations with random initial delays
            if (dna.blinkSpeed) setTimeout(blink, dna.blinkDelay || 0);
            if (dna.limbSpeed) setTimeout(swapLimbs, dna.limbDelay || 0);
            if (dna.antennaSpeed) setTimeout(swapAntennas, dna.antennaDelay || 0);
        }

        function generateChildren(spreaderData, count = 3) {
            for (let i = 0; i < count; i++) {
                // CRITICAL: Pass sibling index to ensure diversity between siblings
                // Each sibling gets different mutation patterns based on their index
                const child = generateASCIICreature(16, spreaderData.family, null, spreaderData.dna, i);
                child.parentId = spreaderData.id;
                familyData[spreaderData.family].children.push(child);
            }
            displayFamily(currentFamily);
            updateStats();
        }

        function displayFamily(family) {
            document.getElementById('spreaders').innerHTML = '';
            document.getElementById('children').innerHTML = '';

            // Display spreaders
            familyData[family].spreaders.forEach(spreader => {
                const card = document.createElement('div');
                card.className = 'spreader-card';
                card.dataset.spreaderId = spreader.id;
                card.onclick = () => generateChildren(spreader);

                // Hover effect to highlight children
                card.onmouseenter = () => {
                    document.querySelectorAll(`.child-card[data-parent-id="${spreader.id}"]`).forEach(c => {
                        c.classList.add('highlight-parent');
                    });
                };
                card.onmouseleave = () => {
                    document.querySelectorAll('.child-card').forEach(c => {
                        c.classList.remove('highlight-parent');
                    });
                };

                const asciiDiv = document.createElement('div');
                asciiDiv.className = `ascii-display spreader-ascii bg-${family}`;
                asciiDiv.textContent = spreader.ascii;
                applyAnimations(asciiDiv, spreader);

                const info = document.createElement('div');
                info.className = 'creature-info';
                info.textContent = `ID: ${spreader.id.substr(0,6)} | Seed: ${Math.floor(spreader.seed % 1000000)} | CLICK TO BREED`;

                // DNA traits display
                const traitsDiv = document.createElement('div');
                traitsDiv.className = 'dna-traits';

                // Species icon mapping
                const speciesIcons = {
                    'insectoid': '‚¨°',
                    'reptilian': '‚ñì',
                    'mammalian': '‚ñë',
                    'viral': '‚óé',
                    'alien': '‚Äª',
                    'aquatic': '‚âã',
                    'skeletal': '‚óØ'
                };
                const speciesIcon = speciesIcons[spreader.traits.species] || '‚óè';

                const stageEmoji = {calm: 'üòå', nervous: 'üò∞', adhd: 'ü§™', crazy: 'ü§Ø'}[spreader.dna.animationStage] || '‚óè';

                traitsDiv.innerHTML = `
                    <div class="dna-trait species-trait">${speciesIcon} ${spreader.traits.species.toUpperCase()}</div>
                    <div class="dna-trait species-trait">${stageEmoji} ${spreader.dna.animationStage.toUpperCase()}</div>
                    <div class="dna-trait">Body: ${spreader.dna.bodyType}</div>
                    <div class="dna-trait">Fill: ${spreader.dna.bodyChar}</div>
                    <div class="dna-trait">Eyes: ${spreader.dna.eyeChar}</div>
                    <div class="dna-trait">Arms: ${spreader.dna.armStyle}</div>
                    <div class="dna-trait">Legs: ${spreader.dna.legStyle}</div>
                    ${spreader.dna.hatType !== 'none' ? `<div class="dna-trait">Hat: ${spreader.dna.hatType}</div>` : ''}
                    ${spreader.dna.hasCigarette ? `<div class="dna-trait">üö¨</div>` : ''}
                `;

                // Zoom button
                const zoomBtn = document.createElement('button');
                zoomBtn.className = 'zoom-btn';
                zoomBtn.textContent = 'üîç ZOOM';
                zoomBtn.onclick = (e) => {
                    e.stopPropagation();
                    openZoom(spreader, false);
                };

                card.appendChild(asciiDiv);
                card.appendChild(info);
                card.appendChild(traitsDiv);
                card.appendChild(zoomBtn);
                document.getElementById('spreaders').appendChild(card);
            });

            // Display children
            familyData[family].children.forEach(child => {
                const card = document.createElement('div');
                card.className = 'child-card';
                card.dataset.parentId = child.parentId;

                // Find parent
                const parent = familyData[family].spreaders.find(s => s.id === child.parentId);

                const asciiDiv = document.createElement('div');
                asciiDiv.className = `ascii-display child-ascii bg-${family}`;
                asciiDiv.textContent = child.ascii;
                applyAnimations(asciiDiv, child);

                // Click to zoom
                card.onclick = () => {
                    openZoom(child, true, parent);
                };

                // Hover on card to highlight parent
                card.onmouseenter = () => {
                    const parentCard = document.querySelector(`.spreader-card[data-spreader-id="${child.parentId}"]`);
                    if (parentCard) {
                        parentCard.classList.add('selected');
                    }
                };
                card.onmouseleave = () => {
                    document.querySelectorAll('.spreader-card').forEach(c => {
                        c.classList.remove('selected');
                    });
                };

                // Parent link
                const parentLink = document.createElement('div');
                parentLink.className = 'parent-link';
                parentLink.textContent = `‚Üë ${child.parentId.substr(0,6)}`;

                const info = document.createElement('div');
                info.className = 'creature-info';
                info.textContent = `ID: ${child.id.substr(0,6)}`;

                // DNA traits with inheritance indicators
                const traitsDiv = document.createElement('div');
                traitsDiv.className = 'dna-traits';

                if (parent) {
                    // Species icon mapping
                    const speciesIcons = {
                        'insectoid': '‚¨°',
                        'reptilian': '‚ñì',
                        'mammalian': '‚ñë',
                        'viral': '‚óé',
                        'alien': '‚Äª',
                        'aquatic': '‚âã',
                        'skeletal': '‚óØ'
                    };
                    const speciesIcon = speciesIcons[child.traits.species] || '‚óè';
                    const stageEmoji = {calm: 'üòå', nervous: 'üò∞', adhd: 'ü§™', crazy: 'ü§Ø'}[child.dna.animationStage] || '‚óè';

                    // Compare DNA and show inheritance
                    const speciesMatch = child.traits.species === parent.traits.species;
                    const stageMatch = child.dna.animationStage === parent.dna.animationStage;
                    const bodyMatch = child.dna.bodyType === parent.dna.bodyType;
                    const bodyCharMatch = child.dna.bodyChar === parent.dna.bodyChar;
                    const eyeMatch = child.dna.eyeChar === parent.dna.eyeChar;
                    const armMatch = child.dna.armStyle === parent.dna.armStyle;
                    const legMatch = child.dna.legStyle === parent.dna.legStyle;
                    const hatMatch = child.dna.hatType === parent.dna.hatType;

                    traitsDiv.innerHTML = `
                        <div class="dna-trait ${speciesMatch ? 'inherited' : 'mutated'}">${speciesIcon} ${child.traits.species.toUpperCase().substr(0,4)}</div>
                        <div class="dna-trait ${stageMatch ? 'inherited' : 'mutated'}">${stageEmoji} ${child.dna.animationStage.toUpperCase().substr(0,4)}</div>
                        <div class="dna-trait ${bodyMatch ? 'inherited' : 'mutated'}">Body: ${child.dna.bodyType.substr(0,4)}</div>
                        <div class="dna-trait ${bodyCharMatch ? 'inherited' : 'mutated'}">Fill: ${child.dna.bodyChar}</div>
                        <div class="dna-trait ${eyeMatch ? 'inherited' : 'mutated'}">Eye: ${child.dna.eyeChar}</div>
                        <div class="dna-trait ${armMatch ? 'inherited' : 'mutated'}">Arm: ${child.dna.armStyle.substr(0,3)}</div>
                        <div class="dna-trait ${legMatch ? 'inherited' : 'mutated'}">Leg: ${child.dna.legStyle.substr(0,3)}</div>
                        ${child.dna.hatType !== 'none' ? `<div class="dna-trait ${hatMatch ? 'inherited' : 'mutated'}">Hat: ${child.dna.hatType.substr(0,3)}</div>` : ''}
                        ${child.dna.hasCigarette ? `<div class="dna-trait mutated">üö¨</div>` : ''}
                    `;
                } else {
                    traitsDiv.innerHTML = `<div style="color: #cc0000;">Parent not found</div>`;
                }

                card.appendChild(parentLink);
                card.appendChild(asciiDiv);
                card.appendChild(info);
                card.appendChild(traitsDiv);
                document.getElementById('children').appendChild(card);
            });
        }

        function clearFamily() {
            familyData[currentFamily] = { spreaders: [], children: [] };
            displayFamily(currentFamily);
            updateStats();
        }

        function clearAll() {
            Object.keys(families).forEach(key => {
                familyData[key] = { spreaders: [], children: [] };
            });
            displayFamily(currentFamily);
            updateStats();
        }

        function updateStats() {
            let activeFamilies = 0;
            let totalSpreaders = 0;
            let totalChildren = 0;

            Object.keys(familyData).forEach(key => {
                if (familyData[key].spreaders.length > 0) activeFamilies++;
                totalSpreaders += familyData[key].spreaders.length;
                totalChildren += familyData[key].children.length;
            });

            document.getElementById('activeFamilies').textContent = activeFamilies;
            document.getElementById('totalSpreaders').textContent = totalSpreaders;
            document.getElementById('totalChildren').textContent = totalChildren;
        }

        function exportData() {
            const data = {
                protocol: 'ASCII_PROTOCOLITE_VI',
                version: '6.0',
                timestamp: new Date().toISOString(),
                families: {}
            };

            Object.keys(familyData).forEach(key => {
                if (familyData[key].spreaders.length > 0) {
                    data.families[key] = {
                        spreaders: familyData[key].spreaders.map(s => ({
                            id: s.id,
                            seed: s.seed,
                            ascii: s.ascii,
                            dna: s.dna,
                            traits: s.traits
                        })),
                        children: familyData[key].children.map(c => ({
                            id: c.id,
                            parentId: c.parentId,
                            seed: c.seed,
                            ascii: c.ascii,
                            dna: c.dna,
                            traits: c.traits
                        }))
                    };
                }
            });

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ascii_protocolite_v5_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Zoom Modal Functions
        function openZoom(creature, isChild = false, parent = null) {
            const modal = document.getElementById('zoomModal');
            const title = document.getElementById('zoomTitle');
            const id = document.getElementById('zoomId');
            const ascii = document.getElementById('zoomAscii');
            const dnaGrid = document.getElementById('zoomDnaGrid');

            // Set title and ID
            title.textContent = isChild ? 'CHILD' : 'SPREADER';
            id.textContent = `ID: ${creature.id}`;

            // Set ASCII art with colored background
            ascii.textContent = creature.ascii;
            ascii.className = `zoom-ascii bg-${creature.family}`;

            // Apply animations to zoomed creature
            applyAnimations(ascii, creature);

            // Build DNA traits grid
            let dnaHtml = '';

            if (isChild && parent) {
                // Show inheritance comparison for children
                const speciesMatch = creature.traits.species === parent.traits.species;
                const bodyMatch = creature.dna.bodyType === parent.dna.bodyType;
                const bodyCharMatch = creature.dna.bodyChar === parent.dna.bodyChar;
                const eyeMatch = creature.dna.eyeChar === parent.dna.eyeChar;
                const armMatch = creature.dna.armStyle === parent.dna.armStyle;
                const legMatch = creature.dna.legStyle === parent.dna.legStyle;
                const hatMatch = creature.dna.hatType === parent.dna.hatType;

                // Species icon mapping
                const speciesIcons = {
                    'insectoid': '‚¨°',
                    'reptilian': '‚ñì',
                    'mammalian': '‚ñë',
                    'viral': '‚óé',
                    'alien': '‚Äª',
                    'aquatic': '‚âã',
                    'skeletal': '‚óØ'
                };
                const speciesIcon = speciesIcons[creature.traits.species] || '‚óè';

                dnaHtml = `
                    <div class="zoom-dna-item ${speciesMatch ? 'inherited' : 'mutated'}" style="grid-column: 1 / -1; font-size: 14px; font-weight: 300;">
                        <div class="zoom-dna-label">SPECIES ${speciesMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${speciesIcon} ${creature.traits.species.toUpperCase()}</div>
                    </div>
                    <div class="zoom-dna-item ${bodyMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Body Type ${bodyMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.bodyType}</div>
                    </div>
                    <div class="zoom-dna-item ${bodyCharMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Body Fill ${bodyCharMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.bodyChar}</div>
                    </div>
                    <div class="zoom-dna-item ${eyeMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Eye Character ${eyeMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.eyeChar}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Eye Size</div>
                        <div class="zoom-dna-value">${creature.dna.eyeSize || 'normal'}</div>
                    </div>
                    <div class="zoom-dna-item ${armMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Arm Style ${armMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.armStyle}</div>
                    </div>
                    <div class="zoom-dna-item ${legMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Leg Style ${legMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.legStyle}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Antenna Tip</div>
                        <div class="zoom-dna-value">${creature.dna.antennaTip}</div>
                    </div>
                    ${creature.dna.hatType !== 'none' ? `
                    <div class="zoom-dna-item ${hatMatch ? 'inherited' : 'mutated'}">
                        <div class="zoom-dna-label">Hat ${hatMatch ? '‚úì Inherited' : '‚úó Mutated'}</div>
                        <div class="zoom-dna-value">${creature.dna.hatType}</div>
                    </div>
                    ` : ''}
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Cigarette</div>
                        <div class="zoom-dna-value">${creature.dna.hasCigarette ? 'Yes üö¨' : 'No'}</div>
                    </div>
                    <div class="zoom-dna-item inherited" style="grid-column: 1 / -1;">
                        <div class="zoom-dna-label">Parent ID</div>
                        <div class="zoom-dna-value">${creature.parentId}</div>
                    </div>
                `;
            } else {
                // Show DNA for spreaders
                // Species icon mapping
                const speciesIcons = {
                    'insectoid': '‚¨°',
                    'reptilian': '‚ñì',
                    'mammalian': '‚ñë',
                    'viral': '‚óé',
                    'alien': '‚Äª',
                    'aquatic': '‚âã',
                    'skeletal': '‚óØ'
                };
                const speciesIcon = speciesIcons[creature.traits.species] || '‚óè';

                dnaHtml = `
                    <div class="zoom-dna-item" style="grid-column: 1 / -1; font-size: 14px; font-weight: 300;">
                        <div class="zoom-dna-label">SPECIES</div>
                        <div class="zoom-dna-value">${speciesIcon} ${creature.traits.species.toUpperCase()}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Body Type</div>
                        <div class="zoom-dna-value">${creature.dna.bodyType}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Body Fill</div>
                        <div class="zoom-dna-value">${creature.dna.bodyChar}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Eye Character</div>
                        <div class="zoom-dna-value">${creature.dna.eyeChar}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Eye Size</div>
                        <div class="zoom-dna-value">${creature.dna.eyeSize || 'normal'}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Arm Style</div>
                        <div class="zoom-dna-value">${creature.dna.armStyle}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Leg Style</div>
                        <div class="zoom-dna-value">${creature.dna.legStyle}</div>
                    </div>
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Antenna Tip</div>
                        <div class="zoom-dna-value">${creature.dna.antennaTip}</div>
                    </div>
                    ${creature.dna.hatType !== 'none' ? `
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Hat</div>
                        <div class="zoom-dna-value">${creature.dna.hatType}</div>
                    </div>
                    ` : ''}
                    <div class="zoom-dna-item">
                        <div class="zoom-dna-label">Cigarette</div>
                        <div class="zoom-dna-value">${creature.dna.hasCigarette ? 'Yes üö¨' : 'No'}</div>
                    </div>
                    <div class="zoom-dna-item" style="grid-column: 1 / -1;">
                        <div class="zoom-dna-label">Seed</div>
                        <div class="zoom-dna-value">${creature.seed}</div>
                    </div>
                `;
            }

            dnaGrid.innerHTML = dnaHtml;

            // Show modal
            modal.classList.add('active');

            // Add escape key listener
            document.addEventListener('keydown', handleEscapeKey);
        }

        function closeZoom(event) {
            const modal = document.getElementById('zoomModal');
            modal.classList.remove('active');
            document.removeEventListener('keydown', handleEscapeKey);
        }

        function handleEscapeKey(event) {
            if (event.key === 'Escape') {
                closeZoom();
            }
        }

        // Initialize
        selectFamily('red');
        updateStats();
    </script>
</body>
</html>
