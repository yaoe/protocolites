<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protolite Generator V5 - Fusion Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            color: #0f0;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .container {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 8px;
            padding: 30px;
            max-width: 1600px;
            width: 100%;
            box-sizing: border-box;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #0f0;
            margin-bottom: 20px;
            font-size: 28px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 12px 24px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            font-weight: bold;
        }

        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            transform: scale(1.05);
        }

        select {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 10px;
            font-family: 'Courier New', monospace;
        }

        .chaos-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px auto;
            justify-content: center;
        }

        .chaos-slider {
            width: 200px;
            accent-color: #0f0;
        }

        .creators-section {
            margin-bottom: 40px;
        }

        .section-title {
            color: #0f0;
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            font-weight: bold;
        }

        .creators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .creator-container {
            border: 2px solid rgba(0, 255, 0, 0.5);
            background: rgba(5, 5, 5, 0.8);
            padding: 15px;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .creator-container:hover {
            border-color: #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .creator-dual {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .creator-item {
            text-align: center;
        }

        .creator-canvas, .qr-canvas {
            margin: 0 auto 10px;
            background: #000;
            border: 2px solid #0f0;
            cursor: pointer;
            display: block;
            transition: all 0.3s;
        }

        .creator-canvas:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.5);
        }

        .qr-canvas {
            border-color: #ff0;
        }

        .qr-canvas:hover {
            box-shadow: 0 0 25px rgba(255, 255, 0, 0.5);
        }

        .descendants-section {
            border-top: 2px solid rgba(0, 255, 0, 0.3);
            padding-top: 30px;
        }

        .descendants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .descendant-card {
            text-align: center;
            padding: 10px;
            border: 2px solid rgba(255, 255, 0, 0.5);
            background: rgba(5, 5, 0, 0.5);
            border-radius: 6px;
            animation: spawn 0.5s ease-out;
        }

        @keyframes spawn {
            from {
                opacity: 0;
                transform: scale(0.5) rotate(180deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        .descendant-canvas {
            margin: 0 auto;
            background: #000;
            border: 2px solid #ff0;
            display: block;
            transition: all 0.3s;
        }

        .descendant-canvas:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
        }

        .id-label {
            margin-top: 10px;
            font-size: 11px;
            color: #0f0;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .descendant-label {
            color: #ff0;
        }

        .stats {
            text-align: center;
            margin: 20px 0;
            font-size: 14px;
            color: #0f0;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .dna-display {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            word-break: break-all;
        }

        .item-label {
            font-size: 11px;
            color: #0f0;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .qr-label {
            color: #ff0;
        }

        .download-btn {
            font-size: 10px;
            padding: 5px 10px;
            margin-top: 5px;
            border: 1px solid #0f0;
            background: #000;
            color: #0f0;
        }

        .download-btn:hover {
            background: #0f0;
            color: #000;
        }

        .mutation-badge {
            display: inline-block;
            background: #ff00ff;
            color: #000;
            padding: 2px 6px;
            font-size: 9px;
            border-radius: 4px;
            margin-left: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§¬ PROTOLITE FUSION STUDIO V5 ðŸ§¬</h1>
        
        <div class="stats" id="stats">
            CREATORS: 0 | QR GALLERIES: 0 | DESCENDANTS: 0 | CHAOS LEVEL: 50%
        </div>
        
        <div class="chaos-control">
            <label for="chaosSlider">CHAOS:</label>
            <input type="range" id="chaosSlider" class="chaos-slider" min="0" max="100" value="50">
            <span id="chaosValue">50%</span>
        </div>
        
        <div class="controls">
            <select id="parentSize">
                <option value="24">PARENT: 24x24</option>
                <option value="36">PARENT: 36x36</option>
            </select>
            <select id="childSize">
                <option value="12">CHILD: 12x12</option>
                <option value="16" selected>CHILD: 16x16</option>
            </select>
            <input type="text" id="mintUrl" placeholder="GALLERY URL (e.g., https://uba.art/gallery)" value="https://uba.art/gallery/" style="background: #000; color: #0f0; border: 2px solid #0f0; padding: 10px; font-family: 'Courier New', monospace; width: 300px;">
            <button onclick="generateCreators()">SPAWN CREATORS</button>
            <button onclick="clearAll()">PURGE COLONY</button>
            <button onclick="exportAll()">EXPORT DNA</button>
        </div>

        <div class="creators-section">
            <div class="section-title" id="creatorTitle">CREATOR ORGANISMS WITH QR GALLERIES</div>
            <div class="creators-grid" id="creators"></div>
        </div>

        <div class="descendants-section">
            <div class="section-title" id="descendantTitle">DESCENDANT MUTATIONS</div>
            <div class="descendants-grid" id="descendants"></div>
        </div>
    </div>

    <script>
        let creatorCount = 0;
        let descendantCount = 0;
        let creatorData = [];
        let chaosLevel = 50;

        // Creature type names from V0
        const creatureTypes = [
            'PIXEL-WEAVER', 'BYTE-DANCER', 'CODE-SHIFTER', 'DATA-MORPH', 
            'GLITCH-SPAWN', 'NEON-PULSE', 'CYBER-SPORE', 'GRID-WALKER',
            'MATRIX-BLOOM', 'QUANTUM-SEED', 'VOID-DWELLER', 'PLASMA-MITE'
        ];

        // Update chaos level
        document.getElementById('chaosSlider').addEventListener('input', (e) => {
            chaosLevel = parseInt(e.target.value);
            document.getElementById('chaosValue').textContent = chaosLevel + '%';
            updateStats();
        });

        function hashCode(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateDNA() {
            return Math.random().toString(36).substring(2, 10).toUpperCase();
        }

        function dnaToColors(dna) {
            const hash = hashCode(dna);
            const hue1 = (hash % 360);
            const hue2 = ((hash >> 8) % 360);
            const hue3 = ((hash >> 16) % 360);
            
            // Enhanced color palette from V0
            const saturation = 80 + (hash % 20); // 80-100%
            const lightness = 45 + (hash % 20); // 45-65%
            
            return {
                primary: `hsl(${hue1}, ${saturation}%, ${lightness}%)`,
                secondary: `hsl(${hue2}, ${saturation}%, ${lightness}%)`,
                accent: `hsl(${hue3}, 100%, 50%)`,
                glow: `hsl(${(hue1 + 180) % 360}, 100%, 60%)` // Complementary glow
            };
        }

        function generateProtolite(dna, size = 24, parentData = null) {
            const canvas = document.createElement('canvas');
            const pixelSize = 6;
            canvas.width = size * pixelSize;
            canvas.height = size * pixelSize;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            let colors, dominantColor, creatureType;
            
            if (parentData && parentData.dominantColor) {
                dominantColor = parentData.dominantColor;
                colors = {
                    primary: dominantColor,
                    secondary: dnaToColors(dna).secondary,
                    accent: dnaToColors(dna).accent,
                    glow: dnaToColors(dna).glow
                };
                
                // Mutation chance based on chaos level
                if (Math.random() * 100 < chaosLevel * 0.3) {
                    const hueShift = (Math.random() - 0.5) * chaosLevel;
                    const match = dominantColor.match(/hsl\((\d+),/);
                    if (match) {
                        const hue = (parseInt(match[1]) + hueShift + 360) % 360;
                        colors.primary = `hsl(${hue}, 100%, 50%)`;
                    }
                }
                
                // Inherit or mutate creature type
                creatureType = parentData.creatureType;
                if (Math.random() * 100 < chaosLevel * 0.2) {
                    creatureType = creatureTypes[Math.floor(Math.random() * creatureTypes.length)];
                }
            } else {
                colors = dnaToColors(dna);
                creatureType = creatureTypes[Math.floor(Math.random() * creatureTypes.length)];
            }
            
            const seed = hashCode(dna);
            
            // Black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const halfWidth = Math.floor(size / 2);
            const pattern = [];
            const colorCount = { primary: 0, secondary: 0, accent: 0 };

            // Initialize pattern array
            for (let y = 0; y < size; y++) {
                pattern[y] = new Array(size).fill(null);
            }

            // Body generation with chaos influence
            const bodyType = seed % 7; // More body types
            const asymmetryChance = chaosLevel / 200; // 0-50% chance based on chaos
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < halfWidth; x++) {
                    const rand = seededRandom(seed + y * size + x);
                    const rand2 = seededRandom(seed + y * size + x + 1000);
                    const rand3 = seededRandom(seed + y * size + x + 2000);
                    
                    const centerY = size / 2;
                    const distFromCenterY = Math.abs(y - centerY);
                    const distFromCenterX = Math.abs(x - halfWidth);
                    const distFromCenter = Math.sqrt(distFromCenterX * distFromCenterX + distFromCenterY * distFromCenterY);
                    
                    let bodyChance = 0;
                    
                    // Enhanced body shapes combining all versions
                    switch(bodyType) {
                        case 0: // Blob (kawaii style)
                            const roundness = 1 - (distFromCenter / (size * 0.35));
                            bodyChance = roundness > 0 ? Math.pow(roundness, 0.7) : 0;
                            break;
                        case 1: // Spiky (V0 style)
                            bodyChance = 0.8 - (distFromCenter * 0.06);
                            if (rand3 < chaosLevel / 100) { // Add spikes based on chaos
                                bodyChance += 0.3;
                            }
                            break;
                        case 2: // Bean shape
                            const beanDist = Math.sqrt(Math.pow(distFromCenterX / 0.8, 2) + Math.pow(distFromCenterY / 1.2, 2));
                            bodyChance = 0.95 - (beanDist / (size * 0.4));
                            break;
                        case 3: // Diamond with extensions
                            const diamondDist = Math.abs(x - halfWidth) + Math.abs(y - centerY);
                            bodyChance = 0.8 - (diamondDist / (size * 0.5));
                            // Add extensions based on creature type
                            if (creatureType.includes('SPIKE') || creatureType.includes('MORPH')) {
                                if ((x === 0 || x === halfWidth - 1) && rand3 < 0.7) {
                                    bodyChance += 0.4;
                                }
                            }
                            break;
                        case 4: // Organic/flowing
                            const flowMod = Math.sin(y * 0.3) * 0.2 + Math.cos(x * 0.4) * 0.15;
                            bodyChance = 0.75 - (distFromCenter / (size * 0.4)) + flowMod;
                            break;
                        case 5: // Fragmented
                            bodyChance = 0.7 - (distFromCenter / (size * 0.45));
                            if (rand3 < chaosLevel / 150) { // Gaps based on chaos
                                bodyChance = 0;
                            }
                            break;
                        case 6: // Crystalline
                            const crystalDist = Math.max(Math.abs(x - halfWidth), Math.abs(y - centerY));
                            bodyChance = 0.85 - (crystalDist / (size * 0.35));
                            break;
                    }
                    
                    // Dense center with chaos influence
                    if (distFromCenter < size * 0.2) {
                        bodyChance += 0.4 + (chaosLevel / 200);
                    }
                    
                    if (rand < bodyChance && bodyChance > 0) {
                        // Color distribution influenced by chaos
                        const colorThreshold1 = 0.7 - (chaosLevel / 300);
                        const colorThreshold2 = 0.85 - (chaosLevel / 400);
                        
                        if (rand2 < colorThreshold1) {
                            pattern[y][x] = colors.primary;
                            colorCount.primary += 2;
                        } else if (rand2 < colorThreshold2) {
                            pattern[y][x] = colors.secondary;
                            colorCount.secondary += 2;
                        } else {
                            pattern[y][x] = colors.accent;
                            colorCount.accent += 2;
                        }
                    }
                }
            }

            // Mirror with potential asymmetry
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < halfWidth; x++) {
                    const mirrorX = size - 1 - x;
                    if (seededRandom(seed + y * 1000 + x * 100) > asymmetryChance) {
                        pattern[y][mirrorX] = pattern[y][x];
                    } else {
                        // Asymmetric mutation
                        if (pattern[y][x] && seededRandom(seed + y * 2000 + x * 200) < 0.5) {
                            pattern[y][mirrorX] = colors.glow;
                        }
                    }
                }
            }

            // Add chaotic details
            const detailSeed = seed + 5000;
            const detailCount = Math.floor(size * (0.2 + chaosLevel / 200));
            
            for (let i = 0; i < detailCount; i++) {
                const x = Math.floor(seededRandom(detailSeed + i * 2) * size);
                const y = Math.floor(seededRandom(detailSeed + i * 2 + 1) * size);
                
                if (pattern[y] && seededRandom(detailSeed + i * 3) < chaosLevel / 100) {
                    // Wild mutations
                    pattern[y][x] = colors.glow;
                }
            }

            // Add spikes/extensions based on creature type and chaos
            if (chaosLevel > 30 && (creatureType.includes('SPIKE') || creatureType.includes('MORPH'))) {
                const spikeCount = Math.floor(8 + chaosLevel / 10);
                for (let i = 0; i < spikeCount; i++) {
                    const angle = (i / spikeCount) * Math.PI * 2;
                    const distance = (size / 3) + seededRandom(seed + i * 100) * (size / 4);
                    const x = Math.round(size / 2 + Math.cos(angle) * distance);
                    const y = Math.round(size / 2 + Math.sin(angle) * distance);
                    
                    if (x >= 0 && x < size && y >= 0 && y < size) {
                        pattern[y][x] = colors.accent;
                        // Extend spikes
                        for (let j = 1; j < 3; j++) {
                            const extX = Math.round(size / 2 + Math.cos(angle) * (distance + j));
                            const extY = Math.round(size / 2 + Math.sin(angle) * (distance + j));
                            if (extX >= 0 && extX < size && extY >= 0 && extY < size) {
                                pattern[extY][extX] = colors.glow;
                            }
                        }
                    }
                }
            }

            // Add breed core marker
            const coreSize = Math.max(2, Math.floor(size * 0.15));
            const coreStart = Math.floor((size - coreSize) / 2);
            for (let y = coreStart; y < coreStart + coreSize; y++) {
                for (let x = coreStart; x < coreStart + coreSize; x++) {
                    const coreDistX = Math.abs(x - size/2);
                    const coreDistY = Math.abs(y - size/2);
                    if (coreDistX + coreDistY < coreSize * 0.7) {
                        pattern[y][x] = colors.primary;
                        colorCount.primary += 1;
                    }
                }
            }

            // Draw pattern
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (pattern[y][x]) {
                        ctx.fillStyle = pattern[y][x];
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }

            // Determine dominant color
            if (!parentData) {
                const maxCount = Math.max(colorCount.primary, colorCount.secondary, colorCount.accent);
                if (colorCount.primary === maxCount) {
                    dominantColor = colors.primary;
                } else if (colorCount.secondary === maxCount) {
                    dominantColor = colors.secondary;
                } else {
                    dominantColor = colors.accent;
                }
            } else {
                dominantColor = colors.primary;
            }

            // Enhanced eye system combining all versions
            const eyeSeed = seed + 1000;
            const eyeType = (eyeSeed + Math.floor(chaosLevel / 20)) % 10;
            
            const eyeY = Math.floor(size * 0.3);
            const eyeSpacing = Math.floor(size * 0.25);
            const centerX = Math.floor(size / 2);
            
            // Eye colors
            const eyeMatch = colors.primary.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            let eyeWhite = '#fff';
            let eyePupil = '#000';
            let eyeGlow = colors.glow;
            
            if (eyeMatch) {
                const h = parseInt(eyeMatch[1]);
                const s = parseInt(eyeMatch[2]);
                eyeWhite = `hsl(${h}, ${s * 0.3}%, 90%)`;
                eyePupil = `hsl(${h}, ${s}%, 20%)`;
            }
            
            switch(eyeType) {
                case 0: // Single pixel (classic)
                    ctx.fillStyle = eyeGlow;
                    ctx.fillRect((centerX - eyeSpacing) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing - 1) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    break;
                    
                case 1: // V0 style multi-pixel with glow
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (Math.abs(dx) + Math.abs(dy) <= 1) {
                                ctx.fillStyle = '#ff0000';
                                ctx.fillRect((centerX - eyeSpacing + dx) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                                ctx.fillRect((centerX + eyeSpacing + dx - 1) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                    // White center
                    ctx.fillStyle = '#fff';
                    ctx.fillRect((centerX - eyeSpacing) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing - 1) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    break;
                    
                case 2: // Kawaii sparkle
                    // Base eye
                    ctx.fillStyle = eyeWhite;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            ctx.fillRect((centerX - eyeSpacing + dx) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                            ctx.fillRect((centerX + eyeSpacing + dx - 1) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                        }
                    }
                    // Pupil
                    ctx.fillStyle = eyePupil;
                    ctx.fillRect((centerX - eyeSpacing) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing - 1) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    // Sparkle
                    ctx.fillStyle = '#fff';
                    ctx.fillRect((centerX - eyeSpacing - 1) * pixelSize, (eyeY - 1) * pixelSize, pixelSize * 0.5, pixelSize * 0.5);
                    ctx.fillRect((centerX + eyeSpacing) * pixelSize, (eyeY - 1) * pixelSize, pixelSize * 0.5, pixelSize * 0.5);
                    break;
                    
                case 3: // Asymmetric chaos eyes
                    ctx.fillStyle = eyeGlow;
                    // Left eye - normal
                    ctx.fillRect((centerX - eyeSpacing) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    // Right eye - displaced
                    const offsetY = Math.floor(seededRandom(eyeSeed) * 3 - 1);
                    ctx.fillRect((centerX + eyeSpacing - 1) * pixelSize, (eyeY + offsetY) * pixelSize, pixelSize, pixelSize);
                    break;
                    
                case 4: // X eyes
                    ctx.fillStyle = '#ff0000';
                    // X pattern
                    ctx.fillRect((centerX - eyeSpacing - 1) * pixelSize, (eyeY - 1) * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX - eyeSpacing + 1) * pixelSize, (eyeY + 1) * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX - eyeSpacing - 1) * pixelSize, (eyeY + 1) * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX - eyeSpacing + 1) * pixelSize, (eyeY - 1) * pixelSize, pixelSize, pixelSize);
                    
                    ctx.fillRect((centerX + eyeSpacing - 2) * pixelSize, (eyeY - 1) * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing) * pixelSize, (eyeY + 1) * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing - 2) * pixelSize, (eyeY + 1) * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing) * pixelSize, (eyeY - 1) * pixelSize, pixelSize, pixelSize);
                    break;
                    
                case 5: // Cyclops
                    ctx.fillStyle = eyeGlow;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            ctx.fillRect((centerX + dx - 1) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                        }
                    }
                    ctx.fillStyle = eyePupil;
                    ctx.fillRect((centerX - 1) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    break;
                    
                case 6: // Triple eyes
                    ctx.fillStyle = eyeGlow;
                    ctx.fillRect((centerX - eyeSpacing - 3) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX - 1) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    ctx.fillRect((centerX + eyeSpacing + 2) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize);
                    break;
                    
                case 7: // Sleepy/happy
                    ctx.fillStyle = colors.primary;
                    for (let dx = -2; dx <= 2; dx++) {
                        ctx.fillRect((centerX - eyeSpacing + dx) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize * 0.5);
                        ctx.fillRect((centerX + eyeSpacing + dx - 2) * pixelSize, eyeY * pixelSize, pixelSize, pixelSize * 0.5);
                    }
                    break;
                    
                case 8: // Spiral eyes
                    ctx.fillStyle = eyeGlow;
                    const spiralPattern = [[0,0], [1,0], [1,1], [0,1], [-1,1], [-1,0], [-1,-1], [0,-1]];
                    spiralPattern.forEach(([dx, dy], i) => {
                        if (i < 4 + Math.floor(chaosLevel / 25)) {
                            ctx.fillRect((centerX - eyeSpacing + dx) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                            ctx.fillRect((centerX + eyeSpacing + dx - 1) * pixelSize, (eyeY + dy) * pixelSize, pixelSize, pixelSize);
                        }
                    });
                    break;
                    
                case 9: // Glitch eyes
                    for (let i = 0; i < 3 + Math.floor(chaosLevel / 30); i++) {
                        const glitchX = Math.floor(seededRandom(eyeSeed + i * 10) * 3 - 1);
                        const glitchY = Math.floor(seededRandom(eyeSeed + i * 20) * 3 - 1);
                        ctx.fillStyle = i === 0 ? eyeGlow : (i === 1 ? colors.accent : colors.secondary);
                        ctx.fillRect((centerX - eyeSpacing + glitchX) * pixelSize, (eyeY + glitchY) * pixelSize, pixelSize, pixelSize);
                        ctx.fillRect((centerX + eyeSpacing + glitchX - 1) * pixelSize, (eyeY + glitchY) * pixelSize, pixelSize, pixelSize);
                    }
                    break;
            }

            // Add mouth based on chaos level
            if (chaosLevel > 40 && size >= 24) {
                const mouthY = Math.floor(size * 0.6);
                const mouthType = (seed + 2000) % 4;
                
                ctx.fillStyle = colors.accent;
                switch(mouthType) {
                    case 0: // Smile
                        for (let dx = -2; dx <= 2; dx++) {
                            const dy = Math.abs(dx) < 2 ? 1 : 0;
                            ctx.fillRect((centerX + dx) * pixelSize, (mouthY + dy) * pixelSize, pixelSize, pixelSize * 0.5);
                        }
                        break;
                    case 1: // Frown
                        for (let dx = -2; dx <= 2; dx++) {
                            const dy = Math.abs(dx) < 2 ? 0 : 1;
                            ctx.fillRect((centerX + dx) * pixelSize, (mouthY + dy) * pixelSize, pixelSize, pixelSize * 0.5);
                        }
                        break;
                    case 2: // Open
                        ctx.fillStyle = '#000';
                        ctx.fillRect((centerX - 1) * pixelSize, mouthY * pixelSize, pixelSize * 2, pixelSize * 2);
                        ctx.fillStyle = colors.accent;
                        ctx.strokeRect((centerX - 1) * pixelSize, mouthY * pixelSize, pixelSize * 2, pixelSize * 2);
                        break;
                    case 3: // Zigzag
                        for (let dx = -2; dx <= 2; dx++) {
                            const dy = dx % 2;
                            ctx.fillRect((centerX + dx) * pixelSize, (mouthY + dy) * pixelSize, pixelSize, pixelSize * 0.5);
                        }
                        break;
                }
            }

            // Add chaotic accessories
            if (chaosLevel > 60) {
                const accessorySeed = seed + 3000;
                const accessoryType = seededRandom(accessorySeed) * 3;
                
                if (accessoryType < 1) { // Antenna
                    ctx.fillStyle = colors.glow;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect((centerX - 1) * pixelSize, i * pixelSize, pixelSize, pixelSize);
                    }
                    ctx.fillRect((centerX - 2) * pixelSize, 0, pixelSize * 3, pixelSize);
                } else if (accessoryType < 2) { // Horns
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect((centerX - eyeSpacing - 2) * pixelSize, (eyeY - 3) * pixelSize, pixelSize, pixelSize * 2);
                    ctx.fillRect((centerX + eyeSpacing + 1) * pixelSize, (eyeY - 3) * pixelSize, pixelSize, pixelSize * 2);
                }
            }

            // Scan lines effect based on chaos
            if (chaosLevel > 20) {
                ctx.strokeStyle = `rgba(0, 255, 0, ${0.05 + chaosLevel / 1000})`;
                ctx.lineWidth = 1;
                const scanLineSpacing = Math.max(2, 6 - Math.floor(chaosLevel / 20));
                for (let i = 0; i < size; i++) {
                    if (i % scanLineSpacing === 0) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * pixelSize);
                        ctx.lineTo(canvas.width, i * pixelSize);
                        ctx.stroke();
                    }
                }
            }

            // Add glitch effects at high chaos
            if (chaosLevel > 80) {
                const glitchCount = Math.floor((chaosLevel - 80) / 5);
                for (let i = 0; i < glitchCount; i++) {
                    const glitchX = Math.floor(seededRandom(seed + i * 1000) * canvas.width);
                    const glitchY = Math.floor(seededRandom(seed + i * 2000) * canvas.height);
                    const glitchW = Math.floor(seededRandom(seed + i * 3000) * 20 + 5);
                    const glitchH = Math.floor(seededRandom(seed + i * 4000) * 20 + 5);
                    
                    ctx.fillStyle = `rgba(${Math.floor(Math.random() * 255)}, 255, 0, 0.3)`;
                    ctx.fillRect(glitchX, glitchY, glitchW, glitchH);
                }
            }

            return { 
                canvas, 
                dna, 
                dominantColor, 
                pattern, 
                eyeType,
                creatureType,
                bodyType,
                chaosLevel
            };
        }

        function generateArtQR(creatorData, index) {
            const qrSize = 256;
            const qrCanvasElement = document.getElementById(`qr-${index}`);
            if (!qrCanvasElement) {
                console.error('QR canvas not found for index:', index);
                return;
            }
            
            const ctx = qrCanvasElement.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // Generate QR code data URL
            const galleryUrl = document.getElementById('mintUrl').value + creatorData.dna;
            
            // Store data for export
            qrCanvasElement.qrData = galleryUrl;
            qrCanvasElement.creatorData = creatorData;
            
            // Create a temporary div for QRCode.js
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            document.body.appendChild(tempDiv);
            
            try {
                // Generate QR code using qrcode.js
                const qr = new QRCode(tempDiv, {
                    text: galleryUrl,
                    width: qrSize,
                    height: qrSize,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                // Wait for QR code to render
                setTimeout(() => {
                    const qrImg = tempDiv.querySelector('img');
                    if (qrImg) {
                        qrImg.onload = function() {
                            // Clear canvas
                            ctx.clearRect(0, 0, qrSize, qrSize);
                            
                            // Draw QR code
                            ctx.drawImage(qrImg, 0, 0, qrSize, qrSize);

                            // Get QR code pixel data
                            const imageData = ctx.getImageData(0, 0, qrSize, qrSize);
                            const data = imageData.data;

                            // Get breed color
                            const breedColor = hexToRgb(creatorData.dominantColor);
                            
                            // Apply colors and effects based on chaos level
                            for (let y = 0; y < qrSize; y++) {
                                for (let x = 0; x < qrSize; x++) {
                                    const i = (y * qrSize + x) * 4;
                                    
                                    if (data[i] < 50 && data[i + 3] === 255) { // Black QR module
                                        // Apply breed color with chaos variations
                                        if (breedColor) {
                                            const variation = 1 + (Math.sin(x * 0.1 + y * 0.1) * chaosLevel / 200);
                                            data[i] = Math.min(255, breedColor.r * variation);
                                            data[i + 1] = Math.min(255, breedColor.g * variation);
                                            data[i + 2] = Math.min(255, breedColor.b * variation);
                                        } else {
                                            data[i] = 0;
                                            data[i + 1] = 255;
                                            data[i + 2] = 0;
                                        }
                                    } else {
                                        // Background with subtle chaos noise
                                        const noise = chaosLevel > 50 ? Math.random() * (chaosLevel / 500) : 0;
                                        data[i] = Math.floor(20 * noise);
                                        data[i + 1] = Math.floor(20 * noise);
                                        data[i + 2] = Math.floor(20 * noise);
                                    }
                                }
                            }

                            ctx.putImageData(imageData, 0, 0);

                            // Calculate optimal protolite size
                            const creatorSize = creatorData.canvas.width;
                            const maxOverlaySize = qrSize * 0.42;
                            const scale = maxOverlaySize / creatorSize;
                            const scaledSize = creatorSize * scale;
                            const offsetX = (qrSize - scaledSize) / 2;
                            const offsetY = (qrSize - scaledSize) / 2;

                            // Create background for the creator
                            const centerX = qrSize / 2;
                            const centerY = qrSize / 2;
                            const radius = scaledSize / 2 + 6;
                            
                            // Chaos-influenced background
                            if (chaosLevel > 30) {
                                // Glitchy/irregular shape
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.beginPath();
                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                    const radiusVar = radius + Math.sin(angle * 3) * (chaosLevel / 10);
                                    const x = centerX + Math.cos(angle) * radiusVar;
                                    const y = centerY + Math.sin(angle) * radiusVar;
                                    if (angle === 0) {
                                        ctx.moveTo(x, y);
                                    } else {
                                        ctx.lineTo(x, y);
                                    }
                                }
                                ctx.closePath();
                                ctx.fill();
                            } else {
                                // Standard circular background
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, radius + 4, 0, Math.PI * 2);
                                ctx.fill();
                                
                                ctx.fillStyle = '#000';
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // Draw the creator
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, scaledSize / 2, 0, Math.PI * 2);
                            ctx.clip();
                            ctx.drawImage(creatorData.canvas, offsetX, offsetY, scaledSize, scaledSize);
                            ctx.restore();
                            
                            // Add effects around protolite
                            ctx.shadowColor = creatorData.dominantColor;
                            ctx.shadowBlur = 15 + chaosLevel / 5;
                            ctx.strokeStyle = creatorData.dominantColor;
                            ctx.lineWidth = 2 + Math.floor(chaosLevel / 30);
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Add chaos effects
                            if (chaosLevel > 60) {
                                ctx.shadowBlur = 0;
                                // Lightning effect
                                ctx.strokeStyle = `rgba(255, 255, 0, ${chaosLevel / 200})`;
                                ctx.lineWidth = 1;
                                for (let i = 0; i < 3; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(centerX, centerY);
                                    const angle = Math.random() * Math.PI * 2;
                                    const endX = centerX + Math.cos(angle) * (radius + 20);
                                    const endY = centerY + Math.sin(angle) * (radius + 20);
                                    ctx.lineTo(endX, endY);
                                    ctx.stroke();
                                }
                            }

                            // Add scan lines
                            if (breedColor) {
                                ctx.strokeStyle = `rgba(${breedColor.r}, ${breedColor.g}, ${breedColor.b}, ${0.08 + chaosLevel / 1000})`;
                            } else {
                                ctx.strokeStyle = `rgba(0, 255, 0, ${0.08 + chaosLevel / 1000})`;
                            }
                            ctx.lineWidth = 1;
                            for (let y = 0; y < qrSize; y += Math.max(2, 6 - Math.floor(chaosLevel / 25))) {
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(qrSize, y);
                                ctx.stroke();
                            }
                            
                            // Clean up
                            document.body.removeChild(tempDiv);
                        };
                        
                        // If image is already loaded
                        if (qrImg.complete) {
                            qrImg.onload();
                        }
                    } else {
                        console.error('QR image not found');
                        document.body.removeChild(tempDiv);
                    }
                }, 100);
                
            } catch (err) {
                console.error('QR generation error:', err);
                document.body.removeChild(tempDiv);
                // Fallback
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, qrSize, qrSize);
                ctx.fillStyle = '#0f0';
                ctx.font = '12px monospace';
                ctx.fillText('QR ERROR', qrSize/2 - 30, qrSize/2);
            }
        }

        function hexToRgb(color) {
            // Handle HSL color format
            if (color.startsWith('hsl')) {
                const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (match) {
                    const h = parseInt(match[1]) / 360;
                    const s = parseInt(match[2]) / 100;
                    const l = parseInt(match[3]) / 100;
                    
                    let r, g, b;
                    if (s === 0) {
                        r = g = b = l;
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    
                    return {
                        r: Math.round(r * 255),
                        g: Math.round(g * 255),
                        b: Math.round(b * 255)
                    };
                }
            }
            return null;
        }

        function generateCreators() {
            const container = document.getElementById('creators');
            container.innerHTML = '';
            creatorData = [];
            creatorCount = 0;
            
            const parentSize = parseInt(document.getElementById('parentSize').value);
            document.getElementById('creatorTitle').textContent = `CREATOR ORGANISMS WITH QR GALLERIES (${parentSize}x${parentSize}) - CHAOS: ${chaosLevel}%`;
            
            for (let i = 0; i < 6; i++) {
                const dna = generateDNA();
                const result = generateProtolite(dna, parentSize);
                
                const containerDiv = document.createElement('div');
                containerDiv.className = 'creator-container';
                
                const dualDiv = document.createElement('div');
                dualDiv.className = 'creator-dual';
                
                // Creator item
                const creatorItem = document.createElement('div');
                creatorItem.className = 'creator-item';
                
                const creatorLabel = document.createElement('div');
                creatorLabel.className = 'item-label';
                creatorLabel.textContent = 'PROTOLITE';
                
                result.canvas.className = 'creator-canvas';
                result.canvas.style.width = parentSize === 36 ? '216px' : '144px';
                result.canvas.style.height = parentSize === 36 ? '216px' : '144px';
                result.canvas.onclick = () => breed(result, i);
                
                creatorItem.appendChild(creatorLabel);
                creatorItem.appendChild(result.canvas);
                
                // QR item
                const qrItem = document.createElement('div');
                qrItem.className = 'creator-item';
                
                const qrLabel = document.createElement('div');
                qrLabel.className = 'item-label qr-label';
                qrLabel.textContent = 'QR GALLERY';
                
                const qrCanvas = document.createElement('canvas');
                qrCanvas.id = `qr-${i}`;
                qrCanvas.className = 'qr-canvas';
                qrCanvas.width = 256;
                qrCanvas.height = 256;
                qrCanvas.style.width = parentSize === 36 ? '216px' : '144px';
                qrCanvas.style.height = parentSize === 36 ? '216px' : '144px';
                
                const downloadContainer = document.createElement('div');
                downloadContainer.style.marginTop = '5px';
                
                const downloadPngBtn = document.createElement('button');
                downloadPngBtn.className = 'download-btn';
                downloadPngBtn.textContent = 'PNG';
                downloadPngBtn.onclick = () => downloadQR(qrCanvas, `creator_${i}_qr.png`, 'png');
                
                const downloadSvgBtn = document.createElement('button');
                downloadSvgBtn.className = 'download-btn';
                downloadSvgBtn.textContent = 'SVG';
                downloadSvgBtn.style.marginLeft = '5px';
                downloadSvgBtn.onclick = () => downloadQR(qrCanvas, `creator_${i}_qr.svg`, 'svg');
                
                downloadContainer.appendChild(downloadPngBtn);
                downloadContainer.appendChild(downloadSvgBtn);
                
                qrItem.appendChild(qrLabel);
                qrItem.appendChild(qrCanvas);
                qrItem.appendChild(downloadContainer);
                
                dualDiv.appendChild(creatorItem);
                dualDiv.appendChild(qrItem);
                
                const idLabel = document.createElement('div');
                idLabel.className = 'id-label';
                idLabel.innerHTML = `${result.creatureType}`;
                
                const dnaLabel = document.createElement('div');
                dnaLabel.className = 'dna-display';
                dnaLabel.textContent = `DNA: ${result.dna} | BODY: TYPE-${result.bodyType}`;
                
                containerDiv.appendChild(dualDiv);
                containerDiv.appendChild(idLabel);
                containerDiv.appendChild(dnaLabel);
                container.appendChild(containerDiv);
                
                creatorData[i] = result;
                creatorCount++;
                
                // Generate QR code
                setTimeout(() => generateArtQR(result, i), 100);
            }
            
            updateStats();
        }

        function downloadQR(canvas, filename, format) {
            if (format === 'png') {
                const link = document.createElement('a');
                link.download = filename;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } else if (format === 'svg') {
                const galleryUrl = canvas.qrData;
                const creatorData = canvas.creatorData;
                
                if (!galleryUrl || !creatorData) {
                    console.error('Missing data for SVG generation');
                    alert('Please wait for QR code to generate before downloading SVG');
                    return;
                }
                
                const svgString = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="256" height="256" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <radialGradient id="artGradient" cx="50%" cy="50%" r="30%">
            <stop offset="0%" stop-color="${creatorData.dominantColor}" stop-opacity="1"/>
            <stop offset="100%" stop-color="${creatorData.dominantColor}" stop-opacity="0"/>
        </radialGradient>
    </defs>
    <rect width="256" height="256" fill="white"/>
    <image href="${canvas.toDataURL('image/png')}" x="0" y="0" width="256" height="256"/>
    <rect width="256" height="256" fill="url(#artGradient)" opacity="0.3" style="mix-blend-mode: multiply"/>
    <text x="128" y="250" text-anchor="middle" font-family="monospace" font-size="8" fill="#0f0">${galleryUrl.substring(0, 30)}...</text>
</svg>`;
                
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(svgBlob);
                
                const link = document.createElement('a');
                link.download = filename;
                link.href = url;
                link.click();
                
                URL.revokeObjectURL(url);
            }
        }

        function breed(parentData, parentIndex) {
            const container = document.getElementById('descendants');
            
            const childSize = parseInt(document.getElementById('childSize').value);
            document.getElementById('descendantTitle').textContent = `DESCENDANT MUTATIONS (${childSize}x${childSize})`;
            
            for (let i = 0; i < 3; i++) {
                const childDNA = generateDNA();
                const result = generateProtolite(childDNA, childSize, parentData);
                
                const card = document.createElement('div');
                card.className = 'descendant-card';
                
                result.canvas.className = 'descendant-canvas';
                result.canvas.style.width = childSize === 16 ? '96px' : '72px';
                result.canvas.style.height = childSize === 16 ? '96px' : '72px';
                
                const label = document.createElement('div');
                label.className = 'id-label descendant-label';
                let labelText = `${result.creatureType}-JR${i + 1}`;
                
                // Add mutation badge if type changed
                if (result.creatureType !== parentData.creatureType) {
                    labelText += '<span class="mutation-badge">MUTANT</span>';
                }
                
                label.innerHTML = labelText;
                
                const dnaLabel = document.createElement('div');
                dnaLabel.className = 'dna-display';
                dnaLabel.textContent = `DNA: ${result.dna}`;
                
                card.appendChild(result.canvas);
                card.appendChild(label);
                card.appendChild(dnaLabel);
                container.appendChild(card);
                
                descendantCount++;
            }
            
            updateStats();
        }

        function updateStats() {
            document.getElementById('stats').textContent = 
                `CREATORS: ${creatorCount} | QR GALLERIES: ${creatorCount} | DESCENDANTS: ${descendantCount} | CHAOS LEVEL: ${chaosLevel}%`;
        }

        function clearAll() {
            document.getElementById('creators').innerHTML = '';
            document.getElementById('descendants').innerHTML = '';
            creatorData = [];
            creatorCount = 0;
            descendantCount = 0;
            updateStats();
        }

        function exportAll() {
            const parentSize = parseInt(document.getElementById('parentSize').value);
            const childSize = parseInt(document.getElementById('childSize').value);
            const galleryUrl = document.getElementById('mintUrl').value;
            
            const descendantElements = document.querySelectorAll('.descendant-card');
            const descendants = [];
            descendantElements.forEach(card => {
                const dnaText = card.querySelector('.dna-display').textContent;
                const idText = card.querySelector('.id-label').innerText;
                descendants.push({
                    id: idText,
                    dna: dnaText.replace('DNA: ', '')
                });
            });
            
            const data = {
                protocol: "UBA_ART_PROTOCOL_V5_FUSION",
                timestamp: new Date().toISOString(),
                configuration: {
                    parentSize: `${parentSize}x${parentSize}`,
                    childSize: `${childSize}x${childSize}`,
                    evolutionRate: "15%",
                    chaosLevel: `${chaosLevel}%`,
                    galleryBaseUrl: galleryUrl
                },
                creators: creatorData.map((s, i) => ({
                    id: `CREATOR-${String(i + 1).padStart(3, '0')}`,
                    type: s.creatureType,
                    dna: s.dna,
                    dominantColor: s.dominantColor,
                    bodyType: s.bodyType,
                    eyeType: s.eyeType,
                    chaosLevel: s.chaosLevel,
                    qrGalleryUrl: galleryUrl + s.dna,
                    genetics: {
                        primaryHue: s.dominantColor.match(/hsl\((\d+),/)?.[1] || "0",
                        pattern: "fusion",
                        density: "variable",
                        asymmetry: chaosLevel > 50 ? "high" : "low"
                    }
                })),
                descendants: descendants,
                stats: {
                    totalCreators: creatorCount,
                    totalQRGalleries: creatorCount,
                    totalDescendants: descendantCount,
                    averageDescendantsPerCreator: creatorCount > 0 ? descendantCount / creatorCount : 0,
                    chaosInfluence: chaosLevel
                },
                usage: {
                    description: "V5 Fusion Protocol - Chaos-driven evolution with asymmetric mutations",
                    features: [
                        "Dynamic chaos slider for controlling mutation rate",
                        "10 different eye types including glitch and spiral",
                        "7 body types with asymmetric variations",
                        "Creature type inheritance with mutations",
                        "Mouth and accessory generation at high chaos",
                        "Glitch effects and visual artifacts"
                    ],
                    instructions: "Adjust chaos level to control creature complexity and mutation rate. High chaos creates more experimental forms."
                }
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `uba_protolite_dna_v5_fusion_chaos${chaosLevel}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Generate initial creators
        generateCreators();
    </script>
</body>
</html>
