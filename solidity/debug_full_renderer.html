<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width,user-scalable=no" />
</head>
<body>
    <style>
        html,body { background: black; } 
        body { overflow: hidden; margin: 0; padding: 0; display: flex; align-items: center; justify-content: center; height: 100vh; } 
        canvas { image-rendering: pixelated; width: 100vmin; height: 100vmin; border: 1px solid #333; }
    </style>
    <canvas id="canvas"></canvas>
    <div style="position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; font-size: 10px;">
        <div id="debug"></div>
    </div>
    <script>
        const debug = document.getElementById('debug');
        
        // Test with a kid
        const tokenId = 2;
        const dna = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
        const isKid = true;
        const parentDna = "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321";
        const size = 12;
        
        // Canvas setup
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const pixelSize = 6;
        canvas.width = 144;
        canvas.height = 144;
        ctx.imageSmoothingEnabled = false;
        const drawOffset = size === 12 ? 36 : 0;
        
        // Include minimal functions to test
        function hashCode(str){
            let hash=0;
            for(let i=0;i<str.length;i++){
                const char=str.charCodeAt(i);
                hash=((hash<<5)-hash)+char;
                hash=hash&hash;
            }
            return Math.abs(hash);
        }
        
        function dnaToColors(dna){
            const hash=hashCode(dna);
            const hue1=(hash%360);
            const saturation=80+(hash%20);
            const lightness=45+(hash%20);
            return{
                primary:`hsl(${hue1},${saturation}%,${lightness}%)`,
                secondary:`hsl(${hue1+120},${saturation}%,${lightness}%)`,
                accent:`hsl(${hue1+240},100%,50%)`,
                glow:`hsl(${(hue1+180)%360},100%,60%)`
            };
        }
        
        const seed=hashCode(dna);
        let seedValue=seed;
        function random(){
            seedValue=(seedValue*9301+49297)%233280;
            return seedValue/233280;
        }
        
        const colors=isKid&&parentDna!=="0x0"?dnaToColors(parentDna):dnaToColors(dna);
        
        debug.innerHTML = `Colors: ${JSON.stringify(colors)}<br>`;
        
        // Clear canvas
        ctx.fillStyle="#000";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        
        // Create grid
        const grid=Array(size).fill().map(()=>Array(size).fill("#000"));
        
        // Draw body
        const centerX=Math.floor(size/2);
        const centerY=Math.floor(size/2);
        const bodyStart=size===24?7:4;
        const bodyEnd=size===24?17:12;
        
        debug.innerHTML += `Body: ${bodyStart} to ${bodyEnd}<br>`;
        debug.innerHTML += `Center: ${centerX}, ${centerY}<br>`;
        
        let bodyPixels = 0;
        for(let y=bodyStart;y<bodyEnd;y++){
            for(let x=bodyStart;x<bodyEnd;x++){
                const distanceFromCenter=Math.abs(x-centerX)+Math.abs(y-centerY);
                const bodyChance=0.8-(distanceFromCenter*(size===24?0.07:0.1));
                if(random()<bodyChance){
                    grid[y][x]=colors.primary;
                    bodyPixels++;
                    if(x!==centerX){
                        const mirrorX=centerX-(x-centerX);
                        if(mirrorX>=0&&mirrorX<size){
                            grid[y][mirrorX]=colors.primary;
                            bodyPixels++;
                        }
                    }
                }
            }
        }
        
        debug.innerHTML += `Body pixels: ${bodyPixels}<br>`;
        
        // Draw eyes
        const eyeY=Math.floor(size*0.35);
        const eyeSpacing=Math.floor(size*0.25);
        let eyePixels = 0;
        for(let eye=0;eye<2;eye++){
            const eyeX=eye===0?centerX-eyeSpacing:centerX+eyeSpacing-1;
            if(eyeX>=0&&eyeX<size&&eyeY>=0&&eyeY<size){
                grid[eyeY][eyeX]="#ffffff";
                eyePixels++;
            }
        }
        
        debug.innerHTML += `Eye pixels: ${eyePixels}<br>`;
        
        // Draw mouth
        const mouthY=Math.floor(size*0.55);
        if(centerX>=0&&centerX<size&&mouthY>=0&&mouthY<size){
            grid[mouthY][centerX]="#ffffff";
        }
        
        // Count non-black pixels
        let nonBlackPixels = 0;
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                if(grid[y][x] !== "#000"){
                    nonBlackPixels++;
                }
            }
        }
        debug.innerHTML += `Non-black pixels: ${nonBlackPixels}<br>`;
        
        // Draw the grid with offset
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                ctx.fillStyle=grid[y][x];
                ctx.fillRect(drawOffset+x*pixelSize,drawOffset+y*pixelSize,pixelSize,pixelSize);
            }
        }
        
        // Draw grid lines for debugging
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 0.5;
        for(let i=0; i<=size; i++){
            ctx.beginPath();
            ctx.moveTo(drawOffset + i*pixelSize, drawOffset);
            ctx.lineTo(drawOffset + i*pixelSize, drawOffset + size*pixelSize);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(drawOffset, drawOffset + i*pixelSize);
            ctx.lineTo(drawOffset + size*pixelSize, drawOffset + i*pixelSize);
            ctx.stroke();
        }
        
        // Scanlines
        ctx.fillStyle="rgba(0,0,0,0.1)";
        for(let y=0;y<canvas.height;y+=2){
            ctx.fillRect(0,y,canvas.width,1);
        }
    </script>
</body>
</html>